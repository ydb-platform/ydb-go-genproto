// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v6.30.2
// source: protos/ydb_topic.proto

//go:build !protoopaque

package Ydb_Topic

import (
	Ydb "github.com/ydb-platform/ydb-go-genproto/protos/Ydb"
	Ydb_Issue "github.com/ydb-platform/ydb-go-genproto/protos/Ydb_Issue"
	Ydb_Operations "github.com/ydb-platform/ydb-go-genproto/protos/Ydb_Operations"
	Ydb_Scheme "github.com/ydb-platform/ydb-go-genproto/protos/Ydb_Scheme"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	_ "google.golang.org/protobuf/types/gofeaturespb"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Codec int32

const (
	Codec_CODEC_UNSPECIFIED Codec = 0
	Codec_CODEC_RAW         Codec = 1
	Codec_CODEC_GZIP        Codec = 2
	Codec_CODEC_LZOP        Codec = 3
	Codec_CODEC_ZSTD        Codec = 4
	// User-defined codecs from 10000 to 19999
	Codec_CODEC_CUSTOM Codec = 10000
)

// Enum value maps for Codec.
var (
	Codec_name = map[int32]string{
		0:     "CODEC_UNSPECIFIED",
		1:     "CODEC_RAW",
		2:     "CODEC_GZIP",
		3:     "CODEC_LZOP",
		4:     "CODEC_ZSTD",
		10000: "CODEC_CUSTOM",
	}
	Codec_value = map[string]int32{
		"CODEC_UNSPECIFIED": 0,
		"CODEC_RAW":         1,
		"CODEC_GZIP":        2,
		"CODEC_LZOP":        3,
		"CODEC_ZSTD":        4,
		"CODEC_CUSTOM":      10000,
	}
)

func (x Codec) Enum() *Codec {
	p := new(Codec)
	*p = x
	return p
}

func (x Codec) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Codec) Descriptor() protoreflect.EnumDescriptor {
	return file_protos_ydb_topic_proto_enumTypes[0].Descriptor()
}

func (Codec) Type() protoreflect.EnumType {
	return &file_protos_ydb_topic_proto_enumTypes[0]
}

func (x Codec) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

type AutoPartitioningStrategy int32

const (
	// The auto partitioning algorithm is not specified. The default value will be used.
	AutoPartitioningStrategy_AUTO_PARTITIONING_STRATEGY_UNSPECIFIED AutoPartitioningStrategy = 0
	// The auto partitioning is disabled.
	AutoPartitioningStrategy_AUTO_PARTITIONING_STRATEGY_DISABLED AutoPartitioningStrategy = 1
	// The auto partitioning algorithm will increase partitions count depending on the load characteristics.
	// The auto partitioning algorithm will never decrease the number of partitions.
	AutoPartitioningStrategy_AUTO_PARTITIONING_STRATEGY_SCALE_UP AutoPartitioningStrategy = 2
	// The auto partitioning algorithm will both increase and decrease partitions count depending on the load characteristics.
	AutoPartitioningStrategy_AUTO_PARTITIONING_STRATEGY_SCALE_UP_AND_DOWN AutoPartitioningStrategy = 3
	// The auto partitioning is paused.
	AutoPartitioningStrategy_AUTO_PARTITIONING_STRATEGY_PAUSED AutoPartitioningStrategy = 4
)

// Enum value maps for AutoPartitioningStrategy.
var (
	AutoPartitioningStrategy_name = map[int32]string{
		0: "AUTO_PARTITIONING_STRATEGY_UNSPECIFIED",
		1: "AUTO_PARTITIONING_STRATEGY_DISABLED",
		2: "AUTO_PARTITIONING_STRATEGY_SCALE_UP",
		3: "AUTO_PARTITIONING_STRATEGY_SCALE_UP_AND_DOWN",
		4: "AUTO_PARTITIONING_STRATEGY_PAUSED",
	}
	AutoPartitioningStrategy_value = map[string]int32{
		"AUTO_PARTITIONING_STRATEGY_UNSPECIFIED":       0,
		"AUTO_PARTITIONING_STRATEGY_DISABLED":          1,
		"AUTO_PARTITIONING_STRATEGY_SCALE_UP":          2,
		"AUTO_PARTITIONING_STRATEGY_SCALE_UP_AND_DOWN": 3,
		"AUTO_PARTITIONING_STRATEGY_PAUSED":            4,
	}
)

func (x AutoPartitioningStrategy) Enum() *AutoPartitioningStrategy {
	p := new(AutoPartitioningStrategy)
	*p = x
	return p
}

func (x AutoPartitioningStrategy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AutoPartitioningStrategy) Descriptor() protoreflect.EnumDescriptor {
	return file_protos_ydb_topic_proto_enumTypes[1].Descriptor()
}

func (AutoPartitioningStrategy) Type() protoreflect.EnumType {
	return &file_protos_ydb_topic_proto_enumTypes[1]
}

func (x AutoPartitioningStrategy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Metering mode specifies the method used to determine consumption of resources by the topic.
// This settings will have an effect only in a serverless database.
type MeteringMode int32

const (
	// Use default
	MeteringMode_METERING_MODE_UNSPECIFIED MeteringMode = 0
	// Metering based on resource reservation
	MeteringMode_METERING_MODE_RESERVED_CAPACITY MeteringMode = 1
	// Metering based on actual consumption. Default.
	MeteringMode_METERING_MODE_REQUEST_UNITS MeteringMode = 2
)

// Enum value maps for MeteringMode.
var (
	MeteringMode_name = map[int32]string{
		0: "METERING_MODE_UNSPECIFIED",
		1: "METERING_MODE_RESERVED_CAPACITY",
		2: "METERING_MODE_REQUEST_UNITS",
	}
	MeteringMode_value = map[string]int32{
		"METERING_MODE_UNSPECIFIED":       0,
		"METERING_MODE_RESERVED_CAPACITY": 1,
		"METERING_MODE_REQUEST_UNITS":     2,
	}
)

func (x MeteringMode) Enum() *MeteringMode {
	p := new(MeteringMode)
	*p = x
	return p
}

func (x MeteringMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MeteringMode) Descriptor() protoreflect.EnumDescriptor {
	return file_protos_ydb_topic_proto_enumTypes[2].Descriptor()
}

func (MeteringMode) Type() protoreflect.EnumType {
	return &file_protos_ydb_topic_proto_enumTypes[2]
}

func (x MeteringMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

type StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason int32

const (
	StreamWriteMessage_WriteResponse_WriteAck_Skipped_REASON_UNSPECIFIED     StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason = 0
	StreamWriteMessage_WriteResponse_WriteAck_Skipped_REASON_ALREADY_WRITTEN StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason = 1
)

// Enum value maps for StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason.
var (
	StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason_name = map[int32]string{
		0: "REASON_UNSPECIFIED",
		1: "REASON_ALREADY_WRITTEN",
	}
	StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason_value = map[string]int32{
		"REASON_UNSPECIFIED":     0,
		"REASON_ALREADY_WRITTEN": 1,
	}
)

func (x StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason) Enum() *StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason {
	p := new(StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason)
	*p = x
	return p
}

func (x StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason) Descriptor() protoreflect.EnumDescriptor {
	return file_protos_ydb_topic_proto_enumTypes[3].Descriptor()
}

func (StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason) Type() protoreflect.EnumType {
	return &file_protos_ydb_topic_proto_enumTypes[3]
}

func (x StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Description of supported codecs.
type SupportedCodecs struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// List of supported codecs.
	// See enum Codec above for values.
	Codecs        []int32 `protobuf:"varint,1,rep,packed,name=codecs" json:"codecs,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SupportedCodecs) Reset() {
	*x = SupportedCodecs{}
	mi := &file_protos_ydb_topic_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SupportedCodecs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SupportedCodecs) ProtoMessage() {}

func (x *SupportedCodecs) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *SupportedCodecs) GetCodecs() []int32 {
	if x != nil {
		return x.Codecs
	}
	return nil
}

func (x *SupportedCodecs) SetCodecs(v []int32) {
	x.Codecs = v
}

type SupportedCodecs_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// List of supported codecs.
	// See enum Codec above for values.
	Codecs []int32
}

func (b0 SupportedCodecs_builder) Build() *SupportedCodecs {
	m0 := &SupportedCodecs{}
	b, x := &b0, m0
	_, _ = b, x
	x.Codecs = b.Codecs
	return m0
}

// Represents range [start, end).
// I.e. (end - 1) is the greatest of offsets, included in non-empty range.
type OffsetsRange struct {
	state         protoimpl.MessageState `protogen:"hybrid.v1"`
	Start         *int64                 `protobuf:"varint,1,opt,name=start" json:"start,omitempty"`
	End           *int64                 `protobuf:"varint,2,opt,name=end" json:"end,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OffsetsRange) Reset() {
	*x = OffsetsRange{}
	mi := &file_protos_ydb_topic_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OffsetsRange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OffsetsRange) ProtoMessage() {}

func (x *OffsetsRange) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *OffsetsRange) GetStart() int64 {
	if x != nil && x.Start != nil {
		return *x.Start
	}
	return 0
}

func (x *OffsetsRange) GetEnd() int64 {
	if x != nil && x.End != nil {
		return *x.End
	}
	return 0
}

func (x *OffsetsRange) SetStart(v int64) {
	x.Start = &v
}

func (x *OffsetsRange) SetEnd(v int64) {
	x.End = &v
}

func (x *OffsetsRange) HasStart() bool {
	if x == nil {
		return false
	}
	return x.Start != nil
}

func (x *OffsetsRange) HasEnd() bool {
	if x == nil {
		return false
	}
	return x.End != nil
}

func (x *OffsetsRange) ClearStart() {
	x.Start = nil
}

func (x *OffsetsRange) ClearEnd() {
	x.End = nil
}

type OffsetsRange_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	Start *int64
	End   *int64
}

func (b0 OffsetsRange_builder) Build() *OffsetsRange {
	m0 := &OffsetsRange{}
	b, x := &b0, m0
	_, _ = b, x
	x.Start = b.Start
	x.End = b.End
	return m0
}

// In-session reauthentication and reauthorization, lets user increase session lifetime.
// Client should wait for UpdateTokenResponse before sending next UpdateTokenRequest.
type UpdateTokenRequest struct {
	state         protoimpl.MessageState `protogen:"hybrid.v1"`
	Token         *string                `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateTokenRequest) Reset() {
	*x = UpdateTokenRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateTokenRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateTokenRequest) ProtoMessage() {}

func (x *UpdateTokenRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *UpdateTokenRequest) GetToken() string {
	if x != nil && x.Token != nil {
		return *x.Token
	}
	return ""
}

func (x *UpdateTokenRequest) SetToken(v string) {
	x.Token = &v
}

func (x *UpdateTokenRequest) HasToken() bool {
	if x == nil {
		return false
	}
	return x.Token != nil
}

func (x *UpdateTokenRequest) ClearToken() {
	x.Token = nil
}

type UpdateTokenRequest_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	Token *string
}

func (b0 UpdateTokenRequest_builder) Build() *UpdateTokenRequest {
	m0 := &UpdateTokenRequest{}
	b, x := &b0, m0
	_, _ = b, x
	x.Token = b.Token
	return m0
}

type UpdateTokenResponse struct {
	state         protoimpl.MessageState `protogen:"hybrid.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateTokenResponse) Reset() {
	*x = UpdateTokenResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateTokenResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateTokenResponse) ProtoMessage() {}

func (x *UpdateTokenResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

type UpdateTokenResponse_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

}

func (b0 UpdateTokenResponse_builder) Build() *UpdateTokenResponse {
	m0 := &UpdateTokenResponse{}
	b, x := &b0, m0
	_, _ = b, x
	return m0
}

type PartitionWithGeneration struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Partition identifier.
	PartitionId *int64 `protobuf:"varint,1,opt,name=partition_id,json=partitionId" json:"partition_id,omitempty"`
	// Partition generation.
	Generation    *int64 `protobuf:"varint,2,opt,name=generation" json:"generation,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PartitionWithGeneration) Reset() {
	*x = PartitionWithGeneration{}
	mi := &file_protos_ydb_topic_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PartitionWithGeneration) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PartitionWithGeneration) ProtoMessage() {}

func (x *PartitionWithGeneration) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *PartitionWithGeneration) GetPartitionId() int64 {
	if x != nil && x.PartitionId != nil {
		return *x.PartitionId
	}
	return 0
}

func (x *PartitionWithGeneration) GetGeneration() int64 {
	if x != nil && x.Generation != nil {
		return *x.Generation
	}
	return 0
}

func (x *PartitionWithGeneration) SetPartitionId(v int64) {
	x.PartitionId = &v
}

func (x *PartitionWithGeneration) SetGeneration(v int64) {
	x.Generation = &v
}

func (x *PartitionWithGeneration) HasPartitionId() bool {
	if x == nil {
		return false
	}
	return x.PartitionId != nil
}

func (x *PartitionWithGeneration) HasGeneration() bool {
	if x == nil {
		return false
	}
	return x.Generation != nil
}

func (x *PartitionWithGeneration) ClearPartitionId() {
	x.PartitionId = nil
}

func (x *PartitionWithGeneration) ClearGeneration() {
	x.Generation = nil
}

type PartitionWithGeneration_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Partition identifier.
	PartitionId *int64
	// Partition generation.
	Generation *int64
}

func (b0 PartitionWithGeneration_builder) Build() *PartitionWithGeneration {
	m0 := &PartitionWithGeneration{}
	b, x := &b0, m0
	_, _ = b, x
	x.PartitionId = b.PartitionId
	x.Generation = b.Generation
	return m0
}

type MetadataItem struct {
	state         protoimpl.MessageState `protogen:"hybrid.v1"`
	Key           *string                `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value         []byte                 `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MetadataItem) Reset() {
	*x = MetadataItem{}
	mi := &file_protos_ydb_topic_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MetadataItem) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MetadataItem) ProtoMessage() {}

func (x *MetadataItem) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *MetadataItem) GetKey() string {
	if x != nil && x.Key != nil {
		return *x.Key
	}
	return ""
}

func (x *MetadataItem) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *MetadataItem) SetKey(v string) {
	x.Key = &v
}

func (x *MetadataItem) SetValue(v []byte) {
	if v == nil {
		v = []byte{}
	}
	x.Value = v
}

func (x *MetadataItem) HasKey() bool {
	if x == nil {
		return false
	}
	return x.Key != nil
}

func (x *MetadataItem) HasValue() bool {
	if x == nil {
		return false
	}
	return x.Value != nil
}

func (x *MetadataItem) ClearKey() {
	x.Key = nil
}

func (x *MetadataItem) ClearValue() {
	x.Value = nil
}

type MetadataItem_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	Key   *string
	Value []byte
}

func (b0 MetadataItem_builder) Build() *MetadataItem {
	m0 := &MetadataItem{}
	b, x := &b0, m0
	_, _ = b, x
	x.Key = b.Key
	x.Value = b.Value
	return m0
}

// Messages for bidirectional streaming rpc StreamWrite
type StreamWriteMessage struct {
	state         protoimpl.MessageState `protogen:"hybrid.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamWriteMessage) Reset() {
	*x = StreamWriteMessage{}
	mi := &file_protos_ydb_topic_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamWriteMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamWriteMessage) ProtoMessage() {}

func (x *StreamWriteMessage) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

type StreamWriteMessage_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

}

func (b0 StreamWriteMessage_builder) Build() *StreamWriteMessage {
	m0 := &StreamWriteMessage{}
	b, x := &b0, m0
	_, _ = b, x
	return m0
}

// Messages for bidirectional streaming rpc StreamRead
type StreamReadMessage struct {
	state         protoimpl.MessageState `protogen:"hybrid.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamReadMessage) Reset() {
	*x = StreamReadMessage{}
	mi := &file_protos_ydb_topic_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage) ProtoMessage() {}

func (x *StreamReadMessage) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

type StreamReadMessage_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

}

func (b0 StreamReadMessage_builder) Build() *StreamReadMessage {
	m0 := &StreamReadMessage{}
	b, x := &b0, m0
	_, _ = b, x
	return m0
}

// Messages for bidirectional streaming rpc StreamDirectRead
type StreamDirectReadMessage struct {
	state         protoimpl.MessageState `protogen:"hybrid.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamDirectReadMessage) Reset() {
	*x = StreamDirectReadMessage{}
	mi := &file_protos_ydb_topic_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamDirectReadMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamDirectReadMessage) ProtoMessage() {}

func (x *StreamDirectReadMessage) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

type StreamDirectReadMessage_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

}

func (b0 StreamDirectReadMessage_builder) Build() *StreamDirectReadMessage {
	m0 := &StreamDirectReadMessage{}
	b, x := &b0, m0
	_, _ = b, x
	return m0
}

type TransactionIdentity struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Transaction identifier from TableService.
	Id *string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// Session identifier from TableService.
	Session       *string `protobuf:"bytes,2,opt,name=session" json:"session,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TransactionIdentity) Reset() {
	*x = TransactionIdentity{}
	mi := &file_protos_ydb_topic_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TransactionIdentity) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TransactionIdentity) ProtoMessage() {}

func (x *TransactionIdentity) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *TransactionIdentity) GetId() string {
	if x != nil && x.Id != nil {
		return *x.Id
	}
	return ""
}

func (x *TransactionIdentity) GetSession() string {
	if x != nil && x.Session != nil {
		return *x.Session
	}
	return ""
}

func (x *TransactionIdentity) SetId(v string) {
	x.Id = &v
}

func (x *TransactionIdentity) SetSession(v string) {
	x.Session = &v
}

func (x *TransactionIdentity) HasId() bool {
	if x == nil {
		return false
	}
	return x.Id != nil
}

func (x *TransactionIdentity) HasSession() bool {
	if x == nil {
		return false
	}
	return x.Session != nil
}

func (x *TransactionIdentity) ClearId() {
	x.Id = nil
}

func (x *TransactionIdentity) ClearSession() {
	x.Session = nil
}

type TransactionIdentity_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Transaction identifier from TableService.
	Id *string
	// Session identifier from TableService.
	Session *string
}

func (b0 TransactionIdentity_builder) Build() *TransactionIdentity {
	m0 := &TransactionIdentity{}
	b, x := &b0, m0
	_, _ = b, x
	x.Id = b.Id
	x.Session = b.Session
	return m0
}

// Add offsets to transaction request sent from client to server.
type UpdateOffsetsInTransactionRequest struct {
	state           protoimpl.MessageState          `protogen:"hybrid.v1"`
	OperationParams *Ydb_Operations.OperationParams `protobuf:"bytes,1,opt,name=operation_params,json=operationParams" json:"operation_params,omitempty"`
	Tx              *TransactionIdentity            `protobuf:"bytes,2,opt,name=tx" json:"tx,omitempty"`
	// Ranges of offsets by topics.
	Topics        []*UpdateOffsetsInTransactionRequest_TopicOffsets `protobuf:"bytes,3,rep,name=topics" json:"topics,omitempty"`
	Consumer      *string                                           `protobuf:"bytes,4,opt,name=consumer" json:"consumer,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateOffsetsInTransactionRequest) Reset() {
	*x = UpdateOffsetsInTransactionRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateOffsetsInTransactionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateOffsetsInTransactionRequest) ProtoMessage() {}

func (x *UpdateOffsetsInTransactionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *UpdateOffsetsInTransactionRequest) GetOperationParams() *Ydb_Operations.OperationParams {
	if x != nil {
		return x.OperationParams
	}
	return nil
}

func (x *UpdateOffsetsInTransactionRequest) GetTx() *TransactionIdentity {
	if x != nil {
		return x.Tx
	}
	return nil
}

func (x *UpdateOffsetsInTransactionRequest) GetTopics() []*UpdateOffsetsInTransactionRequest_TopicOffsets {
	if x != nil {
		return x.Topics
	}
	return nil
}

func (x *UpdateOffsetsInTransactionRequest) GetConsumer() string {
	if x != nil && x.Consumer != nil {
		return *x.Consumer
	}
	return ""
}

func (x *UpdateOffsetsInTransactionRequest) SetOperationParams(v *Ydb_Operations.OperationParams) {
	x.OperationParams = v
}

func (x *UpdateOffsetsInTransactionRequest) SetTx(v *TransactionIdentity) {
	x.Tx = v
}

func (x *UpdateOffsetsInTransactionRequest) SetTopics(v []*UpdateOffsetsInTransactionRequest_TopicOffsets) {
	x.Topics = v
}

func (x *UpdateOffsetsInTransactionRequest) SetConsumer(v string) {
	x.Consumer = &v
}

func (x *UpdateOffsetsInTransactionRequest) HasOperationParams() bool {
	if x == nil {
		return false
	}
	return x.OperationParams != nil
}

func (x *UpdateOffsetsInTransactionRequest) HasTx() bool {
	if x == nil {
		return false
	}
	return x.Tx != nil
}

func (x *UpdateOffsetsInTransactionRequest) HasConsumer() bool {
	if x == nil {
		return false
	}
	return x.Consumer != nil
}

func (x *UpdateOffsetsInTransactionRequest) ClearOperationParams() {
	x.OperationParams = nil
}

func (x *UpdateOffsetsInTransactionRequest) ClearTx() {
	x.Tx = nil
}

func (x *UpdateOffsetsInTransactionRequest) ClearConsumer() {
	x.Consumer = nil
}

type UpdateOffsetsInTransactionRequest_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	OperationParams *Ydb_Operations.OperationParams
	Tx              *TransactionIdentity
	// Ranges of offsets by topics.
	Topics   []*UpdateOffsetsInTransactionRequest_TopicOffsets
	Consumer *string
}

func (b0 UpdateOffsetsInTransactionRequest_builder) Build() *UpdateOffsetsInTransactionRequest {
	m0 := &UpdateOffsetsInTransactionRequest{}
	b, x := &b0, m0
	_, _ = b, x
	x.OperationParams = b.OperationParams
	x.Tx = b.Tx
	x.Topics = b.Topics
	x.Consumer = b.Consumer
	return m0
}

// Add offsets to transaction response sent from server to client.
type UpdateOffsetsInTransactionResponse struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Result of request will be inside operation.
	Operation     *Ydb_Operations.Operation `protobuf:"bytes,1,opt,name=operation" json:"operation,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateOffsetsInTransactionResponse) Reset() {
	*x = UpdateOffsetsInTransactionResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateOffsetsInTransactionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateOffsetsInTransactionResponse) ProtoMessage() {}

func (x *UpdateOffsetsInTransactionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *UpdateOffsetsInTransactionResponse) GetOperation() *Ydb_Operations.Operation {
	if x != nil {
		return x.Operation
	}
	return nil
}

func (x *UpdateOffsetsInTransactionResponse) SetOperation(v *Ydb_Operations.Operation) {
	x.Operation = v
}

func (x *UpdateOffsetsInTransactionResponse) HasOperation() bool {
	if x == nil {
		return false
	}
	return x.Operation != nil
}

func (x *UpdateOffsetsInTransactionResponse) ClearOperation() {
	x.Operation = nil
}

type UpdateOffsetsInTransactionResponse_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Result of request will be inside operation.
	Operation *Ydb_Operations.Operation
}

func (b0 UpdateOffsetsInTransactionResponse_builder) Build() *UpdateOffsetsInTransactionResponse {
	m0 := &UpdateOffsetsInTransactionResponse{}
	b, x := &b0, m0
	_, _ = b, x
	x.Operation = b.Operation
	return m0
}

// Add offsets to transaction result message that will be inside UpdateOffsetsInTransactionResponse.operation.
type UpdateOffsetsInTransactionResult struct {
	state         protoimpl.MessageState `protogen:"hybrid.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateOffsetsInTransactionResult) Reset() {
	*x = UpdateOffsetsInTransactionResult{}
	mi := &file_protos_ydb_topic_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateOffsetsInTransactionResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateOffsetsInTransactionResult) ProtoMessage() {}

func (x *UpdateOffsetsInTransactionResult) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

type UpdateOffsetsInTransactionResult_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

}

func (b0 UpdateOffsetsInTransactionResult_builder) Build() *UpdateOffsetsInTransactionResult {
	m0 := &UpdateOffsetsInTransactionResult{}
	b, x := &b0, m0
	_, _ = b, x
	return m0
}

// Commit offset request sent from client to server.
type CommitOffsetRequest struct {
	state           protoimpl.MessageState          `protogen:"hybrid.v1"`
	OperationParams *Ydb_Operations.OperationParams `protobuf:"bytes,1,opt,name=operation_params,json=operationParams" json:"operation_params,omitempty"`
	// Topic path of partition.
	Path *string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	// Partition identifier.
	PartitionId *int64 `protobuf:"varint,3,opt,name=partition_id,json=partitionId" json:"partition_id,omitempty"`
	// Path of consumer.
	Consumer *string `protobuf:"bytes,4,opt,name=consumer" json:"consumer,omitempty"`
	// Processed offset.
	Offset        *int64 `protobuf:"varint,5,opt,name=offset" json:"offset,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CommitOffsetRequest) Reset() {
	*x = CommitOffsetRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CommitOffsetRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommitOffsetRequest) ProtoMessage() {}

func (x *CommitOffsetRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *CommitOffsetRequest) GetOperationParams() *Ydb_Operations.OperationParams {
	if x != nil {
		return x.OperationParams
	}
	return nil
}

func (x *CommitOffsetRequest) GetPath() string {
	if x != nil && x.Path != nil {
		return *x.Path
	}
	return ""
}

func (x *CommitOffsetRequest) GetPartitionId() int64 {
	if x != nil && x.PartitionId != nil {
		return *x.PartitionId
	}
	return 0
}

func (x *CommitOffsetRequest) GetConsumer() string {
	if x != nil && x.Consumer != nil {
		return *x.Consumer
	}
	return ""
}

func (x *CommitOffsetRequest) GetOffset() int64 {
	if x != nil && x.Offset != nil {
		return *x.Offset
	}
	return 0
}

func (x *CommitOffsetRequest) SetOperationParams(v *Ydb_Operations.OperationParams) {
	x.OperationParams = v
}

func (x *CommitOffsetRequest) SetPath(v string) {
	x.Path = &v
}

func (x *CommitOffsetRequest) SetPartitionId(v int64) {
	x.PartitionId = &v
}

func (x *CommitOffsetRequest) SetConsumer(v string) {
	x.Consumer = &v
}

func (x *CommitOffsetRequest) SetOffset(v int64) {
	x.Offset = &v
}

func (x *CommitOffsetRequest) HasOperationParams() bool {
	if x == nil {
		return false
	}
	return x.OperationParams != nil
}

func (x *CommitOffsetRequest) HasPath() bool {
	if x == nil {
		return false
	}
	return x.Path != nil
}

func (x *CommitOffsetRequest) HasPartitionId() bool {
	if x == nil {
		return false
	}
	return x.PartitionId != nil
}

func (x *CommitOffsetRequest) HasConsumer() bool {
	if x == nil {
		return false
	}
	return x.Consumer != nil
}

func (x *CommitOffsetRequest) HasOffset() bool {
	if x == nil {
		return false
	}
	return x.Offset != nil
}

func (x *CommitOffsetRequest) ClearOperationParams() {
	x.OperationParams = nil
}

func (x *CommitOffsetRequest) ClearPath() {
	x.Path = nil
}

func (x *CommitOffsetRequest) ClearPartitionId() {
	x.PartitionId = nil
}

func (x *CommitOffsetRequest) ClearConsumer() {
	x.Consumer = nil
}

func (x *CommitOffsetRequest) ClearOffset() {
	x.Offset = nil
}

type CommitOffsetRequest_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	OperationParams *Ydb_Operations.OperationParams
	// Topic path of partition.
	Path *string
	// Partition identifier.
	PartitionId *int64
	// Path of consumer.
	Consumer *string
	// Processed offset.
	Offset *int64
}

func (b0 CommitOffsetRequest_builder) Build() *CommitOffsetRequest {
	m0 := &CommitOffsetRequest{}
	b, x := &b0, m0
	_, _ = b, x
	x.OperationParams = b.OperationParams
	x.Path = b.Path
	x.PartitionId = b.PartitionId
	x.Consumer = b.Consumer
	x.Offset = b.Offset
	return m0
}

// Commit offset response sent from server to client.
type CommitOffsetResponse struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Result of request will be inside operation.
	Operation     *Ydb_Operations.Operation `protobuf:"bytes,1,opt,name=operation" json:"operation,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CommitOffsetResponse) Reset() {
	*x = CommitOffsetResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CommitOffsetResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommitOffsetResponse) ProtoMessage() {}

func (x *CommitOffsetResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *CommitOffsetResponse) GetOperation() *Ydb_Operations.Operation {
	if x != nil {
		return x.Operation
	}
	return nil
}

func (x *CommitOffsetResponse) SetOperation(v *Ydb_Operations.Operation) {
	x.Operation = v
}

func (x *CommitOffsetResponse) HasOperation() bool {
	if x == nil {
		return false
	}
	return x.Operation != nil
}

func (x *CommitOffsetResponse) ClearOperation() {
	x.Operation = nil
}

type CommitOffsetResponse_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Result of request will be inside operation.
	Operation *Ydb_Operations.Operation
}

func (b0 CommitOffsetResponse_builder) Build() *CommitOffsetResponse {
	m0 := &CommitOffsetResponse{}
	b, x := &b0, m0
	_, _ = b, x
	x.Operation = b.Operation
	return m0
}

// Commit offset result message inside CommitOffsetResponse.operation.
type CommitOffsetResult struct {
	state         protoimpl.MessageState `protogen:"hybrid.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CommitOffsetResult) Reset() {
	*x = CommitOffsetResult{}
	mi := &file_protos_ydb_topic_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CommitOffsetResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommitOffsetResult) ProtoMessage() {}

func (x *CommitOffsetResult) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

type CommitOffsetResult_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

}

func (b0 CommitOffsetResult_builder) Build() *CommitOffsetResult {
	m0 := &CommitOffsetResult{}
	b, x := &b0, m0
	_, _ = b, x
	return m0
}

// message representing statistics by several windows
type MultipleWindowsStat struct {
	state         protoimpl.MessageState `protogen:"hybrid.v1"`
	PerMinute     *int64                 `protobuf:"varint,1,opt,name=per_minute,json=perMinute" json:"per_minute,omitempty"`
	PerHour       *int64                 `protobuf:"varint,2,opt,name=per_hour,json=perHour" json:"per_hour,omitempty"`
	PerDay        *int64                 `protobuf:"varint,3,opt,name=per_day,json=perDay" json:"per_day,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MultipleWindowsStat) Reset() {
	*x = MultipleWindowsStat{}
	mi := &file_protos_ydb_topic_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MultipleWindowsStat) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MultipleWindowsStat) ProtoMessage() {}

func (x *MultipleWindowsStat) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *MultipleWindowsStat) GetPerMinute() int64 {
	if x != nil && x.PerMinute != nil {
		return *x.PerMinute
	}
	return 0
}

func (x *MultipleWindowsStat) GetPerHour() int64 {
	if x != nil && x.PerHour != nil {
		return *x.PerHour
	}
	return 0
}

func (x *MultipleWindowsStat) GetPerDay() int64 {
	if x != nil && x.PerDay != nil {
		return *x.PerDay
	}
	return 0
}

func (x *MultipleWindowsStat) SetPerMinute(v int64) {
	x.PerMinute = &v
}

func (x *MultipleWindowsStat) SetPerHour(v int64) {
	x.PerHour = &v
}

func (x *MultipleWindowsStat) SetPerDay(v int64) {
	x.PerDay = &v
}

func (x *MultipleWindowsStat) HasPerMinute() bool {
	if x == nil {
		return false
	}
	return x.PerMinute != nil
}

func (x *MultipleWindowsStat) HasPerHour() bool {
	if x == nil {
		return false
	}
	return x.PerHour != nil
}

func (x *MultipleWindowsStat) HasPerDay() bool {
	if x == nil {
		return false
	}
	return x.PerDay != nil
}

func (x *MultipleWindowsStat) ClearPerMinute() {
	x.PerMinute = nil
}

func (x *MultipleWindowsStat) ClearPerHour() {
	x.PerHour = nil
}

func (x *MultipleWindowsStat) ClearPerDay() {
	x.PerDay = nil
}

type MultipleWindowsStat_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	PerMinute *int64
	PerHour   *int64
	PerDay    *int64
}

func (b0 MultipleWindowsStat_builder) Build() *MultipleWindowsStat {
	m0 := &MultipleWindowsStat{}
	b, x := &b0, m0
	_, _ = b, x
	x.PerMinute = b.PerMinute
	x.PerHour = b.PerHour
	x.PerDay = b.PerDay
	return m0
}

// Consumer description.
type Consumer struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Must have valid not empty name as a key.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Consumer may be marked as 'important'. It means messages for this consumer will never expire due to retention.
	// User should take care that such consumer never stalls, to prevent running out of disk space.
	// Flag that this consumer is important.
	Important *bool `protobuf:"varint,2,opt,name=important" json:"important,omitempty"`
	// All messages with smaller server written_at timestamp will be skipped.
	ReadFrom *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=read_from,json=readFrom" json:"read_from,omitempty"`
	// List of supported codecs by this consumer.
	// supported_codecs on topic must be contained inside this list.
	// If empty, codec compatibility check for the consumer is disabled.
	SupportedCodecs *SupportedCodecs `protobuf:"bytes,5,opt,name=supported_codecs,json=supportedCodecs" json:"supported_codecs,omitempty"`
	// Attributes of consumer
	Attributes map[string]string `protobuf:"bytes,6,rep,name=attributes" json:"attributes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Filled only when requested statistics in Describe*Request.
	ConsumerStats *Consumer_ConsumerStats `protobuf:"bytes,7,opt,name=consumer_stats,json=consumerStats" json:"consumer_stats,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Consumer) Reset() {
	*x = Consumer{}
	mi := &file_protos_ydb_topic_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Consumer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Consumer) ProtoMessage() {}

func (x *Consumer) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *Consumer) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *Consumer) GetImportant() bool {
	if x != nil && x.Important != nil {
		return *x.Important
	}
	return false
}

func (x *Consumer) GetReadFrom() *timestamppb.Timestamp {
	if x != nil {
		return x.ReadFrom
	}
	return nil
}

func (x *Consumer) GetSupportedCodecs() *SupportedCodecs {
	if x != nil {
		return x.SupportedCodecs
	}
	return nil
}

func (x *Consumer) GetAttributes() map[string]string {
	if x != nil {
		return x.Attributes
	}
	return nil
}

func (x *Consumer) GetConsumerStats() *Consumer_ConsumerStats {
	if x != nil {
		return x.ConsumerStats
	}
	return nil
}

func (x *Consumer) SetName(v string) {
	x.Name = &v
}

func (x *Consumer) SetImportant(v bool) {
	x.Important = &v
}

func (x *Consumer) SetReadFrom(v *timestamppb.Timestamp) {
	x.ReadFrom = v
}

func (x *Consumer) SetSupportedCodecs(v *SupportedCodecs) {
	x.SupportedCodecs = v
}

func (x *Consumer) SetAttributes(v map[string]string) {
	x.Attributes = v
}

func (x *Consumer) SetConsumerStats(v *Consumer_ConsumerStats) {
	x.ConsumerStats = v
}

func (x *Consumer) HasName() bool {
	if x == nil {
		return false
	}
	return x.Name != nil
}

func (x *Consumer) HasImportant() bool {
	if x == nil {
		return false
	}
	return x.Important != nil
}

func (x *Consumer) HasReadFrom() bool {
	if x == nil {
		return false
	}
	return x.ReadFrom != nil
}

func (x *Consumer) HasSupportedCodecs() bool {
	if x == nil {
		return false
	}
	return x.SupportedCodecs != nil
}

func (x *Consumer) HasConsumerStats() bool {
	if x == nil {
		return false
	}
	return x.ConsumerStats != nil
}

func (x *Consumer) ClearName() {
	x.Name = nil
}

func (x *Consumer) ClearImportant() {
	x.Important = nil
}

func (x *Consumer) ClearReadFrom() {
	x.ReadFrom = nil
}

func (x *Consumer) ClearSupportedCodecs() {
	x.SupportedCodecs = nil
}

func (x *Consumer) ClearConsumerStats() {
	x.ConsumerStats = nil
}

type Consumer_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Must have valid not empty name as a key.
	Name *string
	// Consumer may be marked as 'important'. It means messages for this consumer will never expire due to retention.
	// User should take care that such consumer never stalls, to prevent running out of disk space.
	// Flag that this consumer is important.
	Important *bool
	// All messages with smaller server written_at timestamp will be skipped.
	ReadFrom *timestamppb.Timestamp
	// List of supported codecs by this consumer.
	// supported_codecs on topic must be contained inside this list.
	// If empty, codec compatibility check for the consumer is disabled.
	SupportedCodecs *SupportedCodecs
	// Attributes of consumer
	Attributes map[string]string
	// Filled only when requested statistics in Describe*Request.
	ConsumerStats *Consumer_ConsumerStats
}

func (b0 Consumer_builder) Build() *Consumer {
	m0 := &Consumer{}
	b, x := &b0, m0
	_, _ = b, x
	x.Name = b.Name
	x.Important = b.Important
	x.ReadFrom = b.ReadFrom
	x.SupportedCodecs = b.SupportedCodecs
	x.Attributes = b.Attributes
	x.ConsumerStats = b.ConsumerStats
	return m0
}

// Consumer alter description.
type AlterConsumer struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Must have valid not empty name as a key.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Consumer may be marked as 'important'. It means messages for this consumer will never expire due to retention.
	// User should take care that such consumer never stalls, to prevent running out of disk space.
	// Flag that this consumer is important.
	SetImportant *bool `protobuf:"varint,2,opt,name=set_important,json=setImportant" json:"set_important,omitempty"`
	// All messages with smaller server written_at timestamp will be skipped.
	SetReadFrom *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=set_read_from,json=setReadFrom" json:"set_read_from,omitempty"`
	// List of supported codecs by this consumer.
	// supported_codecs on topic must be contained inside this list.
	// If empty, codec compatibility check for the consumer is disabled.
	SetSupportedCodecs *SupportedCodecs `protobuf:"bytes,5,opt,name=set_supported_codecs,json=setSupportedCodecs" json:"set_supported_codecs,omitempty"`
	// User and server attributes of consumer. Server attributes starts from "_" and will be validated by server.
	// Leave the value blank to drop an attribute.
	AlterAttributes map[string]string `protobuf:"bytes,6,rep,name=alter_attributes,json=alterAttributes" json:"alter_attributes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *AlterConsumer) Reset() {
	*x = AlterConsumer{}
	mi := &file_protos_ydb_topic_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AlterConsumer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AlterConsumer) ProtoMessage() {}

func (x *AlterConsumer) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *AlterConsumer) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *AlterConsumer) GetSetImportant() bool {
	if x != nil && x.SetImportant != nil {
		return *x.SetImportant
	}
	return false
}

func (x *AlterConsumer) GetSetReadFrom() *timestamppb.Timestamp {
	if x != nil {
		return x.SetReadFrom
	}
	return nil
}

func (x *AlterConsumer) GetSetSupportedCodecs() *SupportedCodecs {
	if x != nil {
		return x.SetSupportedCodecs
	}
	return nil
}

func (x *AlterConsumer) GetAlterAttributes() map[string]string {
	if x != nil {
		return x.AlterAttributes
	}
	return nil
}

func (x *AlterConsumer) SetName(v string) {
	x.Name = &v
}

func (x *AlterConsumer) SetSetImportant(v bool) {
	x.SetImportant = &v
}

func (x *AlterConsumer) SetSetReadFrom(v *timestamppb.Timestamp) {
	x.SetReadFrom = v
}

func (x *AlterConsumer) SetSetSupportedCodecs(v *SupportedCodecs) {
	x.SetSupportedCodecs = v
}

func (x *AlterConsumer) SetAlterAttributes(v map[string]string) {
	x.AlterAttributes = v
}

func (x *AlterConsumer) HasName() bool {
	if x == nil {
		return false
	}
	return x.Name != nil
}

func (x *AlterConsumer) HasSetImportant() bool {
	if x == nil {
		return false
	}
	return x.SetImportant != nil
}

func (x *AlterConsumer) HasSetReadFrom() bool {
	if x == nil {
		return false
	}
	return x.SetReadFrom != nil
}

func (x *AlterConsumer) HasSetSupportedCodecs() bool {
	if x == nil {
		return false
	}
	return x.SetSupportedCodecs != nil
}

func (x *AlterConsumer) ClearName() {
	x.Name = nil
}

func (x *AlterConsumer) ClearSetImportant() {
	x.SetImportant = nil
}

func (x *AlterConsumer) ClearSetReadFrom() {
	x.SetReadFrom = nil
}

func (x *AlterConsumer) ClearSetSupportedCodecs() {
	x.SetSupportedCodecs = nil
}

type AlterConsumer_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Must have valid not empty name as a key.
	Name *string
	// Consumer may be marked as 'important'. It means messages for this consumer will never expire due to retention.
	// User should take care that such consumer never stalls, to prevent running out of disk space.
	// Flag that this consumer is important.
	SetImportant *bool
	// All messages with smaller server written_at timestamp will be skipped.
	SetReadFrom *timestamppb.Timestamp
	// List of supported codecs by this consumer.
	// supported_codecs on topic must be contained inside this list.
	// If empty, codec compatibility check for the consumer is disabled.
	SetSupportedCodecs *SupportedCodecs
	// User and server attributes of consumer. Server attributes starts from "_" and will be validated by server.
	// Leave the value blank to drop an attribute.
	AlterAttributes map[string]string
}

func (b0 AlterConsumer_builder) Build() *AlterConsumer {
	m0 := &AlterConsumer{}
	b, x := &b0, m0
	_, _ = b, x
	x.Name = b.Name
	x.SetImportant = b.SetImportant
	x.SetReadFrom = b.SetReadFrom
	x.SetSupportedCodecs = b.SetSupportedCodecs
	x.AlterAttributes = b.AlterAttributes
	return m0
}

// Partitioning settings for topic.
type PartitioningSettings struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Auto merge would stop working when the partitions count reaches min_active_partitions
	// Zero value means default - 1.
	MinActivePartitions *int64 `protobuf:"varint,1,opt,name=min_active_partitions,json=minActivePartitions" json:"min_active_partitions,omitempty"`
	// Auto split would stop working when the partitions count reaches max_active_partitions
	// Zero value means default - 1.
	MaxActivePartitions *int64 `protobuf:"varint,3,opt,name=max_active_partitions,json=maxActivePartitions" json:"max_active_partitions,omitempty"`
	// Limit for total partition count, including active (open for write) and read-only partitions.
	// Zero value means default - 100.
	// Use max_active_partitions
	//
	// Deprecated: Marked as deprecated in protos/ydb_topic.proto.
	PartitionCountLimit *int64 `protobuf:"varint,2,opt,name=partition_count_limit,json=partitionCountLimit" json:"partition_count_limit,omitempty"`
	// Settings for the partitions count auto partitioning.
	AutoPartitioningSettings *AutoPartitioningSettings `protobuf:"bytes,4,opt,name=auto_partitioning_settings,json=autoPartitioningSettings" json:"auto_partitioning_settings,omitempty"`
	unknownFields            protoimpl.UnknownFields
	sizeCache                protoimpl.SizeCache
}

func (x *PartitioningSettings) Reset() {
	*x = PartitioningSettings{}
	mi := &file_protos_ydb_topic_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PartitioningSettings) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PartitioningSettings) ProtoMessage() {}

func (x *PartitioningSettings) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *PartitioningSettings) GetMinActivePartitions() int64 {
	if x != nil && x.MinActivePartitions != nil {
		return *x.MinActivePartitions
	}
	return 0
}

func (x *PartitioningSettings) GetMaxActivePartitions() int64 {
	if x != nil && x.MaxActivePartitions != nil {
		return *x.MaxActivePartitions
	}
	return 0
}

// Deprecated: Marked as deprecated in protos/ydb_topic.proto.
func (x *PartitioningSettings) GetPartitionCountLimit() int64 {
	if x != nil && x.PartitionCountLimit != nil {
		return *x.PartitionCountLimit
	}
	return 0
}

func (x *PartitioningSettings) GetAutoPartitioningSettings() *AutoPartitioningSettings {
	if x != nil {
		return x.AutoPartitioningSettings
	}
	return nil
}

func (x *PartitioningSettings) SetMinActivePartitions(v int64) {
	x.MinActivePartitions = &v
}

func (x *PartitioningSettings) SetMaxActivePartitions(v int64) {
	x.MaxActivePartitions = &v
}

// Deprecated: Marked as deprecated in protos/ydb_topic.proto.
func (x *PartitioningSettings) SetPartitionCountLimit(v int64) {
	x.PartitionCountLimit = &v
}

func (x *PartitioningSettings) SetAutoPartitioningSettings(v *AutoPartitioningSettings) {
	x.AutoPartitioningSettings = v
}

func (x *PartitioningSettings) HasMinActivePartitions() bool {
	if x == nil {
		return false
	}
	return x.MinActivePartitions != nil
}

func (x *PartitioningSettings) HasMaxActivePartitions() bool {
	if x == nil {
		return false
	}
	return x.MaxActivePartitions != nil
}

// Deprecated: Marked as deprecated in protos/ydb_topic.proto.
func (x *PartitioningSettings) HasPartitionCountLimit() bool {
	if x == nil {
		return false
	}
	return x.PartitionCountLimit != nil
}

func (x *PartitioningSettings) HasAutoPartitioningSettings() bool {
	if x == nil {
		return false
	}
	return x.AutoPartitioningSettings != nil
}

func (x *PartitioningSettings) ClearMinActivePartitions() {
	x.MinActivePartitions = nil
}

func (x *PartitioningSettings) ClearMaxActivePartitions() {
	x.MaxActivePartitions = nil
}

// Deprecated: Marked as deprecated in protos/ydb_topic.proto.
func (x *PartitioningSettings) ClearPartitionCountLimit() {
	x.PartitionCountLimit = nil
}

func (x *PartitioningSettings) ClearAutoPartitioningSettings() {
	x.AutoPartitioningSettings = nil
}

type PartitioningSettings_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Auto merge would stop working when the partitions count reaches min_active_partitions
	// Zero value means default - 1.
	MinActivePartitions *int64
	// Auto split would stop working when the partitions count reaches max_active_partitions
	// Zero value means default - 1.
	MaxActivePartitions *int64
	// Limit for total partition count, including active (open for write) and read-only partitions.
	// Zero value means default - 100.
	// Use max_active_partitions
	//
	// Deprecated: Marked as deprecated in protos/ydb_topic.proto.
	PartitionCountLimit *int64
	// Settings for the partitions count auto partitioning.
	AutoPartitioningSettings *AutoPartitioningSettings
}

func (b0 PartitioningSettings_builder) Build() *PartitioningSettings {
	m0 := &PartitioningSettings{}
	b, x := &b0, m0
	_, _ = b, x
	x.MinActivePartitions = b.MinActivePartitions
	x.MaxActivePartitions = b.MaxActivePartitions
	x.PartitionCountLimit = b.PartitionCountLimit
	x.AutoPartitioningSettings = b.AutoPartitioningSettings
	return m0
}

type AutoPartitioningSettings struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Strategy of auto partitioning.
	Strategy *AutoPartitioningStrategy `protobuf:"varint,1,opt,name=strategy,enum=Ydb.Topic.AutoPartitioningStrategy" json:"strategy,omitempty"`
	// Partition write speed auto partitioning options.
	PartitionWriteSpeed *AutoPartitioningWriteSpeedStrategy `protobuf:"bytes,2,opt,name=partition_write_speed,json=partitionWriteSpeed" json:"partition_write_speed,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *AutoPartitioningSettings) Reset() {
	*x = AutoPartitioningSettings{}
	mi := &file_protos_ydb_topic_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AutoPartitioningSettings) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AutoPartitioningSettings) ProtoMessage() {}

func (x *AutoPartitioningSettings) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *AutoPartitioningSettings) GetStrategy() AutoPartitioningStrategy {
	if x != nil && x.Strategy != nil {
		return *x.Strategy
	}
	return AutoPartitioningStrategy_AUTO_PARTITIONING_STRATEGY_UNSPECIFIED
}

func (x *AutoPartitioningSettings) GetPartitionWriteSpeed() *AutoPartitioningWriteSpeedStrategy {
	if x != nil {
		return x.PartitionWriteSpeed
	}
	return nil
}

func (x *AutoPartitioningSettings) SetStrategy(v AutoPartitioningStrategy) {
	x.Strategy = &v
}

func (x *AutoPartitioningSettings) SetPartitionWriteSpeed(v *AutoPartitioningWriteSpeedStrategy) {
	x.PartitionWriteSpeed = v
}

func (x *AutoPartitioningSettings) HasStrategy() bool {
	if x == nil {
		return false
	}
	return x.Strategy != nil
}

func (x *AutoPartitioningSettings) HasPartitionWriteSpeed() bool {
	if x == nil {
		return false
	}
	return x.PartitionWriteSpeed != nil
}

func (x *AutoPartitioningSettings) ClearStrategy() {
	x.Strategy = nil
}

func (x *AutoPartitioningSettings) ClearPartitionWriteSpeed() {
	x.PartitionWriteSpeed = nil
}

type AutoPartitioningSettings_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Strategy of auto partitioning.
	Strategy *AutoPartitioningStrategy
	// Partition write speed auto partitioning options.
	PartitionWriteSpeed *AutoPartitioningWriteSpeedStrategy
}

func (b0 AutoPartitioningSettings_builder) Build() *AutoPartitioningSettings {
	m0 := &AutoPartitioningSettings{}
	b, x := &b0, m0
	_, _ = b, x
	x.Strategy = b.Strategy
	x.PartitionWriteSpeed = b.PartitionWriteSpeed
	return m0
}

type AutoPartitioningWriteSpeedStrategy struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Zero value means default - 300.
	StabilizationWindow *durationpb.Duration `protobuf:"bytes,1,opt,name=stabilization_window,json=stabilizationWindow" json:"stabilization_window,omitempty"`
	// Zero value means default - 90.
	UpUtilizationPercent *int32 `protobuf:"varint,2,opt,name=up_utilization_percent,json=upUtilizationPercent" json:"up_utilization_percent,omitempty"`
	// Zero value means default - 30.
	DownUtilizationPercent *int32 `protobuf:"varint,3,opt,name=down_utilization_percent,json=downUtilizationPercent" json:"down_utilization_percent,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *AutoPartitioningWriteSpeedStrategy) Reset() {
	*x = AutoPartitioningWriteSpeedStrategy{}
	mi := &file_protos_ydb_topic_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AutoPartitioningWriteSpeedStrategy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AutoPartitioningWriteSpeedStrategy) ProtoMessage() {}

func (x *AutoPartitioningWriteSpeedStrategy) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *AutoPartitioningWriteSpeedStrategy) GetStabilizationWindow() *durationpb.Duration {
	if x != nil {
		return x.StabilizationWindow
	}
	return nil
}

func (x *AutoPartitioningWriteSpeedStrategy) GetUpUtilizationPercent() int32 {
	if x != nil && x.UpUtilizationPercent != nil {
		return *x.UpUtilizationPercent
	}
	return 0
}

func (x *AutoPartitioningWriteSpeedStrategy) GetDownUtilizationPercent() int32 {
	if x != nil && x.DownUtilizationPercent != nil {
		return *x.DownUtilizationPercent
	}
	return 0
}

func (x *AutoPartitioningWriteSpeedStrategy) SetStabilizationWindow(v *durationpb.Duration) {
	x.StabilizationWindow = v
}

func (x *AutoPartitioningWriteSpeedStrategy) SetUpUtilizationPercent(v int32) {
	x.UpUtilizationPercent = &v
}

func (x *AutoPartitioningWriteSpeedStrategy) SetDownUtilizationPercent(v int32) {
	x.DownUtilizationPercent = &v
}

func (x *AutoPartitioningWriteSpeedStrategy) HasStabilizationWindow() bool {
	if x == nil {
		return false
	}
	return x.StabilizationWindow != nil
}

func (x *AutoPartitioningWriteSpeedStrategy) HasUpUtilizationPercent() bool {
	if x == nil {
		return false
	}
	return x.UpUtilizationPercent != nil
}

func (x *AutoPartitioningWriteSpeedStrategy) HasDownUtilizationPercent() bool {
	if x == nil {
		return false
	}
	return x.DownUtilizationPercent != nil
}

func (x *AutoPartitioningWriteSpeedStrategy) ClearStabilizationWindow() {
	x.StabilizationWindow = nil
}

func (x *AutoPartitioningWriteSpeedStrategy) ClearUpUtilizationPercent() {
	x.UpUtilizationPercent = nil
}

func (x *AutoPartitioningWriteSpeedStrategy) ClearDownUtilizationPercent() {
	x.DownUtilizationPercent = nil
}

type AutoPartitioningWriteSpeedStrategy_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Zero value means default - 300.
	StabilizationWindow *durationpb.Duration
	// Zero value means default - 90.
	UpUtilizationPercent *int32
	// Zero value means default - 30.
	DownUtilizationPercent *int32
}

func (b0 AutoPartitioningWriteSpeedStrategy_builder) Build() *AutoPartitioningWriteSpeedStrategy {
	m0 := &AutoPartitioningWriteSpeedStrategy{}
	b, x := &b0, m0
	_, _ = b, x
	x.StabilizationWindow = b.StabilizationWindow
	x.UpUtilizationPercent = b.UpUtilizationPercent
	x.DownUtilizationPercent = b.DownUtilizationPercent
	return m0
}

// Partitioning settings for topic.
type AlterPartitioningSettings struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Minimum partition count auto merge would stop working at.
	// Zero value means default - 1.
	SetMinActivePartitions *int64 `protobuf:"varint,1,opt,name=set_min_active_partitions,json=setMinActivePartitions" json:"set_min_active_partitions,omitempty"`
	// Maximum partition count auto merge would stop working at.
	// Zero value means default - 1.
	SetMaxActivePartitions *int64 `protobuf:"varint,3,opt,name=set_max_active_partitions,json=setMaxActivePartitions" json:"set_max_active_partitions,omitempty"`
	// Limit for total partition count, including active (open for write) and read-only partitions.
	// Zero value means default - 100.
	// Use set_max_active_partitions
	//
	// Deprecated: Marked as deprecated in protos/ydb_topic.proto.
	SetPartitionCountLimit *int64 `protobuf:"varint,2,opt,name=set_partition_count_limit,json=setPartitionCountLimit" json:"set_partition_count_limit,omitempty"`
	// Settings for auto partitioning the partition number
	AlterAutoPartitioningSettings *AlterAutoPartitioningSettings `protobuf:"bytes,4,opt,name=alter_auto_partitioning_settings,json=alterAutoPartitioningSettings" json:"alter_auto_partitioning_settings,omitempty"`
	unknownFields                 protoimpl.UnknownFields
	sizeCache                     protoimpl.SizeCache
}

func (x *AlterPartitioningSettings) Reset() {
	*x = AlterPartitioningSettings{}
	mi := &file_protos_ydb_topic_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AlterPartitioningSettings) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AlterPartitioningSettings) ProtoMessage() {}

func (x *AlterPartitioningSettings) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *AlterPartitioningSettings) GetSetMinActivePartitions() int64 {
	if x != nil && x.SetMinActivePartitions != nil {
		return *x.SetMinActivePartitions
	}
	return 0
}

func (x *AlterPartitioningSettings) GetSetMaxActivePartitions() int64 {
	if x != nil && x.SetMaxActivePartitions != nil {
		return *x.SetMaxActivePartitions
	}
	return 0
}

// Deprecated: Marked as deprecated in protos/ydb_topic.proto.
func (x *AlterPartitioningSettings) GetSetPartitionCountLimit() int64 {
	if x != nil && x.SetPartitionCountLimit != nil {
		return *x.SetPartitionCountLimit
	}
	return 0
}

func (x *AlterPartitioningSettings) GetAlterAutoPartitioningSettings() *AlterAutoPartitioningSettings {
	if x != nil {
		return x.AlterAutoPartitioningSettings
	}
	return nil
}

func (x *AlterPartitioningSettings) SetSetMinActivePartitions(v int64) {
	x.SetMinActivePartitions = &v
}

func (x *AlterPartitioningSettings) SetSetMaxActivePartitions(v int64) {
	x.SetMaxActivePartitions = &v
}

// Deprecated: Marked as deprecated in protos/ydb_topic.proto.
func (x *AlterPartitioningSettings) SetSetPartitionCountLimit(v int64) {
	x.SetPartitionCountLimit = &v
}

func (x *AlterPartitioningSettings) SetAlterAutoPartitioningSettings(v *AlterAutoPartitioningSettings) {
	x.AlterAutoPartitioningSettings = v
}

func (x *AlterPartitioningSettings) HasSetMinActivePartitions() bool {
	if x == nil {
		return false
	}
	return x.SetMinActivePartitions != nil
}

func (x *AlterPartitioningSettings) HasSetMaxActivePartitions() bool {
	if x == nil {
		return false
	}
	return x.SetMaxActivePartitions != nil
}

// Deprecated: Marked as deprecated in protos/ydb_topic.proto.
func (x *AlterPartitioningSettings) HasSetPartitionCountLimit() bool {
	if x == nil {
		return false
	}
	return x.SetPartitionCountLimit != nil
}

func (x *AlterPartitioningSettings) HasAlterAutoPartitioningSettings() bool {
	if x == nil {
		return false
	}
	return x.AlterAutoPartitioningSettings != nil
}

func (x *AlterPartitioningSettings) ClearSetMinActivePartitions() {
	x.SetMinActivePartitions = nil
}

func (x *AlterPartitioningSettings) ClearSetMaxActivePartitions() {
	x.SetMaxActivePartitions = nil
}

// Deprecated: Marked as deprecated in protos/ydb_topic.proto.
func (x *AlterPartitioningSettings) ClearSetPartitionCountLimit() {
	x.SetPartitionCountLimit = nil
}

func (x *AlterPartitioningSettings) ClearAlterAutoPartitioningSettings() {
	x.AlterAutoPartitioningSettings = nil
}

type AlterPartitioningSettings_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Minimum partition count auto merge would stop working at.
	// Zero value means default - 1.
	SetMinActivePartitions *int64
	// Maximum partition count auto merge would stop working at.
	// Zero value means default - 1.
	SetMaxActivePartitions *int64
	// Limit for total partition count, including active (open for write) and read-only partitions.
	// Zero value means default - 100.
	// Use set_max_active_partitions
	//
	// Deprecated: Marked as deprecated in protos/ydb_topic.proto.
	SetPartitionCountLimit *int64
	// Settings for auto partitioning the partition number
	AlterAutoPartitioningSettings *AlterAutoPartitioningSettings
}

func (b0 AlterPartitioningSettings_builder) Build() *AlterPartitioningSettings {
	m0 := &AlterPartitioningSettings{}
	b, x := &b0, m0
	_, _ = b, x
	x.SetMinActivePartitions = b.SetMinActivePartitions
	x.SetMaxActivePartitions = b.SetMaxActivePartitions
	x.SetPartitionCountLimit = b.SetPartitionCountLimit
	x.AlterAutoPartitioningSettings = b.AlterAutoPartitioningSettings
	return m0
}

type AlterAutoPartitioningSettings struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Strategy of auto partitioning
	SetStrategy *AutoPartitioningStrategy `protobuf:"varint,1,opt,name=set_strategy,json=setStrategy,enum=Ydb.Topic.AutoPartitioningStrategy" json:"set_strategy,omitempty"`
	// Auto partitioning write speed options.
	SetPartitionWriteSpeed *AlterAutoPartitioningWriteSpeedStrategy `protobuf:"bytes,2,opt,name=set_partition_write_speed,json=setPartitionWriteSpeed" json:"set_partition_write_speed,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *AlterAutoPartitioningSettings) Reset() {
	*x = AlterAutoPartitioningSettings{}
	mi := &file_protos_ydb_topic_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AlterAutoPartitioningSettings) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AlterAutoPartitioningSettings) ProtoMessage() {}

func (x *AlterAutoPartitioningSettings) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *AlterAutoPartitioningSettings) GetSetStrategy() AutoPartitioningStrategy {
	if x != nil && x.SetStrategy != nil {
		return *x.SetStrategy
	}
	return AutoPartitioningStrategy_AUTO_PARTITIONING_STRATEGY_UNSPECIFIED
}

func (x *AlterAutoPartitioningSettings) GetSetPartitionWriteSpeed() *AlterAutoPartitioningWriteSpeedStrategy {
	if x != nil {
		return x.SetPartitionWriteSpeed
	}
	return nil
}

func (x *AlterAutoPartitioningSettings) SetSetStrategy(v AutoPartitioningStrategy) {
	x.SetStrategy = &v
}

func (x *AlterAutoPartitioningSettings) SetSetPartitionWriteSpeed(v *AlterAutoPartitioningWriteSpeedStrategy) {
	x.SetPartitionWriteSpeed = v
}

func (x *AlterAutoPartitioningSettings) HasSetStrategy() bool {
	if x == nil {
		return false
	}
	return x.SetStrategy != nil
}

func (x *AlterAutoPartitioningSettings) HasSetPartitionWriteSpeed() bool {
	if x == nil {
		return false
	}
	return x.SetPartitionWriteSpeed != nil
}

func (x *AlterAutoPartitioningSettings) ClearSetStrategy() {
	x.SetStrategy = nil
}

func (x *AlterAutoPartitioningSettings) ClearSetPartitionWriteSpeed() {
	x.SetPartitionWriteSpeed = nil
}

type AlterAutoPartitioningSettings_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Strategy of auto partitioning
	SetStrategy *AutoPartitioningStrategy
	// Auto partitioning write speed options.
	SetPartitionWriteSpeed *AlterAutoPartitioningWriteSpeedStrategy
}

func (b0 AlterAutoPartitioningSettings_builder) Build() *AlterAutoPartitioningSettings {
	m0 := &AlterAutoPartitioningSettings{}
	b, x := &b0, m0
	_, _ = b, x
	x.SetStrategy = b.SetStrategy
	x.SetPartitionWriteSpeed = b.SetPartitionWriteSpeed
	return m0
}

type AlterAutoPartitioningWriteSpeedStrategy struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// The time of exceeding the threshold value, after which the partition will be
	// auto partitioning.
	// Zero value means default - 300.
	SetStabilizationWindow *durationpb.Duration `protobuf:"bytes,1,opt,name=set_stabilization_window,json=setStabilizationWindow" json:"set_stabilization_window,omitempty"`
	// The threshold value of the write speed to the partition as a percentage, when exceeded,
	// the partition will be auto split.
	// Zero value means default - 90.
	SetUpUtilizationPercent *int32 `protobuf:"varint,2,opt,name=set_up_utilization_percent,json=setUpUtilizationPercent" json:"set_up_utilization_percent,omitempty"`
	// The threshold value of the write speed to the partition as a percentage, if it is not reached,
	// the partition will be auto merged.
	// Zero value means default - 30.
	SetDownUtilizationPercent *int32 `protobuf:"varint,3,opt,name=set_down_utilization_percent,json=setDownUtilizationPercent" json:"set_down_utilization_percent,omitempty"`
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *AlterAutoPartitioningWriteSpeedStrategy) Reset() {
	*x = AlterAutoPartitioningWriteSpeedStrategy{}
	mi := &file_protos_ydb_topic_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AlterAutoPartitioningWriteSpeedStrategy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AlterAutoPartitioningWriteSpeedStrategy) ProtoMessage() {}

func (x *AlterAutoPartitioningWriteSpeedStrategy) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *AlterAutoPartitioningWriteSpeedStrategy) GetSetStabilizationWindow() *durationpb.Duration {
	if x != nil {
		return x.SetStabilizationWindow
	}
	return nil
}

func (x *AlterAutoPartitioningWriteSpeedStrategy) GetSetUpUtilizationPercent() int32 {
	if x != nil && x.SetUpUtilizationPercent != nil {
		return *x.SetUpUtilizationPercent
	}
	return 0
}

func (x *AlterAutoPartitioningWriteSpeedStrategy) GetSetDownUtilizationPercent() int32 {
	if x != nil && x.SetDownUtilizationPercent != nil {
		return *x.SetDownUtilizationPercent
	}
	return 0
}

func (x *AlterAutoPartitioningWriteSpeedStrategy) SetSetStabilizationWindow(v *durationpb.Duration) {
	x.SetStabilizationWindow = v
}

func (x *AlterAutoPartitioningWriteSpeedStrategy) SetSetUpUtilizationPercent(v int32) {
	x.SetUpUtilizationPercent = &v
}

func (x *AlterAutoPartitioningWriteSpeedStrategy) SetSetDownUtilizationPercent(v int32) {
	x.SetDownUtilizationPercent = &v
}

func (x *AlterAutoPartitioningWriteSpeedStrategy) HasSetStabilizationWindow() bool {
	if x == nil {
		return false
	}
	return x.SetStabilizationWindow != nil
}

func (x *AlterAutoPartitioningWriteSpeedStrategy) HasSetUpUtilizationPercent() bool {
	if x == nil {
		return false
	}
	return x.SetUpUtilizationPercent != nil
}

func (x *AlterAutoPartitioningWriteSpeedStrategy) HasSetDownUtilizationPercent() bool {
	if x == nil {
		return false
	}
	return x.SetDownUtilizationPercent != nil
}

func (x *AlterAutoPartitioningWriteSpeedStrategy) ClearSetStabilizationWindow() {
	x.SetStabilizationWindow = nil
}

func (x *AlterAutoPartitioningWriteSpeedStrategy) ClearSetUpUtilizationPercent() {
	x.SetUpUtilizationPercent = nil
}

func (x *AlterAutoPartitioningWriteSpeedStrategy) ClearSetDownUtilizationPercent() {
	x.SetDownUtilizationPercent = nil
}

type AlterAutoPartitioningWriteSpeedStrategy_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// The time of exceeding the threshold value, after which the partition will be
	// auto partitioning.
	// Zero value means default - 300.
	SetStabilizationWindow *durationpb.Duration
	// The threshold value of the write speed to the partition as a percentage, when exceeded,
	// the partition will be auto split.
	// Zero value means default - 90.
	SetUpUtilizationPercent *int32
	// The threshold value of the write speed to the partition as a percentage, if it is not reached,
	// the partition will be auto merged.
	// Zero value means default - 30.
	SetDownUtilizationPercent *int32
}

func (b0 AlterAutoPartitioningWriteSpeedStrategy_builder) Build() *AlterAutoPartitioningWriteSpeedStrategy {
	m0 := &AlterAutoPartitioningWriteSpeedStrategy{}
	b, x := &b0, m0
	_, _ = b, x
	x.SetStabilizationWindow = b.SetStabilizationWindow
	x.SetUpUtilizationPercent = b.SetUpUtilizationPercent
	x.SetDownUtilizationPercent = b.SetDownUtilizationPercent
	return m0
}

// Create topic request sent from client to server.
type CreateTopicRequest struct {
	state           protoimpl.MessageState          `protogen:"hybrid.v1"`
	OperationParams *Ydb_Operations.OperationParams `protobuf:"bytes,1,opt,name=operation_params,json=operationParams" json:"operation_params,omitempty"`
	// Topic path.
	Path *string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	// Settings for partitioning
	PartitioningSettings *PartitioningSettings `protobuf:"bytes,3,opt,name=partitioning_settings,json=partitioningSettings" json:"partitioning_settings,omitempty"`
	// Retention settings.
	// Currently, only one limit may be set, so other should not be set.
	//
	// How long data in partition should be stored. Must be greater than 0 and less than limit for this database.
	// Default limit - 36 hours.
	RetentionPeriod *durationpb.Duration `protobuf:"bytes,4,opt,name=retention_period,json=retentionPeriod" json:"retention_period,omitempty"`
	// How much data in partition should be stored. Must be greater than 0 and less than limit for this database.
	// Zero value means infinite limit.
	RetentionStorageMb *int64 `protobuf:"varint,5,opt,name=retention_storage_mb,json=retentionStorageMb" json:"retention_storage_mb,omitempty"`
	// List of allowed codecs for writers.
	// Writes with codec not from this list are forbidden.
	// If empty, codec compatibility check for the topic is disabled.
	SupportedCodecs *SupportedCodecs `protobuf:"bytes,7,opt,name=supported_codecs,json=supportedCodecs" json:"supported_codecs,omitempty"`
	// Partition write speed in bytes per second. Must be less than database limit.
	// Zero value means default limit: 1 MB per second.
	PartitionWriteSpeedBytesPerSecond *int64 `protobuf:"varint,8,opt,name=partition_write_speed_bytes_per_second,json=partitionWriteSpeedBytesPerSecond" json:"partition_write_speed_bytes_per_second,omitempty"`
	// Burst size for write in partition, in bytes. Must be less than database limit.
	// Zero value means default limit: 1 MB.
	PartitionWriteBurstBytes *int64 `protobuf:"varint,9,opt,name=partition_write_burst_bytes,json=partitionWriteBurstBytes" json:"partition_write_burst_bytes,omitempty"`
	// User and server attributes of topic. Server attributes starts from "_" and will be validated by server.
	Attributes map[string]string `protobuf:"bytes,10,rep,name=attributes" json:"attributes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// List of consumers for this topic.
	Consumers []*Consumer `protobuf:"bytes,11,rep,name=consumers" json:"consumers,omitempty"`
	// Metering mode for the topic in a serverless database.
	MeteringMode  *MeteringMode `protobuf:"varint,12,opt,name=metering_mode,json=meteringMode,enum=Ydb.Topic.MeteringMode" json:"metering_mode,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateTopicRequest) Reset() {
	*x = CreateTopicRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateTopicRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateTopicRequest) ProtoMessage() {}

func (x *CreateTopicRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *CreateTopicRequest) GetOperationParams() *Ydb_Operations.OperationParams {
	if x != nil {
		return x.OperationParams
	}
	return nil
}

func (x *CreateTopicRequest) GetPath() string {
	if x != nil && x.Path != nil {
		return *x.Path
	}
	return ""
}

func (x *CreateTopicRequest) GetPartitioningSettings() *PartitioningSettings {
	if x != nil {
		return x.PartitioningSettings
	}
	return nil
}

func (x *CreateTopicRequest) GetRetentionPeriod() *durationpb.Duration {
	if x != nil {
		return x.RetentionPeriod
	}
	return nil
}

func (x *CreateTopicRequest) GetRetentionStorageMb() int64 {
	if x != nil && x.RetentionStorageMb != nil {
		return *x.RetentionStorageMb
	}
	return 0
}

func (x *CreateTopicRequest) GetSupportedCodecs() *SupportedCodecs {
	if x != nil {
		return x.SupportedCodecs
	}
	return nil
}

func (x *CreateTopicRequest) GetPartitionWriteSpeedBytesPerSecond() int64 {
	if x != nil && x.PartitionWriteSpeedBytesPerSecond != nil {
		return *x.PartitionWriteSpeedBytesPerSecond
	}
	return 0
}

func (x *CreateTopicRequest) GetPartitionWriteBurstBytes() int64 {
	if x != nil && x.PartitionWriteBurstBytes != nil {
		return *x.PartitionWriteBurstBytes
	}
	return 0
}

func (x *CreateTopicRequest) GetAttributes() map[string]string {
	if x != nil {
		return x.Attributes
	}
	return nil
}

func (x *CreateTopicRequest) GetConsumers() []*Consumer {
	if x != nil {
		return x.Consumers
	}
	return nil
}

func (x *CreateTopicRequest) GetMeteringMode() MeteringMode {
	if x != nil && x.MeteringMode != nil {
		return *x.MeteringMode
	}
	return MeteringMode_METERING_MODE_UNSPECIFIED
}

func (x *CreateTopicRequest) SetOperationParams(v *Ydb_Operations.OperationParams) {
	x.OperationParams = v
}

func (x *CreateTopicRequest) SetPath(v string) {
	x.Path = &v
}

func (x *CreateTopicRequest) SetPartitioningSettings(v *PartitioningSettings) {
	x.PartitioningSettings = v
}

func (x *CreateTopicRequest) SetRetentionPeriod(v *durationpb.Duration) {
	x.RetentionPeriod = v
}

func (x *CreateTopicRequest) SetRetentionStorageMb(v int64) {
	x.RetentionStorageMb = &v
}

func (x *CreateTopicRequest) SetSupportedCodecs(v *SupportedCodecs) {
	x.SupportedCodecs = v
}

func (x *CreateTopicRequest) SetPartitionWriteSpeedBytesPerSecond(v int64) {
	x.PartitionWriteSpeedBytesPerSecond = &v
}

func (x *CreateTopicRequest) SetPartitionWriteBurstBytes(v int64) {
	x.PartitionWriteBurstBytes = &v
}

func (x *CreateTopicRequest) SetAttributes(v map[string]string) {
	x.Attributes = v
}

func (x *CreateTopicRequest) SetConsumers(v []*Consumer) {
	x.Consumers = v
}

func (x *CreateTopicRequest) SetMeteringMode(v MeteringMode) {
	x.MeteringMode = &v
}

func (x *CreateTopicRequest) HasOperationParams() bool {
	if x == nil {
		return false
	}
	return x.OperationParams != nil
}

func (x *CreateTopicRequest) HasPath() bool {
	if x == nil {
		return false
	}
	return x.Path != nil
}

func (x *CreateTopicRequest) HasPartitioningSettings() bool {
	if x == nil {
		return false
	}
	return x.PartitioningSettings != nil
}

func (x *CreateTopicRequest) HasRetentionPeriod() bool {
	if x == nil {
		return false
	}
	return x.RetentionPeriod != nil
}

func (x *CreateTopicRequest) HasRetentionStorageMb() bool {
	if x == nil {
		return false
	}
	return x.RetentionStorageMb != nil
}

func (x *CreateTopicRequest) HasSupportedCodecs() bool {
	if x == nil {
		return false
	}
	return x.SupportedCodecs != nil
}

func (x *CreateTopicRequest) HasPartitionWriteSpeedBytesPerSecond() bool {
	if x == nil {
		return false
	}
	return x.PartitionWriteSpeedBytesPerSecond != nil
}

func (x *CreateTopicRequest) HasPartitionWriteBurstBytes() bool {
	if x == nil {
		return false
	}
	return x.PartitionWriteBurstBytes != nil
}

func (x *CreateTopicRequest) HasMeteringMode() bool {
	if x == nil {
		return false
	}
	return x.MeteringMode != nil
}

func (x *CreateTopicRequest) ClearOperationParams() {
	x.OperationParams = nil
}

func (x *CreateTopicRequest) ClearPath() {
	x.Path = nil
}

func (x *CreateTopicRequest) ClearPartitioningSettings() {
	x.PartitioningSettings = nil
}

func (x *CreateTopicRequest) ClearRetentionPeriod() {
	x.RetentionPeriod = nil
}

func (x *CreateTopicRequest) ClearRetentionStorageMb() {
	x.RetentionStorageMb = nil
}

func (x *CreateTopicRequest) ClearSupportedCodecs() {
	x.SupportedCodecs = nil
}

func (x *CreateTopicRequest) ClearPartitionWriteSpeedBytesPerSecond() {
	x.PartitionWriteSpeedBytesPerSecond = nil
}

func (x *CreateTopicRequest) ClearPartitionWriteBurstBytes() {
	x.PartitionWriteBurstBytes = nil
}

func (x *CreateTopicRequest) ClearMeteringMode() {
	x.MeteringMode = nil
}

type CreateTopicRequest_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	OperationParams *Ydb_Operations.OperationParams
	// Topic path.
	Path *string
	// Settings for partitioning
	PartitioningSettings *PartitioningSettings
	// Retention settings.
	// Currently, only one limit may be set, so other should not be set.
	//
	// How long data in partition should be stored. Must be greater than 0 and less than limit for this database.
	// Default limit - 36 hours.
	RetentionPeriod *durationpb.Duration
	// How much data in partition should be stored. Must be greater than 0 and less than limit for this database.
	// Zero value means infinite limit.
	RetentionStorageMb *int64
	// List of allowed codecs for writers.
	// Writes with codec not from this list are forbidden.
	// If empty, codec compatibility check for the topic is disabled.
	SupportedCodecs *SupportedCodecs
	// Partition write speed in bytes per second. Must be less than database limit.
	// Zero value means default limit: 1 MB per second.
	PartitionWriteSpeedBytesPerSecond *int64
	// Burst size for write in partition, in bytes. Must be less than database limit.
	// Zero value means default limit: 1 MB.
	PartitionWriteBurstBytes *int64
	// User and server attributes of topic. Server attributes starts from "_" and will be validated by server.
	Attributes map[string]string
	// List of consumers for this topic.
	Consumers []*Consumer
	// Metering mode for the topic in a serverless database.
	MeteringMode *MeteringMode
}

func (b0 CreateTopicRequest_builder) Build() *CreateTopicRequest {
	m0 := &CreateTopicRequest{}
	b, x := &b0, m0
	_, _ = b, x
	x.OperationParams = b.OperationParams
	x.Path = b.Path
	x.PartitioningSettings = b.PartitioningSettings
	x.RetentionPeriod = b.RetentionPeriod
	x.RetentionStorageMb = b.RetentionStorageMb
	x.SupportedCodecs = b.SupportedCodecs
	x.PartitionWriteSpeedBytesPerSecond = b.PartitionWriteSpeedBytesPerSecond
	x.PartitionWriteBurstBytes = b.PartitionWriteBurstBytes
	x.Attributes = b.Attributes
	x.Consumers = b.Consumers
	x.MeteringMode = b.MeteringMode
	return m0
}

// Create topic response sent from server to client.
// If topic is already exists then response status will be "ALREADY_EXISTS".
type CreateTopicResponse struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Result of request will be inside operation.
	Operation     *Ydb_Operations.Operation `protobuf:"bytes,1,opt,name=operation" json:"operation,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateTopicResponse) Reset() {
	*x = CreateTopicResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateTopicResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateTopicResponse) ProtoMessage() {}

func (x *CreateTopicResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *CreateTopicResponse) GetOperation() *Ydb_Operations.Operation {
	if x != nil {
		return x.Operation
	}
	return nil
}

func (x *CreateTopicResponse) SetOperation(v *Ydb_Operations.Operation) {
	x.Operation = v
}

func (x *CreateTopicResponse) HasOperation() bool {
	if x == nil {
		return false
	}
	return x.Operation != nil
}

func (x *CreateTopicResponse) ClearOperation() {
	x.Operation = nil
}

type CreateTopicResponse_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Result of request will be inside operation.
	Operation *Ydb_Operations.Operation
}

func (b0 CreateTopicResponse_builder) Build() *CreateTopicResponse {
	m0 := &CreateTopicResponse{}
	b, x := &b0, m0
	_, _ = b, x
	x.Operation = b.Operation
	return m0
}

// Create topic result message that will be inside CreateTopicResponse.operation.
type CreateTopicResult struct {
	state         protoimpl.MessageState `protogen:"hybrid.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateTopicResult) Reset() {
	*x = CreateTopicResult{}
	mi := &file_protos_ydb_topic_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateTopicResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateTopicResult) ProtoMessage() {}

func (x *CreateTopicResult) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

type CreateTopicResult_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

}

func (b0 CreateTopicResult_builder) Build() *CreateTopicResult {
	m0 := &CreateTopicResult{}
	b, x := &b0, m0
	_, _ = b, x
	return m0
}

// Topic partition location
type PartitionLocation struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Node identificator.
	NodeId *int32 `protobuf:"varint,1,opt,name=node_id,json=nodeId" json:"node_id,omitempty"`
	// Partition generation.
	Generation    *int64 `protobuf:"varint,2,opt,name=generation" json:"generation,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PartitionLocation) Reset() {
	*x = PartitionLocation{}
	mi := &file_protos_ydb_topic_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PartitionLocation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PartitionLocation) ProtoMessage() {}

func (x *PartitionLocation) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *PartitionLocation) GetNodeId() int32 {
	if x != nil && x.NodeId != nil {
		return *x.NodeId
	}
	return 0
}

func (x *PartitionLocation) GetGeneration() int64 {
	if x != nil && x.Generation != nil {
		return *x.Generation
	}
	return 0
}

func (x *PartitionLocation) SetNodeId(v int32) {
	x.NodeId = &v
}

func (x *PartitionLocation) SetGeneration(v int64) {
	x.Generation = &v
}

func (x *PartitionLocation) HasNodeId() bool {
	if x == nil {
		return false
	}
	return x.NodeId != nil
}

func (x *PartitionLocation) HasGeneration() bool {
	if x == nil {
		return false
	}
	return x.Generation != nil
}

func (x *PartitionLocation) ClearNodeId() {
	x.NodeId = nil
}

func (x *PartitionLocation) ClearGeneration() {
	x.Generation = nil
}

type PartitionLocation_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Node identificator.
	NodeId *int32
	// Partition generation.
	Generation *int64
}

func (b0 PartitionLocation_builder) Build() *PartitionLocation {
	m0 := &PartitionLocation{}
	b, x := &b0, m0
	_, _ = b, x
	x.NodeId = b.NodeId
	x.Generation = b.Generation
	return m0
}

// Describe topic request sent from client to server.
type DescribeTopicRequest struct {
	state           protoimpl.MessageState          `protogen:"hybrid.v1"`
	OperationParams *Ydb_Operations.OperationParams `protobuf:"bytes,1,opt,name=operation_params,json=operationParams" json:"operation_params,omitempty"`
	// Topic path.
	Path *string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	// Include topic statistics.
	IncludeStats *bool `protobuf:"varint,3,opt,name=include_stats,json=includeStats" json:"include_stats,omitempty"`
	// Include partition location.
	IncludeLocation *bool `protobuf:"varint,4,opt,name=include_location,json=includeLocation" json:"include_location,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *DescribeTopicRequest) Reset() {
	*x = DescribeTopicRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DescribeTopicRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DescribeTopicRequest) ProtoMessage() {}

func (x *DescribeTopicRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *DescribeTopicRequest) GetOperationParams() *Ydb_Operations.OperationParams {
	if x != nil {
		return x.OperationParams
	}
	return nil
}

func (x *DescribeTopicRequest) GetPath() string {
	if x != nil && x.Path != nil {
		return *x.Path
	}
	return ""
}

func (x *DescribeTopicRequest) GetIncludeStats() bool {
	if x != nil && x.IncludeStats != nil {
		return *x.IncludeStats
	}
	return false
}

func (x *DescribeTopicRequest) GetIncludeLocation() bool {
	if x != nil && x.IncludeLocation != nil {
		return *x.IncludeLocation
	}
	return false
}

func (x *DescribeTopicRequest) SetOperationParams(v *Ydb_Operations.OperationParams) {
	x.OperationParams = v
}

func (x *DescribeTopicRequest) SetPath(v string) {
	x.Path = &v
}

func (x *DescribeTopicRequest) SetIncludeStats(v bool) {
	x.IncludeStats = &v
}

func (x *DescribeTopicRequest) SetIncludeLocation(v bool) {
	x.IncludeLocation = &v
}

func (x *DescribeTopicRequest) HasOperationParams() bool {
	if x == nil {
		return false
	}
	return x.OperationParams != nil
}

func (x *DescribeTopicRequest) HasPath() bool {
	if x == nil {
		return false
	}
	return x.Path != nil
}

func (x *DescribeTopicRequest) HasIncludeStats() bool {
	if x == nil {
		return false
	}
	return x.IncludeStats != nil
}

func (x *DescribeTopicRequest) HasIncludeLocation() bool {
	if x == nil {
		return false
	}
	return x.IncludeLocation != nil
}

func (x *DescribeTopicRequest) ClearOperationParams() {
	x.OperationParams = nil
}

func (x *DescribeTopicRequest) ClearPath() {
	x.Path = nil
}

func (x *DescribeTopicRequest) ClearIncludeStats() {
	x.IncludeStats = nil
}

func (x *DescribeTopicRequest) ClearIncludeLocation() {
	x.IncludeLocation = nil
}

type DescribeTopicRequest_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	OperationParams *Ydb_Operations.OperationParams
	// Topic path.
	Path *string
	// Include topic statistics.
	IncludeStats *bool
	// Include partition location.
	IncludeLocation *bool
}

func (b0 DescribeTopicRequest_builder) Build() *DescribeTopicRequest {
	m0 := &DescribeTopicRequest{}
	b, x := &b0, m0
	_, _ = b, x
	x.OperationParams = b.OperationParams
	x.Path = b.Path
	x.IncludeStats = b.IncludeStats
	x.IncludeLocation = b.IncludeLocation
	return m0
}

// Describe topic response sent from server to client.
// If topic is not existed then response status will be "SCHEME_ERROR".
type DescribeTopicResponse struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Result of request will be inside operation.
	Operation     *Ydb_Operations.Operation `protobuf:"bytes,1,opt,name=operation" json:"operation,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DescribeTopicResponse) Reset() {
	*x = DescribeTopicResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DescribeTopicResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DescribeTopicResponse) ProtoMessage() {}

func (x *DescribeTopicResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *DescribeTopicResponse) GetOperation() *Ydb_Operations.Operation {
	if x != nil {
		return x.Operation
	}
	return nil
}

func (x *DescribeTopicResponse) SetOperation(v *Ydb_Operations.Operation) {
	x.Operation = v
}

func (x *DescribeTopicResponse) HasOperation() bool {
	if x == nil {
		return false
	}
	return x.Operation != nil
}

func (x *DescribeTopicResponse) ClearOperation() {
	x.Operation = nil
}

type DescribeTopicResponse_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Result of request will be inside operation.
	Operation *Ydb_Operations.Operation
}

func (b0 DescribeTopicResponse_builder) Build() *DescribeTopicResponse {
	m0 := &DescribeTopicResponse{}
	b, x := &b0, m0
	_, _ = b, x
	x.Operation = b.Operation
	return m0
}

type PartitionKeyRange struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Inclusive left border. Emptiness means -inf.
	FromBound []byte `protobuf:"bytes,1,opt,name=from_bound,json=fromBound" json:"from_bound,omitempty"`
	// Exclusive right border. Emptiness means +inf.
	ToBound       []byte `protobuf:"bytes,2,opt,name=to_bound,json=toBound" json:"to_bound,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PartitionKeyRange) Reset() {
	*x = PartitionKeyRange{}
	mi := &file_protos_ydb_topic_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PartitionKeyRange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PartitionKeyRange) ProtoMessage() {}

func (x *PartitionKeyRange) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *PartitionKeyRange) GetFromBound() []byte {
	if x != nil {
		return x.FromBound
	}
	return nil
}

func (x *PartitionKeyRange) GetToBound() []byte {
	if x != nil {
		return x.ToBound
	}
	return nil
}

func (x *PartitionKeyRange) SetFromBound(v []byte) {
	if v == nil {
		v = []byte{}
	}
	x.FromBound = v
}

func (x *PartitionKeyRange) SetToBound(v []byte) {
	if v == nil {
		v = []byte{}
	}
	x.ToBound = v
}

func (x *PartitionKeyRange) HasFromBound() bool {
	if x == nil {
		return false
	}
	return x.FromBound != nil
}

func (x *PartitionKeyRange) HasToBound() bool {
	if x == nil {
		return false
	}
	return x.ToBound != nil
}

func (x *PartitionKeyRange) ClearFromBound() {
	x.FromBound = nil
}

func (x *PartitionKeyRange) ClearToBound() {
	x.ToBound = nil
}

type PartitionKeyRange_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Inclusive left border. Emptiness means -inf.
	FromBound []byte
	// Exclusive right border. Emptiness means +inf.
	ToBound []byte
}

func (b0 PartitionKeyRange_builder) Build() *PartitionKeyRange {
	m0 := &PartitionKeyRange{}
	b, x := &b0, m0
	_, _ = b, x
	x.FromBound = b.FromBound
	x.ToBound = b.ToBound
	return m0
}

// Describe topic result message that will be inside DescribeTopicResponse.operation.
type DescribeTopicResult struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Description of scheme object.
	Self *Ydb_Scheme.Entry `protobuf:"bytes,1,opt,name=self" json:"self,omitempty"`
	// Settings for partitioning
	PartitioningSettings *PartitioningSettings `protobuf:"bytes,2,opt,name=partitioning_settings,json=partitioningSettings" json:"partitioning_settings,omitempty"`
	// Partitions description.
	Partitions []*DescribeTopicResult_PartitionInfo `protobuf:"bytes,3,rep,name=partitions" json:"partitions,omitempty"`
	// Retention settings.
	// Currently, only one limit may be set, so other should not be set.
	//
	// How long data in partition should be stored.
	RetentionPeriod *durationpb.Duration `protobuf:"bytes,4,opt,name=retention_period,json=retentionPeriod" json:"retention_period,omitempty"`
	// How much data in partition should be stored.
	// Zero value means infinite limit.
	RetentionStorageMb *int64 `protobuf:"varint,5,opt,name=retention_storage_mb,json=retentionStorageMb" json:"retention_storage_mb,omitempty"`
	// List of allowed codecs for writers.
	// Writes with codec not from this list are forbidden.
	// If empty, codec compatibility check for the topic is disabled.
	SupportedCodecs *SupportedCodecs `protobuf:"bytes,7,opt,name=supported_codecs,json=supportedCodecs" json:"supported_codecs,omitempty"`
	// Partition write speed in bytes per second.
	// Zero value means default limit: 1 MB per second.
	PartitionWriteSpeedBytesPerSecond        *int64 `protobuf:"varint,8,opt,name=partition_write_speed_bytes_per_second,json=partitionWriteSpeedBytesPerSecond" json:"partition_write_speed_bytes_per_second,omitempty"`
	PartitionTotalReadSpeedBytesPerSecond    *int64 `protobuf:"varint,14,opt,name=partition_total_read_speed_bytes_per_second,json=partitionTotalReadSpeedBytesPerSecond" json:"partition_total_read_speed_bytes_per_second,omitempty"`
	PartitionConsumerReadSpeedBytesPerSecond *int64 `protobuf:"varint,15,opt,name=partition_consumer_read_speed_bytes_per_second,json=partitionConsumerReadSpeedBytesPerSecond" json:"partition_consumer_read_speed_bytes_per_second,omitempty"`
	// Burst size for write in partition, in bytes.
	// Zero value means default limit: 1 MB.
	PartitionWriteBurstBytes *int64 `protobuf:"varint,9,opt,name=partition_write_burst_bytes,json=partitionWriteBurstBytes" json:"partition_write_burst_bytes,omitempty"`
	// User and server attributes of topic. Server attributes starts from "_" and will be validated by server.
	Attributes map[string]string `protobuf:"bytes,10,rep,name=attributes" json:"attributes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// List of consumers for this topic.
	Consumers []*Consumer `protobuf:"bytes,11,rep,name=consumers" json:"consumers,omitempty"`
	// Metering settings.
	MeteringMode *MeteringMode `protobuf:"varint,12,opt,name=metering_mode,json=meteringMode,enum=Ydb.Topic.MeteringMode" json:"metering_mode,omitempty"`
	// Statistics of topic.
	TopicStats    *DescribeTopicResult_TopicStats `protobuf:"bytes,13,opt,name=topic_stats,json=topicStats" json:"topic_stats,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DescribeTopicResult) Reset() {
	*x = DescribeTopicResult{}
	mi := &file_protos_ydb_topic_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DescribeTopicResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DescribeTopicResult) ProtoMessage() {}

func (x *DescribeTopicResult) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *DescribeTopicResult) GetSelf() *Ydb_Scheme.Entry {
	if x != nil {
		return x.Self
	}
	return nil
}

func (x *DescribeTopicResult) GetPartitioningSettings() *PartitioningSettings {
	if x != nil {
		return x.PartitioningSettings
	}
	return nil
}

func (x *DescribeTopicResult) GetPartitions() []*DescribeTopicResult_PartitionInfo {
	if x != nil {
		return x.Partitions
	}
	return nil
}

func (x *DescribeTopicResult) GetRetentionPeriod() *durationpb.Duration {
	if x != nil {
		return x.RetentionPeriod
	}
	return nil
}

func (x *DescribeTopicResult) GetRetentionStorageMb() int64 {
	if x != nil && x.RetentionStorageMb != nil {
		return *x.RetentionStorageMb
	}
	return 0
}

func (x *DescribeTopicResult) GetSupportedCodecs() *SupportedCodecs {
	if x != nil {
		return x.SupportedCodecs
	}
	return nil
}

func (x *DescribeTopicResult) GetPartitionWriteSpeedBytesPerSecond() int64 {
	if x != nil && x.PartitionWriteSpeedBytesPerSecond != nil {
		return *x.PartitionWriteSpeedBytesPerSecond
	}
	return 0
}

func (x *DescribeTopicResult) GetPartitionTotalReadSpeedBytesPerSecond() int64 {
	if x != nil && x.PartitionTotalReadSpeedBytesPerSecond != nil {
		return *x.PartitionTotalReadSpeedBytesPerSecond
	}
	return 0
}

func (x *DescribeTopicResult) GetPartitionConsumerReadSpeedBytesPerSecond() int64 {
	if x != nil && x.PartitionConsumerReadSpeedBytesPerSecond != nil {
		return *x.PartitionConsumerReadSpeedBytesPerSecond
	}
	return 0
}

func (x *DescribeTopicResult) GetPartitionWriteBurstBytes() int64 {
	if x != nil && x.PartitionWriteBurstBytes != nil {
		return *x.PartitionWriteBurstBytes
	}
	return 0
}

func (x *DescribeTopicResult) GetAttributes() map[string]string {
	if x != nil {
		return x.Attributes
	}
	return nil
}

func (x *DescribeTopicResult) GetConsumers() []*Consumer {
	if x != nil {
		return x.Consumers
	}
	return nil
}

func (x *DescribeTopicResult) GetMeteringMode() MeteringMode {
	if x != nil && x.MeteringMode != nil {
		return *x.MeteringMode
	}
	return MeteringMode_METERING_MODE_UNSPECIFIED
}

func (x *DescribeTopicResult) GetTopicStats() *DescribeTopicResult_TopicStats {
	if x != nil {
		return x.TopicStats
	}
	return nil
}

func (x *DescribeTopicResult) SetSelf(v *Ydb_Scheme.Entry) {
	x.Self = v
}

func (x *DescribeTopicResult) SetPartitioningSettings(v *PartitioningSettings) {
	x.PartitioningSettings = v
}

func (x *DescribeTopicResult) SetPartitions(v []*DescribeTopicResult_PartitionInfo) {
	x.Partitions = v
}

func (x *DescribeTopicResult) SetRetentionPeriod(v *durationpb.Duration) {
	x.RetentionPeriod = v
}

func (x *DescribeTopicResult) SetRetentionStorageMb(v int64) {
	x.RetentionStorageMb = &v
}

func (x *DescribeTopicResult) SetSupportedCodecs(v *SupportedCodecs) {
	x.SupportedCodecs = v
}

func (x *DescribeTopicResult) SetPartitionWriteSpeedBytesPerSecond(v int64) {
	x.PartitionWriteSpeedBytesPerSecond = &v
}

func (x *DescribeTopicResult) SetPartitionTotalReadSpeedBytesPerSecond(v int64) {
	x.PartitionTotalReadSpeedBytesPerSecond = &v
}

func (x *DescribeTopicResult) SetPartitionConsumerReadSpeedBytesPerSecond(v int64) {
	x.PartitionConsumerReadSpeedBytesPerSecond = &v
}

func (x *DescribeTopicResult) SetPartitionWriteBurstBytes(v int64) {
	x.PartitionWriteBurstBytes = &v
}

func (x *DescribeTopicResult) SetAttributes(v map[string]string) {
	x.Attributes = v
}

func (x *DescribeTopicResult) SetConsumers(v []*Consumer) {
	x.Consumers = v
}

func (x *DescribeTopicResult) SetMeteringMode(v MeteringMode) {
	x.MeteringMode = &v
}

func (x *DescribeTopicResult) SetTopicStats(v *DescribeTopicResult_TopicStats) {
	x.TopicStats = v
}

func (x *DescribeTopicResult) HasSelf() bool {
	if x == nil {
		return false
	}
	return x.Self != nil
}

func (x *DescribeTopicResult) HasPartitioningSettings() bool {
	if x == nil {
		return false
	}
	return x.PartitioningSettings != nil
}

func (x *DescribeTopicResult) HasRetentionPeriod() bool {
	if x == nil {
		return false
	}
	return x.RetentionPeriod != nil
}

func (x *DescribeTopicResult) HasRetentionStorageMb() bool {
	if x == nil {
		return false
	}
	return x.RetentionStorageMb != nil
}

func (x *DescribeTopicResult) HasSupportedCodecs() bool {
	if x == nil {
		return false
	}
	return x.SupportedCodecs != nil
}

func (x *DescribeTopicResult) HasPartitionWriteSpeedBytesPerSecond() bool {
	if x == nil {
		return false
	}
	return x.PartitionWriteSpeedBytesPerSecond != nil
}

func (x *DescribeTopicResult) HasPartitionTotalReadSpeedBytesPerSecond() bool {
	if x == nil {
		return false
	}
	return x.PartitionTotalReadSpeedBytesPerSecond != nil
}

func (x *DescribeTopicResult) HasPartitionConsumerReadSpeedBytesPerSecond() bool {
	if x == nil {
		return false
	}
	return x.PartitionConsumerReadSpeedBytesPerSecond != nil
}

func (x *DescribeTopicResult) HasPartitionWriteBurstBytes() bool {
	if x == nil {
		return false
	}
	return x.PartitionWriteBurstBytes != nil
}

func (x *DescribeTopicResult) HasMeteringMode() bool {
	if x == nil {
		return false
	}
	return x.MeteringMode != nil
}

func (x *DescribeTopicResult) HasTopicStats() bool {
	if x == nil {
		return false
	}
	return x.TopicStats != nil
}

func (x *DescribeTopicResult) ClearSelf() {
	x.Self = nil
}

func (x *DescribeTopicResult) ClearPartitioningSettings() {
	x.PartitioningSettings = nil
}

func (x *DescribeTopicResult) ClearRetentionPeriod() {
	x.RetentionPeriod = nil
}

func (x *DescribeTopicResult) ClearRetentionStorageMb() {
	x.RetentionStorageMb = nil
}

func (x *DescribeTopicResult) ClearSupportedCodecs() {
	x.SupportedCodecs = nil
}

func (x *DescribeTopicResult) ClearPartitionWriteSpeedBytesPerSecond() {
	x.PartitionWriteSpeedBytesPerSecond = nil
}

func (x *DescribeTopicResult) ClearPartitionTotalReadSpeedBytesPerSecond() {
	x.PartitionTotalReadSpeedBytesPerSecond = nil
}

func (x *DescribeTopicResult) ClearPartitionConsumerReadSpeedBytesPerSecond() {
	x.PartitionConsumerReadSpeedBytesPerSecond = nil
}

func (x *DescribeTopicResult) ClearPartitionWriteBurstBytes() {
	x.PartitionWriteBurstBytes = nil
}

func (x *DescribeTopicResult) ClearMeteringMode() {
	x.MeteringMode = nil
}

func (x *DescribeTopicResult) ClearTopicStats() {
	x.TopicStats = nil
}

type DescribeTopicResult_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Description of scheme object.
	Self *Ydb_Scheme.Entry
	// Settings for partitioning
	PartitioningSettings *PartitioningSettings
	// Partitions description.
	Partitions []*DescribeTopicResult_PartitionInfo
	// Retention settings.
	// Currently, only one limit may be set, so other should not be set.
	//
	// How long data in partition should be stored.
	RetentionPeriod *durationpb.Duration
	// How much data in partition should be stored.
	// Zero value means infinite limit.
	RetentionStorageMb *int64
	// List of allowed codecs for writers.
	// Writes with codec not from this list are forbidden.
	// If empty, codec compatibility check for the topic is disabled.
	SupportedCodecs *SupportedCodecs
	// Partition write speed in bytes per second.
	// Zero value means default limit: 1 MB per second.
	PartitionWriteSpeedBytesPerSecond        *int64
	PartitionTotalReadSpeedBytesPerSecond    *int64
	PartitionConsumerReadSpeedBytesPerSecond *int64
	// Burst size for write in partition, in bytes.
	// Zero value means default limit: 1 MB.
	PartitionWriteBurstBytes *int64
	// User and server attributes of topic. Server attributes starts from "_" and will be validated by server.
	Attributes map[string]string
	// List of consumers for this topic.
	Consumers []*Consumer
	// Metering settings.
	MeteringMode *MeteringMode
	// Statistics of topic.
	TopicStats *DescribeTopicResult_TopicStats
}

func (b0 DescribeTopicResult_builder) Build() *DescribeTopicResult {
	m0 := &DescribeTopicResult{}
	b, x := &b0, m0
	_, _ = b, x
	x.Self = b.Self
	x.PartitioningSettings = b.PartitioningSettings
	x.Partitions = b.Partitions
	x.RetentionPeriod = b.RetentionPeriod
	x.RetentionStorageMb = b.RetentionStorageMb
	x.SupportedCodecs = b.SupportedCodecs
	x.PartitionWriteSpeedBytesPerSecond = b.PartitionWriteSpeedBytesPerSecond
	x.PartitionTotalReadSpeedBytesPerSecond = b.PartitionTotalReadSpeedBytesPerSecond
	x.PartitionConsumerReadSpeedBytesPerSecond = b.PartitionConsumerReadSpeedBytesPerSecond
	x.PartitionWriteBurstBytes = b.PartitionWriteBurstBytes
	x.Attributes = b.Attributes
	x.Consumers = b.Consumers
	x.MeteringMode = b.MeteringMode
	x.TopicStats = b.TopicStats
	return m0
}

// Describe partition request sent from client to server.
type DescribePartitionRequest struct {
	state           protoimpl.MessageState          `protogen:"hybrid.v1"`
	OperationParams *Ydb_Operations.OperationParams `protobuf:"bytes,1,opt,name=operation_params,json=operationParams" json:"operation_params,omitempty"`
	// Topic path.
	Path *string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	// Partition identifier.
	PartitionId *int64 `protobuf:"varint,3,opt,name=partition_id,json=partitionId" json:"partition_id,omitempty"`
	// Include partition statistics.
	IncludeStats *bool `protobuf:"varint,4,opt,name=include_stats,json=includeStats" json:"include_stats,omitempty"`
	// Include partition location.
	IncludeLocation *bool `protobuf:"varint,5,opt,name=include_location,json=includeLocation" json:"include_location,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *DescribePartitionRequest) Reset() {
	*x = DescribePartitionRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DescribePartitionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DescribePartitionRequest) ProtoMessage() {}

func (x *DescribePartitionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *DescribePartitionRequest) GetOperationParams() *Ydb_Operations.OperationParams {
	if x != nil {
		return x.OperationParams
	}
	return nil
}

func (x *DescribePartitionRequest) GetPath() string {
	if x != nil && x.Path != nil {
		return *x.Path
	}
	return ""
}

func (x *DescribePartitionRequest) GetPartitionId() int64 {
	if x != nil && x.PartitionId != nil {
		return *x.PartitionId
	}
	return 0
}

func (x *DescribePartitionRequest) GetIncludeStats() bool {
	if x != nil && x.IncludeStats != nil {
		return *x.IncludeStats
	}
	return false
}

func (x *DescribePartitionRequest) GetIncludeLocation() bool {
	if x != nil && x.IncludeLocation != nil {
		return *x.IncludeLocation
	}
	return false
}

func (x *DescribePartitionRequest) SetOperationParams(v *Ydb_Operations.OperationParams) {
	x.OperationParams = v
}

func (x *DescribePartitionRequest) SetPath(v string) {
	x.Path = &v
}

func (x *DescribePartitionRequest) SetPartitionId(v int64) {
	x.PartitionId = &v
}

func (x *DescribePartitionRequest) SetIncludeStats(v bool) {
	x.IncludeStats = &v
}

func (x *DescribePartitionRequest) SetIncludeLocation(v bool) {
	x.IncludeLocation = &v
}

func (x *DescribePartitionRequest) HasOperationParams() bool {
	if x == nil {
		return false
	}
	return x.OperationParams != nil
}

func (x *DescribePartitionRequest) HasPath() bool {
	if x == nil {
		return false
	}
	return x.Path != nil
}

func (x *DescribePartitionRequest) HasPartitionId() bool {
	if x == nil {
		return false
	}
	return x.PartitionId != nil
}

func (x *DescribePartitionRequest) HasIncludeStats() bool {
	if x == nil {
		return false
	}
	return x.IncludeStats != nil
}

func (x *DescribePartitionRequest) HasIncludeLocation() bool {
	if x == nil {
		return false
	}
	return x.IncludeLocation != nil
}

func (x *DescribePartitionRequest) ClearOperationParams() {
	x.OperationParams = nil
}

func (x *DescribePartitionRequest) ClearPath() {
	x.Path = nil
}

func (x *DescribePartitionRequest) ClearPartitionId() {
	x.PartitionId = nil
}

func (x *DescribePartitionRequest) ClearIncludeStats() {
	x.IncludeStats = nil
}

func (x *DescribePartitionRequest) ClearIncludeLocation() {
	x.IncludeLocation = nil
}

type DescribePartitionRequest_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	OperationParams *Ydb_Operations.OperationParams
	// Topic path.
	Path *string
	// Partition identifier.
	PartitionId *int64
	// Include partition statistics.
	IncludeStats *bool
	// Include partition location.
	IncludeLocation *bool
}

func (b0 DescribePartitionRequest_builder) Build() *DescribePartitionRequest {
	m0 := &DescribePartitionRequest{}
	b, x := &b0, m0
	_, _ = b, x
	x.OperationParams = b.OperationParams
	x.Path = b.Path
	x.PartitionId = b.PartitionId
	x.IncludeStats = b.IncludeStats
	x.IncludeLocation = b.IncludeLocation
	return m0
}

// Describe partition response sent from server to client.
// If topic is not existed then response status will be "SCHEME_ERROR".
type DescribePartitionResponse struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Result of request will be inside operation.
	Operation     *Ydb_Operations.Operation `protobuf:"bytes,1,opt,name=operation" json:"operation,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DescribePartitionResponse) Reset() {
	*x = DescribePartitionResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DescribePartitionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DescribePartitionResponse) ProtoMessage() {}

func (x *DescribePartitionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *DescribePartitionResponse) GetOperation() *Ydb_Operations.Operation {
	if x != nil {
		return x.Operation
	}
	return nil
}

func (x *DescribePartitionResponse) SetOperation(v *Ydb_Operations.Operation) {
	x.Operation = v
}

func (x *DescribePartitionResponse) HasOperation() bool {
	if x == nil {
		return false
	}
	return x.Operation != nil
}

func (x *DescribePartitionResponse) ClearOperation() {
	x.Operation = nil
}

type DescribePartitionResponse_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Result of request will be inside operation.
	Operation *Ydb_Operations.Operation
}

func (b0 DescribePartitionResponse_builder) Build() *DescribePartitionResponse {
	m0 := &DescribePartitionResponse{}
	b, x := &b0, m0
	_, _ = b, x
	x.Operation = b.Operation
	return m0
}

// Describe partition result message that will be inside DescribePartitionResponse.operation.
type DescribePartitionResult struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Partitions description.
	Partition     *DescribeTopicResult_PartitionInfo `protobuf:"bytes,1,opt,name=partition" json:"partition,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DescribePartitionResult) Reset() {
	*x = DescribePartitionResult{}
	mi := &file_protos_ydb_topic_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DescribePartitionResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DescribePartitionResult) ProtoMessage() {}

func (x *DescribePartitionResult) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *DescribePartitionResult) GetPartition() *DescribeTopicResult_PartitionInfo {
	if x != nil {
		return x.Partition
	}
	return nil
}

func (x *DescribePartitionResult) SetPartition(v *DescribeTopicResult_PartitionInfo) {
	x.Partition = v
}

func (x *DescribePartitionResult) HasPartition() bool {
	if x == nil {
		return false
	}
	return x.Partition != nil
}

func (x *DescribePartitionResult) ClearPartition() {
	x.Partition = nil
}

type DescribePartitionResult_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Partitions description.
	Partition *DescribeTopicResult_PartitionInfo
}

func (b0 DescribePartitionResult_builder) Build() *DescribePartitionResult {
	m0 := &DescribePartitionResult{}
	b, x := &b0, m0
	_, _ = b, x
	x.Partition = b.Partition
	return m0
}

// Describe topic's consumer request sent from client to server.
type DescribeConsumerRequest struct {
	state           protoimpl.MessageState          `protogen:"hybrid.v1"`
	OperationParams *Ydb_Operations.OperationParams `protobuf:"bytes,1,opt,name=operation_params,json=operationParams" json:"operation_params,omitempty"`
	// Topic path.
	Path *string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	// Consumer name;
	Consumer *string `protobuf:"bytes,3,opt,name=consumer" json:"consumer,omitempty"`
	// Include consumer statistics.
	IncludeStats *bool `protobuf:"varint,4,opt,name=include_stats,json=includeStats" json:"include_stats,omitempty"`
	// Include partition location.
	IncludeLocation *bool `protobuf:"varint,5,opt,name=include_location,json=includeLocation" json:"include_location,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *DescribeConsumerRequest) Reset() {
	*x = DescribeConsumerRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DescribeConsumerRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DescribeConsumerRequest) ProtoMessage() {}

func (x *DescribeConsumerRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *DescribeConsumerRequest) GetOperationParams() *Ydb_Operations.OperationParams {
	if x != nil {
		return x.OperationParams
	}
	return nil
}

func (x *DescribeConsumerRequest) GetPath() string {
	if x != nil && x.Path != nil {
		return *x.Path
	}
	return ""
}

func (x *DescribeConsumerRequest) GetConsumer() string {
	if x != nil && x.Consumer != nil {
		return *x.Consumer
	}
	return ""
}

func (x *DescribeConsumerRequest) GetIncludeStats() bool {
	if x != nil && x.IncludeStats != nil {
		return *x.IncludeStats
	}
	return false
}

func (x *DescribeConsumerRequest) GetIncludeLocation() bool {
	if x != nil && x.IncludeLocation != nil {
		return *x.IncludeLocation
	}
	return false
}

func (x *DescribeConsumerRequest) SetOperationParams(v *Ydb_Operations.OperationParams) {
	x.OperationParams = v
}

func (x *DescribeConsumerRequest) SetPath(v string) {
	x.Path = &v
}

func (x *DescribeConsumerRequest) SetConsumer(v string) {
	x.Consumer = &v
}

func (x *DescribeConsumerRequest) SetIncludeStats(v bool) {
	x.IncludeStats = &v
}

func (x *DescribeConsumerRequest) SetIncludeLocation(v bool) {
	x.IncludeLocation = &v
}

func (x *DescribeConsumerRequest) HasOperationParams() bool {
	if x == nil {
		return false
	}
	return x.OperationParams != nil
}

func (x *DescribeConsumerRequest) HasPath() bool {
	if x == nil {
		return false
	}
	return x.Path != nil
}

func (x *DescribeConsumerRequest) HasConsumer() bool {
	if x == nil {
		return false
	}
	return x.Consumer != nil
}

func (x *DescribeConsumerRequest) HasIncludeStats() bool {
	if x == nil {
		return false
	}
	return x.IncludeStats != nil
}

func (x *DescribeConsumerRequest) HasIncludeLocation() bool {
	if x == nil {
		return false
	}
	return x.IncludeLocation != nil
}

func (x *DescribeConsumerRequest) ClearOperationParams() {
	x.OperationParams = nil
}

func (x *DescribeConsumerRequest) ClearPath() {
	x.Path = nil
}

func (x *DescribeConsumerRequest) ClearConsumer() {
	x.Consumer = nil
}

func (x *DescribeConsumerRequest) ClearIncludeStats() {
	x.IncludeStats = nil
}

func (x *DescribeConsumerRequest) ClearIncludeLocation() {
	x.IncludeLocation = nil
}

type DescribeConsumerRequest_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	OperationParams *Ydb_Operations.OperationParams
	// Topic path.
	Path *string
	// Consumer name;
	Consumer *string
	// Include consumer statistics.
	IncludeStats *bool
	// Include partition location.
	IncludeLocation *bool
}

func (b0 DescribeConsumerRequest_builder) Build() *DescribeConsumerRequest {
	m0 := &DescribeConsumerRequest{}
	b, x := &b0, m0
	_, _ = b, x
	x.OperationParams = b.OperationParams
	x.Path = b.Path
	x.Consumer = b.Consumer
	x.IncludeStats = b.IncludeStats
	x.IncludeLocation = b.IncludeLocation
	return m0
}

// Describe topic's consumer response sent from server to client.
// If topic is not existed then response status will be "SCHEME_ERROR".
type DescribeConsumerResponse struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Result of request will be inside operation.
	Operation     *Ydb_Operations.Operation `protobuf:"bytes,1,opt,name=operation" json:"operation,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DescribeConsumerResponse) Reset() {
	*x = DescribeConsumerResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DescribeConsumerResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DescribeConsumerResponse) ProtoMessage() {}

func (x *DescribeConsumerResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *DescribeConsumerResponse) GetOperation() *Ydb_Operations.Operation {
	if x != nil {
		return x.Operation
	}
	return nil
}

func (x *DescribeConsumerResponse) SetOperation(v *Ydb_Operations.Operation) {
	x.Operation = v
}

func (x *DescribeConsumerResponse) HasOperation() bool {
	if x == nil {
		return false
	}
	return x.Operation != nil
}

func (x *DescribeConsumerResponse) ClearOperation() {
	x.Operation = nil
}

type DescribeConsumerResponse_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Result of request will be inside operation.
	Operation *Ydb_Operations.Operation
}

func (b0 DescribeConsumerResponse_builder) Build() *DescribeConsumerResponse {
	m0 := &DescribeConsumerResponse{}
	b, x := &b0, m0
	_, _ = b, x
	x.Operation = b.Operation
	return m0
}

// Describe topic's consumer result message that will be inside DescribeConsumerResponse.operation.
type DescribeConsumerResult struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Description of scheme object.
	Self          *Ydb_Scheme.Entry                       `protobuf:"bytes,1,opt,name=self" json:"self,omitempty"`
	Consumer      *Consumer                               `protobuf:"bytes,2,opt,name=consumer" json:"consumer,omitempty"`
	Partitions    []*DescribeConsumerResult_PartitionInfo `protobuf:"bytes,3,rep,name=partitions" json:"partitions,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DescribeConsumerResult) Reset() {
	*x = DescribeConsumerResult{}
	mi := &file_protos_ydb_topic_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DescribeConsumerResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DescribeConsumerResult) ProtoMessage() {}

func (x *DescribeConsumerResult) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *DescribeConsumerResult) GetSelf() *Ydb_Scheme.Entry {
	if x != nil {
		return x.Self
	}
	return nil
}

func (x *DescribeConsumerResult) GetConsumer() *Consumer {
	if x != nil {
		return x.Consumer
	}
	return nil
}

func (x *DescribeConsumerResult) GetPartitions() []*DescribeConsumerResult_PartitionInfo {
	if x != nil {
		return x.Partitions
	}
	return nil
}

func (x *DescribeConsumerResult) SetSelf(v *Ydb_Scheme.Entry) {
	x.Self = v
}

func (x *DescribeConsumerResult) SetConsumer(v *Consumer) {
	x.Consumer = v
}

func (x *DescribeConsumerResult) SetPartitions(v []*DescribeConsumerResult_PartitionInfo) {
	x.Partitions = v
}

func (x *DescribeConsumerResult) HasSelf() bool {
	if x == nil {
		return false
	}
	return x.Self != nil
}

func (x *DescribeConsumerResult) HasConsumer() bool {
	if x == nil {
		return false
	}
	return x.Consumer != nil
}

func (x *DescribeConsumerResult) ClearSelf() {
	x.Self = nil
}

func (x *DescribeConsumerResult) ClearConsumer() {
	x.Consumer = nil
}

type DescribeConsumerResult_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Description of scheme object.
	Self       *Ydb_Scheme.Entry
	Consumer   *Consumer
	Partitions []*DescribeConsumerResult_PartitionInfo
}

func (b0 DescribeConsumerResult_builder) Build() *DescribeConsumerResult {
	m0 := &DescribeConsumerResult{}
	b, x := &b0, m0
	_, _ = b, x
	x.Self = b.Self
	x.Consumer = b.Consumer
	x.Partitions = b.Partitions
	return m0
}

type PartitionStats struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Partition contains messages with offsets in range [start, end).
	PartitionOffsets *OffsetsRange `protobuf:"bytes,1,opt,name=partition_offsets,json=partitionOffsets" json:"partition_offsets,omitempty"`
	// Approximate size of partition.
	StoreSizeBytes *int64 `protobuf:"varint,2,opt,name=store_size_bytes,json=storeSizeBytes" json:"store_size_bytes,omitempty"`
	// Timestamp of last write.
	LastWriteTime *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=last_write_time,json=lastWriteTime" json:"last_write_time,omitempty"`
	// Maximum of differences between write timestamp and create timestamp for all messages, written during last minute.
	MaxWriteTimeLag *durationpb.Duration `protobuf:"bytes,4,opt,name=max_write_time_lag,json=maxWriteTimeLag" json:"max_write_time_lag,omitempty"`
	// How much bytes were written during several windows in this partition.
	BytesWritten *MultipleWindowsStat `protobuf:"bytes,5,opt,name=bytes_written,json=bytesWritten" json:"bytes_written,omitempty"`
	// Partition host. Useful for debugging purposes.
	//
	// Deprecated: Marked as deprecated in protos/ydb_topic.proto.
	PartitionNodeId *int32 `protobuf:"varint,8,opt,name=partition_node_id,json=partitionNodeId" json:"partition_node_id,omitempty"` //Use PartitionLocation
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *PartitionStats) Reset() {
	*x = PartitionStats{}
	mi := &file_protos_ydb_topic_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PartitionStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PartitionStats) ProtoMessage() {}

func (x *PartitionStats) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *PartitionStats) GetPartitionOffsets() *OffsetsRange {
	if x != nil {
		return x.PartitionOffsets
	}
	return nil
}

func (x *PartitionStats) GetStoreSizeBytes() int64 {
	if x != nil && x.StoreSizeBytes != nil {
		return *x.StoreSizeBytes
	}
	return 0
}

func (x *PartitionStats) GetLastWriteTime() *timestamppb.Timestamp {
	if x != nil {
		return x.LastWriteTime
	}
	return nil
}

func (x *PartitionStats) GetMaxWriteTimeLag() *durationpb.Duration {
	if x != nil {
		return x.MaxWriteTimeLag
	}
	return nil
}

func (x *PartitionStats) GetBytesWritten() *MultipleWindowsStat {
	if x != nil {
		return x.BytesWritten
	}
	return nil
}

// Deprecated: Marked as deprecated in protos/ydb_topic.proto.
func (x *PartitionStats) GetPartitionNodeId() int32 {
	if x != nil && x.PartitionNodeId != nil {
		return *x.PartitionNodeId
	}
	return 0
}

func (x *PartitionStats) SetPartitionOffsets(v *OffsetsRange) {
	x.PartitionOffsets = v
}

func (x *PartitionStats) SetStoreSizeBytes(v int64) {
	x.StoreSizeBytes = &v
}

func (x *PartitionStats) SetLastWriteTime(v *timestamppb.Timestamp) {
	x.LastWriteTime = v
}

func (x *PartitionStats) SetMaxWriteTimeLag(v *durationpb.Duration) {
	x.MaxWriteTimeLag = v
}

func (x *PartitionStats) SetBytesWritten(v *MultipleWindowsStat) {
	x.BytesWritten = v
}

// Deprecated: Marked as deprecated in protos/ydb_topic.proto.
func (x *PartitionStats) SetPartitionNodeId(v int32) {
	x.PartitionNodeId = &v
}

func (x *PartitionStats) HasPartitionOffsets() bool {
	if x == nil {
		return false
	}
	return x.PartitionOffsets != nil
}

func (x *PartitionStats) HasStoreSizeBytes() bool {
	if x == nil {
		return false
	}
	return x.StoreSizeBytes != nil
}

func (x *PartitionStats) HasLastWriteTime() bool {
	if x == nil {
		return false
	}
	return x.LastWriteTime != nil
}

func (x *PartitionStats) HasMaxWriteTimeLag() bool {
	if x == nil {
		return false
	}
	return x.MaxWriteTimeLag != nil
}

func (x *PartitionStats) HasBytesWritten() bool {
	if x == nil {
		return false
	}
	return x.BytesWritten != nil
}

// Deprecated: Marked as deprecated in protos/ydb_topic.proto.
func (x *PartitionStats) HasPartitionNodeId() bool {
	if x == nil {
		return false
	}
	return x.PartitionNodeId != nil
}

func (x *PartitionStats) ClearPartitionOffsets() {
	x.PartitionOffsets = nil
}

func (x *PartitionStats) ClearStoreSizeBytes() {
	x.StoreSizeBytes = nil
}

func (x *PartitionStats) ClearLastWriteTime() {
	x.LastWriteTime = nil
}

func (x *PartitionStats) ClearMaxWriteTimeLag() {
	x.MaxWriteTimeLag = nil
}

func (x *PartitionStats) ClearBytesWritten() {
	x.BytesWritten = nil
}

// Deprecated: Marked as deprecated in protos/ydb_topic.proto.
func (x *PartitionStats) ClearPartitionNodeId() {
	x.PartitionNodeId = nil
}

type PartitionStats_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Partition contains messages with offsets in range [start, end).
	PartitionOffsets *OffsetsRange
	// Approximate size of partition.
	StoreSizeBytes *int64
	// Timestamp of last write.
	LastWriteTime *timestamppb.Timestamp
	// Maximum of differences between write timestamp and create timestamp for all messages, written during last minute.
	MaxWriteTimeLag *durationpb.Duration
	// How much bytes were written during several windows in this partition.
	BytesWritten *MultipleWindowsStat
	// Partition host. Useful for debugging purposes.
	//
	// Deprecated: Marked as deprecated in protos/ydb_topic.proto.
	PartitionNodeId *int32
}

func (b0 PartitionStats_builder) Build() *PartitionStats {
	m0 := &PartitionStats{}
	b, x := &b0, m0
	_, _ = b, x
	x.PartitionOffsets = b.PartitionOffsets
	x.StoreSizeBytes = b.StoreSizeBytes
	x.LastWriteTime = b.LastWriteTime
	x.MaxWriteTimeLag = b.MaxWriteTimeLag
	x.BytesWritten = b.BytesWritten
	x.PartitionNodeId = b.PartitionNodeId
	return m0
}

// Update existing topic request sent from client to server.
type AlterTopicRequest struct {
	state           protoimpl.MessageState          `protogen:"hybrid.v1"`
	OperationParams *Ydb_Operations.OperationParams `protobuf:"bytes,1,opt,name=operation_params,json=operationParams" json:"operation_params,omitempty"`
	// Topic path.
	Path                      *string                    `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	AlterPartitioningSettings *AlterPartitioningSettings `protobuf:"bytes,3,opt,name=alter_partitioning_settings,json=alterPartitioningSettings" json:"alter_partitioning_settings,omitempty"` // partitioning_settings
	// Retention settings.
	// Currently, only one limit may be set, so other should not be set.
	//
	// How long data in partition should be stored. Must be greater than 0 and less than limit for this database.
	// Default limit - 36 hours.
	SetRetentionPeriod *durationpb.Duration `protobuf:"bytes,4,opt,name=set_retention_period,json=setRetentionPeriod" json:"set_retention_period,omitempty"`
	// How much data in partition should be stored. Must be greater than 0 and less than limit for this database.
	SetRetentionStorageMb *int64 `protobuf:"varint,5,opt,name=set_retention_storage_mb,json=setRetentionStorageMb" json:"set_retention_storage_mb,omitempty"`
	// List of allowed codecs for writers.
	// Writes with codec not from this list are forbidden.
	// If empty, codec compatibility check for the topic is disabled.
	SetSupportedCodecs *SupportedCodecs `protobuf:"bytes,7,opt,name=set_supported_codecs,json=setSupportedCodecs" json:"set_supported_codecs,omitempty"`
	// Partition write speed in bytes per second. Must be less than database limit. Default limit - 1 MB/s.
	SetPartitionWriteSpeedBytesPerSecond *int64 `protobuf:"varint,8,opt,name=set_partition_write_speed_bytes_per_second,json=setPartitionWriteSpeedBytesPerSecond" json:"set_partition_write_speed_bytes_per_second,omitempty"`
	// Burst size for write in partition, in bytes. Must be less than database limit. Default limit - 1 MB.
	SetPartitionWriteBurstBytes *int64 `protobuf:"varint,9,opt,name=set_partition_write_burst_bytes,json=setPartitionWriteBurstBytes" json:"set_partition_write_burst_bytes,omitempty"`
	// User and server attributes of topic. Server attributes starts from "_" and will be validated by server.
	// Leave the value blank to drop an attribute.
	AlterAttributes map[string]string `protobuf:"bytes,10,rep,name=alter_attributes,json=alterAttributes" json:"alter_attributes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Add consumers.
	AddConsumers []*Consumer `protobuf:"bytes,11,rep,name=add_consumers,json=addConsumers" json:"add_consumers,omitempty"`
	// Remove consumers (by their names)
	DropConsumers []string `protobuf:"bytes,12,rep,name=drop_consumers,json=dropConsumers" json:"drop_consumers,omitempty"`
	// Alter consumers
	AlterConsumers []*AlterConsumer `protobuf:"bytes,13,rep,name=alter_consumers,json=alterConsumers" json:"alter_consumers,omitempty"`
	// Set metering mode for topic in serverless database.
	SetMeteringMode *MeteringMode `protobuf:"varint,14,opt,name=set_metering_mode,json=setMeteringMode,enum=Ydb.Topic.MeteringMode" json:"set_metering_mode,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *AlterTopicRequest) Reset() {
	*x = AlterTopicRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[40]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AlterTopicRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AlterTopicRequest) ProtoMessage() {}

func (x *AlterTopicRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[40]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *AlterTopicRequest) GetOperationParams() *Ydb_Operations.OperationParams {
	if x != nil {
		return x.OperationParams
	}
	return nil
}

func (x *AlterTopicRequest) GetPath() string {
	if x != nil && x.Path != nil {
		return *x.Path
	}
	return ""
}

func (x *AlterTopicRequest) GetAlterPartitioningSettings() *AlterPartitioningSettings {
	if x != nil {
		return x.AlterPartitioningSettings
	}
	return nil
}

func (x *AlterTopicRequest) GetSetRetentionPeriod() *durationpb.Duration {
	if x != nil {
		return x.SetRetentionPeriod
	}
	return nil
}

func (x *AlterTopicRequest) GetSetRetentionStorageMb() int64 {
	if x != nil && x.SetRetentionStorageMb != nil {
		return *x.SetRetentionStorageMb
	}
	return 0
}

func (x *AlterTopicRequest) GetSetSupportedCodecs() *SupportedCodecs {
	if x != nil {
		return x.SetSupportedCodecs
	}
	return nil
}

func (x *AlterTopicRequest) GetSetPartitionWriteSpeedBytesPerSecond() int64 {
	if x != nil && x.SetPartitionWriteSpeedBytesPerSecond != nil {
		return *x.SetPartitionWriteSpeedBytesPerSecond
	}
	return 0
}

func (x *AlterTopicRequest) GetSetPartitionWriteBurstBytes() int64 {
	if x != nil && x.SetPartitionWriteBurstBytes != nil {
		return *x.SetPartitionWriteBurstBytes
	}
	return 0
}

func (x *AlterTopicRequest) GetAlterAttributes() map[string]string {
	if x != nil {
		return x.AlterAttributes
	}
	return nil
}

func (x *AlterTopicRequest) GetAddConsumers() []*Consumer {
	if x != nil {
		return x.AddConsumers
	}
	return nil
}

func (x *AlterTopicRequest) GetDropConsumers() []string {
	if x != nil {
		return x.DropConsumers
	}
	return nil
}

func (x *AlterTopicRequest) GetAlterConsumers() []*AlterConsumer {
	if x != nil {
		return x.AlterConsumers
	}
	return nil
}

func (x *AlterTopicRequest) GetSetMeteringMode() MeteringMode {
	if x != nil && x.SetMeteringMode != nil {
		return *x.SetMeteringMode
	}
	return MeteringMode_METERING_MODE_UNSPECIFIED
}

func (x *AlterTopicRequest) SetOperationParams(v *Ydb_Operations.OperationParams) {
	x.OperationParams = v
}

func (x *AlterTopicRequest) SetPath(v string) {
	x.Path = &v
}

func (x *AlterTopicRequest) SetAlterPartitioningSettings(v *AlterPartitioningSettings) {
	x.AlterPartitioningSettings = v
}

func (x *AlterTopicRequest) SetSetRetentionPeriod(v *durationpb.Duration) {
	x.SetRetentionPeriod = v
}

func (x *AlterTopicRequest) SetSetRetentionStorageMb(v int64) {
	x.SetRetentionStorageMb = &v
}

func (x *AlterTopicRequest) SetSetSupportedCodecs(v *SupportedCodecs) {
	x.SetSupportedCodecs = v
}

func (x *AlterTopicRequest) SetSetPartitionWriteSpeedBytesPerSecond(v int64) {
	x.SetPartitionWriteSpeedBytesPerSecond = &v
}

func (x *AlterTopicRequest) SetSetPartitionWriteBurstBytes(v int64) {
	x.SetPartitionWriteBurstBytes = &v
}

func (x *AlterTopicRequest) SetAlterAttributes(v map[string]string) {
	x.AlterAttributes = v
}

func (x *AlterTopicRequest) SetAddConsumers(v []*Consumer) {
	x.AddConsumers = v
}

func (x *AlterTopicRequest) SetDropConsumers(v []string) {
	x.DropConsumers = v
}

func (x *AlterTopicRequest) SetAlterConsumers(v []*AlterConsumer) {
	x.AlterConsumers = v
}

func (x *AlterTopicRequest) SetSetMeteringMode(v MeteringMode) {
	x.SetMeteringMode = &v
}

func (x *AlterTopicRequest) HasOperationParams() bool {
	if x == nil {
		return false
	}
	return x.OperationParams != nil
}

func (x *AlterTopicRequest) HasPath() bool {
	if x == nil {
		return false
	}
	return x.Path != nil
}

func (x *AlterTopicRequest) HasAlterPartitioningSettings() bool {
	if x == nil {
		return false
	}
	return x.AlterPartitioningSettings != nil
}

func (x *AlterTopicRequest) HasSetRetentionPeriod() bool {
	if x == nil {
		return false
	}
	return x.SetRetentionPeriod != nil
}

func (x *AlterTopicRequest) HasSetRetentionStorageMb() bool {
	if x == nil {
		return false
	}
	return x.SetRetentionStorageMb != nil
}

func (x *AlterTopicRequest) HasSetSupportedCodecs() bool {
	if x == nil {
		return false
	}
	return x.SetSupportedCodecs != nil
}

func (x *AlterTopicRequest) HasSetPartitionWriteSpeedBytesPerSecond() bool {
	if x == nil {
		return false
	}
	return x.SetPartitionWriteSpeedBytesPerSecond != nil
}

func (x *AlterTopicRequest) HasSetPartitionWriteBurstBytes() bool {
	if x == nil {
		return false
	}
	return x.SetPartitionWriteBurstBytes != nil
}

func (x *AlterTopicRequest) HasSetMeteringMode() bool {
	if x == nil {
		return false
	}
	return x.SetMeteringMode != nil
}

func (x *AlterTopicRequest) ClearOperationParams() {
	x.OperationParams = nil
}

func (x *AlterTopicRequest) ClearPath() {
	x.Path = nil
}

func (x *AlterTopicRequest) ClearAlterPartitioningSettings() {
	x.AlterPartitioningSettings = nil
}

func (x *AlterTopicRequest) ClearSetRetentionPeriod() {
	x.SetRetentionPeriod = nil
}

func (x *AlterTopicRequest) ClearSetRetentionStorageMb() {
	x.SetRetentionStorageMb = nil
}

func (x *AlterTopicRequest) ClearSetSupportedCodecs() {
	x.SetSupportedCodecs = nil
}

func (x *AlterTopicRequest) ClearSetPartitionWriteSpeedBytesPerSecond() {
	x.SetPartitionWriteSpeedBytesPerSecond = nil
}

func (x *AlterTopicRequest) ClearSetPartitionWriteBurstBytes() {
	x.SetPartitionWriteBurstBytes = nil
}

func (x *AlterTopicRequest) ClearSetMeteringMode() {
	x.SetMeteringMode = nil
}

type AlterTopicRequest_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	OperationParams *Ydb_Operations.OperationParams
	// Topic path.
	Path                      *string
	AlterPartitioningSettings *AlterPartitioningSettings
	// Retention settings.
	// Currently, only one limit may be set, so other should not be set.
	//
	// How long data in partition should be stored. Must be greater than 0 and less than limit for this database.
	// Default limit - 36 hours.
	SetRetentionPeriod *durationpb.Duration
	// How much data in partition should be stored. Must be greater than 0 and less than limit for this database.
	SetRetentionStorageMb *int64
	// List of allowed codecs for writers.
	// Writes with codec not from this list are forbidden.
	// If empty, codec compatibility check for the topic is disabled.
	SetSupportedCodecs *SupportedCodecs
	// Partition write speed in bytes per second. Must be less than database limit. Default limit - 1 MB/s.
	SetPartitionWriteSpeedBytesPerSecond *int64
	// Burst size for write in partition, in bytes. Must be less than database limit. Default limit - 1 MB.
	SetPartitionWriteBurstBytes *int64
	// User and server attributes of topic. Server attributes starts from "_" and will be validated by server.
	// Leave the value blank to drop an attribute.
	AlterAttributes map[string]string
	// Add consumers.
	AddConsumers []*Consumer
	// Remove consumers (by their names)
	DropConsumers []string
	// Alter consumers
	AlterConsumers []*AlterConsumer
	// Set metering mode for topic in serverless database.
	SetMeteringMode *MeteringMode
}

func (b0 AlterTopicRequest_builder) Build() *AlterTopicRequest {
	m0 := &AlterTopicRequest{}
	b, x := &b0, m0
	_, _ = b, x
	x.OperationParams = b.OperationParams
	x.Path = b.Path
	x.AlterPartitioningSettings = b.AlterPartitioningSettings
	x.SetRetentionPeriod = b.SetRetentionPeriod
	x.SetRetentionStorageMb = b.SetRetentionStorageMb
	x.SetSupportedCodecs = b.SetSupportedCodecs
	x.SetPartitionWriteSpeedBytesPerSecond = b.SetPartitionWriteSpeedBytesPerSecond
	x.SetPartitionWriteBurstBytes = b.SetPartitionWriteBurstBytes
	x.AlterAttributes = b.AlterAttributes
	x.AddConsumers = b.AddConsumers
	x.DropConsumers = b.DropConsumers
	x.AlterConsumers = b.AlterConsumers
	x.SetMeteringMode = b.SetMeteringMode
	return m0
}

// Update topic response sent from server to client.
type AlterTopicResponse struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Result of request will be inside operation.
	Operation     *Ydb_Operations.Operation `protobuf:"bytes,1,opt,name=operation" json:"operation,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AlterTopicResponse) Reset() {
	*x = AlterTopicResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[41]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AlterTopicResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AlterTopicResponse) ProtoMessage() {}

func (x *AlterTopicResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[41]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *AlterTopicResponse) GetOperation() *Ydb_Operations.Operation {
	if x != nil {
		return x.Operation
	}
	return nil
}

func (x *AlterTopicResponse) SetOperation(v *Ydb_Operations.Operation) {
	x.Operation = v
}

func (x *AlterTopicResponse) HasOperation() bool {
	if x == nil {
		return false
	}
	return x.Operation != nil
}

func (x *AlterTopicResponse) ClearOperation() {
	x.Operation = nil
}

type AlterTopicResponse_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Result of request will be inside operation.
	Operation *Ydb_Operations.Operation
}

func (b0 AlterTopicResponse_builder) Build() *AlterTopicResponse {
	m0 := &AlterTopicResponse{}
	b, x := &b0, m0
	_, _ = b, x
	x.Operation = b.Operation
	return m0
}

// Update topic result message that will be inside UpdateTopicResponse.operation.
type AlterTopicResult struct {
	state         protoimpl.MessageState `protogen:"hybrid.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AlterTopicResult) Reset() {
	*x = AlterTopicResult{}
	mi := &file_protos_ydb_topic_proto_msgTypes[42]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AlterTopicResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AlterTopicResult) ProtoMessage() {}

func (x *AlterTopicResult) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[42]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

type AlterTopicResult_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

}

func (b0 AlterTopicResult_builder) Build() *AlterTopicResult {
	m0 := &AlterTopicResult{}
	b, x := &b0, m0
	_, _ = b, x
	return m0
}

// Drop topic request sent from client to server.
type DropTopicRequest struct {
	state           protoimpl.MessageState          `protogen:"hybrid.v1"`
	OperationParams *Ydb_Operations.OperationParams `protobuf:"bytes,1,opt,name=operation_params,json=operationParams" json:"operation_params,omitempty"`
	// Topic path.
	Path          *string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DropTopicRequest) Reset() {
	*x = DropTopicRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[43]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DropTopicRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DropTopicRequest) ProtoMessage() {}

func (x *DropTopicRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[43]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *DropTopicRequest) GetOperationParams() *Ydb_Operations.OperationParams {
	if x != nil {
		return x.OperationParams
	}
	return nil
}

func (x *DropTopicRequest) GetPath() string {
	if x != nil && x.Path != nil {
		return *x.Path
	}
	return ""
}

func (x *DropTopicRequest) SetOperationParams(v *Ydb_Operations.OperationParams) {
	x.OperationParams = v
}

func (x *DropTopicRequest) SetPath(v string) {
	x.Path = &v
}

func (x *DropTopicRequest) HasOperationParams() bool {
	if x == nil {
		return false
	}
	return x.OperationParams != nil
}

func (x *DropTopicRequest) HasPath() bool {
	if x == nil {
		return false
	}
	return x.Path != nil
}

func (x *DropTopicRequest) ClearOperationParams() {
	x.OperationParams = nil
}

func (x *DropTopicRequest) ClearPath() {
	x.Path = nil
}

type DropTopicRequest_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	OperationParams *Ydb_Operations.OperationParams
	// Topic path.
	Path *string
}

func (b0 DropTopicRequest_builder) Build() *DropTopicRequest {
	m0 := &DropTopicRequest{}
	b, x := &b0, m0
	_, _ = b, x
	x.OperationParams = b.OperationParams
	x.Path = b.Path
	return m0
}

// Drop topic response sent from server to client.
// If topic not exists then response status will be "SCHEME_ERROR".
type DropTopicResponse struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Result of request will be inside operation.
	Operation     *Ydb_Operations.Operation `protobuf:"bytes,1,opt,name=operation" json:"operation,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DropTopicResponse) Reset() {
	*x = DropTopicResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[44]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DropTopicResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DropTopicResponse) ProtoMessage() {}

func (x *DropTopicResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[44]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *DropTopicResponse) GetOperation() *Ydb_Operations.Operation {
	if x != nil {
		return x.Operation
	}
	return nil
}

func (x *DropTopicResponse) SetOperation(v *Ydb_Operations.Operation) {
	x.Operation = v
}

func (x *DropTopicResponse) HasOperation() bool {
	if x == nil {
		return false
	}
	return x.Operation != nil
}

func (x *DropTopicResponse) ClearOperation() {
	x.Operation = nil
}

type DropTopicResponse_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Result of request will be inside operation.
	Operation *Ydb_Operations.Operation
}

func (b0 DropTopicResponse_builder) Build() *DropTopicResponse {
	m0 := &DropTopicResponse{}
	b, x := &b0, m0
	_, _ = b, x
	x.Operation = b.Operation
	return m0
}

// Drop topic result message that will be inside DropTopicResponse.operation.
type DropTopicResult struct {
	state         protoimpl.MessageState `protogen:"hybrid.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DropTopicResult) Reset() {
	*x = DropTopicResult{}
	mi := &file_protos_ydb_topic_proto_msgTypes[45]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DropTopicResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DropTopicResult) ProtoMessage() {}

func (x *DropTopicResult) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[45]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

type DropTopicResult_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

}

func (b0 DropTopicResult_builder) Build() *DropTopicResult {
	m0 := &DropTopicResult{}
	b, x := &b0, m0
	_, _ = b, x
	return m0
}

// Client-server message for write session. Contains one of:
//
//	InitRequest - handshake request.
//	WriteRequest - portion of data to be written.
//	UpdateTokenRequest - user credentials if update is needed.
type StreamWriteMessage_FromClient struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Types that are valid to be assigned to ClientMessage:
	//
	//	*StreamWriteMessage_FromClient_InitRequest
	//	*StreamWriteMessage_FromClient_WriteRequest
	//	*StreamWriteMessage_FromClient_UpdateTokenRequest
	ClientMessage isStreamWriteMessage_FromClient_ClientMessage `protobuf_oneof:"client_message"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamWriteMessage_FromClient) Reset() {
	*x = StreamWriteMessage_FromClient{}
	mi := &file_protos_ydb_topic_proto_msgTypes[46]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamWriteMessage_FromClient) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamWriteMessage_FromClient) ProtoMessage() {}

func (x *StreamWriteMessage_FromClient) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[46]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamWriteMessage_FromClient) GetClientMessage() isStreamWriteMessage_FromClient_ClientMessage {
	if x != nil {
		return x.ClientMessage
	}
	return nil
}

func (x *StreamWriteMessage_FromClient) GetInitRequest() *StreamWriteMessage_InitRequest {
	if x != nil {
		if x, ok := x.ClientMessage.(*StreamWriteMessage_FromClient_InitRequest); ok {
			return x.InitRequest
		}
	}
	return nil
}

func (x *StreamWriteMessage_FromClient) GetWriteRequest() *StreamWriteMessage_WriteRequest {
	if x != nil {
		if x, ok := x.ClientMessage.(*StreamWriteMessage_FromClient_WriteRequest); ok {
			return x.WriteRequest
		}
	}
	return nil
}

func (x *StreamWriteMessage_FromClient) GetUpdateTokenRequest() *UpdateTokenRequest {
	if x != nil {
		if x, ok := x.ClientMessage.(*StreamWriteMessage_FromClient_UpdateTokenRequest); ok {
			return x.UpdateTokenRequest
		}
	}
	return nil
}

func (x *StreamWriteMessage_FromClient) SetInitRequest(v *StreamWriteMessage_InitRequest) {
	if v == nil {
		x.ClientMessage = nil
		return
	}
	x.ClientMessage = &StreamWriteMessage_FromClient_InitRequest{v}
}

func (x *StreamWriteMessage_FromClient) SetWriteRequest(v *StreamWriteMessage_WriteRequest) {
	if v == nil {
		x.ClientMessage = nil
		return
	}
	x.ClientMessage = &StreamWriteMessage_FromClient_WriteRequest{v}
}

func (x *StreamWriteMessage_FromClient) SetUpdateTokenRequest(v *UpdateTokenRequest) {
	if v == nil {
		x.ClientMessage = nil
		return
	}
	x.ClientMessage = &StreamWriteMessage_FromClient_UpdateTokenRequest{v}
}

func (x *StreamWriteMessage_FromClient) HasClientMessage() bool {
	if x == nil {
		return false
	}
	return x.ClientMessage != nil
}

func (x *StreamWriteMessage_FromClient) HasInitRequest() bool {
	if x == nil {
		return false
	}
	_, ok := x.ClientMessage.(*StreamWriteMessage_FromClient_InitRequest)
	return ok
}

func (x *StreamWriteMessage_FromClient) HasWriteRequest() bool {
	if x == nil {
		return false
	}
	_, ok := x.ClientMessage.(*StreamWriteMessage_FromClient_WriteRequest)
	return ok
}

func (x *StreamWriteMessage_FromClient) HasUpdateTokenRequest() bool {
	if x == nil {
		return false
	}
	_, ok := x.ClientMessage.(*StreamWriteMessage_FromClient_UpdateTokenRequest)
	return ok
}

func (x *StreamWriteMessage_FromClient) ClearClientMessage() {
	x.ClientMessage = nil
}

func (x *StreamWriteMessage_FromClient) ClearInitRequest() {
	if _, ok := x.ClientMessage.(*StreamWriteMessage_FromClient_InitRequest); ok {
		x.ClientMessage = nil
	}
}

func (x *StreamWriteMessage_FromClient) ClearWriteRequest() {
	if _, ok := x.ClientMessage.(*StreamWriteMessage_FromClient_WriteRequest); ok {
		x.ClientMessage = nil
	}
}

func (x *StreamWriteMessage_FromClient) ClearUpdateTokenRequest() {
	if _, ok := x.ClientMessage.(*StreamWriteMessage_FromClient_UpdateTokenRequest); ok {
		x.ClientMessage = nil
	}
}

const StreamWriteMessage_FromClient_ClientMessage_not_set_case case_StreamWriteMessage_FromClient_ClientMessage = 0
const StreamWriteMessage_FromClient_InitRequest_case case_StreamWriteMessage_FromClient_ClientMessage = 1
const StreamWriteMessage_FromClient_WriteRequest_case case_StreamWriteMessage_FromClient_ClientMessage = 2
const StreamWriteMessage_FromClient_UpdateTokenRequest_case case_StreamWriteMessage_FromClient_ClientMessage = 3

func (x *StreamWriteMessage_FromClient) WhichClientMessage() case_StreamWriteMessage_FromClient_ClientMessage {
	if x == nil {
		return StreamWriteMessage_FromClient_ClientMessage_not_set_case
	}
	switch x.ClientMessage.(type) {
	case *StreamWriteMessage_FromClient_InitRequest:
		return StreamWriteMessage_FromClient_InitRequest_case
	case *StreamWriteMessage_FromClient_WriteRequest:
		return StreamWriteMessage_FromClient_WriteRequest_case
	case *StreamWriteMessage_FromClient_UpdateTokenRequest:
		return StreamWriteMessage_FromClient_UpdateTokenRequest_case
	default:
		return StreamWriteMessage_FromClient_ClientMessage_not_set_case
	}
}

type StreamWriteMessage_FromClient_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Fields of oneof ClientMessage:
	InitRequest        *StreamWriteMessage_InitRequest
	WriteRequest       *StreamWriteMessage_WriteRequest
	UpdateTokenRequest *UpdateTokenRequest
	// -- end of ClientMessage
}

func (b0 StreamWriteMessage_FromClient_builder) Build() *StreamWriteMessage_FromClient {
	m0 := &StreamWriteMessage_FromClient{}
	b, x := &b0, m0
	_, _ = b, x
	if b.InitRequest != nil {
		x.ClientMessage = &StreamWriteMessage_FromClient_InitRequest{b.InitRequest}
	}
	if b.WriteRequest != nil {
		x.ClientMessage = &StreamWriteMessage_FromClient_WriteRequest{b.WriteRequest}
	}
	if b.UpdateTokenRequest != nil {
		x.ClientMessage = &StreamWriteMessage_FromClient_UpdateTokenRequest{b.UpdateTokenRequest}
	}
	return m0
}

type case_StreamWriteMessage_FromClient_ClientMessage protoreflect.FieldNumber

func (x case_StreamWriteMessage_FromClient_ClientMessage) String() string {
	md := file_protos_ydb_topic_proto_msgTypes[46].Descriptor()
	if x == 0 {
		return "not set"
	}
	return protoimpl.X.MessageFieldStringOf(md, protoreflect.FieldNumber(x))
}

type isStreamWriteMessage_FromClient_ClientMessage interface {
	isStreamWriteMessage_FromClient_ClientMessage()
}

type StreamWriteMessage_FromClient_InitRequest struct {
	InitRequest *StreamWriteMessage_InitRequest `protobuf:"bytes,1,opt,name=init_request,json=initRequest,oneof"`
}

type StreamWriteMessage_FromClient_WriteRequest struct {
	WriteRequest *StreamWriteMessage_WriteRequest `protobuf:"bytes,2,opt,name=write_request,json=writeRequest,oneof"`
}

type StreamWriteMessage_FromClient_UpdateTokenRequest struct {
	UpdateTokenRequest *UpdateTokenRequest `protobuf:"bytes,3,opt,name=update_token_request,json=updateTokenRequest,oneof"`
}

func (*StreamWriteMessage_FromClient_InitRequest) isStreamWriteMessage_FromClient_ClientMessage() {}

func (*StreamWriteMessage_FromClient_WriteRequest) isStreamWriteMessage_FromClient_ClientMessage() {}

func (*StreamWriteMessage_FromClient_UpdateTokenRequest) isStreamWriteMessage_FromClient_ClientMessage() {
}

// Server-client message for write session. Contains either non-success status, or one of:
//
//	InitResponse - correct handshake response.
//	WriteResponse - acknowledgment of storing client messages.
//	UpdateTokenResponse - acknowledgment of reauthentication and reauthorization.
type StreamWriteMessage_FromServer struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Server status of response.
	Status *Ydb.StatusIds_StatusCode `protobuf:"varint,1,opt,name=status,enum=Ydb.StatusIds_StatusCode" json:"status,omitempty"`
	// Issues if any.
	Issues []*Ydb_Issue.IssueMessage `protobuf:"bytes,2,rep,name=issues" json:"issues,omitempty"`
	// Types that are valid to be assigned to ServerMessage:
	//
	//	*StreamWriteMessage_FromServer_InitResponse
	//	*StreamWriteMessage_FromServer_WriteResponse
	//	*StreamWriteMessage_FromServer_UpdateTokenResponse
	ServerMessage isStreamWriteMessage_FromServer_ServerMessage `protobuf_oneof:"server_message"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamWriteMessage_FromServer) Reset() {
	*x = StreamWriteMessage_FromServer{}
	mi := &file_protos_ydb_topic_proto_msgTypes[47]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamWriteMessage_FromServer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamWriteMessage_FromServer) ProtoMessage() {}

func (x *StreamWriteMessage_FromServer) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[47]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamWriteMessage_FromServer) GetStatus() Ydb.StatusIds_StatusCode {
	if x != nil && x.Status != nil {
		return *x.Status
	}
	return Ydb.StatusIds_StatusCode(0)
}

func (x *StreamWriteMessage_FromServer) GetIssues() []*Ydb_Issue.IssueMessage {
	if x != nil {
		return x.Issues
	}
	return nil
}

func (x *StreamWriteMessage_FromServer) GetServerMessage() isStreamWriteMessage_FromServer_ServerMessage {
	if x != nil {
		return x.ServerMessage
	}
	return nil
}

func (x *StreamWriteMessage_FromServer) GetInitResponse() *StreamWriteMessage_InitResponse {
	if x != nil {
		if x, ok := x.ServerMessage.(*StreamWriteMessage_FromServer_InitResponse); ok {
			return x.InitResponse
		}
	}
	return nil
}

func (x *StreamWriteMessage_FromServer) GetWriteResponse() *StreamWriteMessage_WriteResponse {
	if x != nil {
		if x, ok := x.ServerMessage.(*StreamWriteMessage_FromServer_WriteResponse); ok {
			return x.WriteResponse
		}
	}
	return nil
}

func (x *StreamWriteMessage_FromServer) GetUpdateTokenResponse() *UpdateTokenResponse {
	if x != nil {
		if x, ok := x.ServerMessage.(*StreamWriteMessage_FromServer_UpdateTokenResponse); ok {
			return x.UpdateTokenResponse
		}
	}
	return nil
}

func (x *StreamWriteMessage_FromServer) SetStatus(v Ydb.StatusIds_StatusCode) {
	x.Status = &v
}

func (x *StreamWriteMessage_FromServer) SetIssues(v []*Ydb_Issue.IssueMessage) {
	x.Issues = v
}

func (x *StreamWriteMessage_FromServer) SetInitResponse(v *StreamWriteMessage_InitResponse) {
	if v == nil {
		x.ServerMessage = nil
		return
	}
	x.ServerMessage = &StreamWriteMessage_FromServer_InitResponse{v}
}

func (x *StreamWriteMessage_FromServer) SetWriteResponse(v *StreamWriteMessage_WriteResponse) {
	if v == nil {
		x.ServerMessage = nil
		return
	}
	x.ServerMessage = &StreamWriteMessage_FromServer_WriteResponse{v}
}

func (x *StreamWriteMessage_FromServer) SetUpdateTokenResponse(v *UpdateTokenResponse) {
	if v == nil {
		x.ServerMessage = nil
		return
	}
	x.ServerMessage = &StreamWriteMessage_FromServer_UpdateTokenResponse{v}
}

func (x *StreamWriteMessage_FromServer) HasStatus() bool {
	if x == nil {
		return false
	}
	return x.Status != nil
}

func (x *StreamWriteMessage_FromServer) HasServerMessage() bool {
	if x == nil {
		return false
	}
	return x.ServerMessage != nil
}

func (x *StreamWriteMessage_FromServer) HasInitResponse() bool {
	if x == nil {
		return false
	}
	_, ok := x.ServerMessage.(*StreamWriteMessage_FromServer_InitResponse)
	return ok
}

func (x *StreamWriteMessage_FromServer) HasWriteResponse() bool {
	if x == nil {
		return false
	}
	_, ok := x.ServerMessage.(*StreamWriteMessage_FromServer_WriteResponse)
	return ok
}

func (x *StreamWriteMessage_FromServer) HasUpdateTokenResponse() bool {
	if x == nil {
		return false
	}
	_, ok := x.ServerMessage.(*StreamWriteMessage_FromServer_UpdateTokenResponse)
	return ok
}

func (x *StreamWriteMessage_FromServer) ClearStatus() {
	x.Status = nil
}

func (x *StreamWriteMessage_FromServer) ClearServerMessage() {
	x.ServerMessage = nil
}

func (x *StreamWriteMessage_FromServer) ClearInitResponse() {
	if _, ok := x.ServerMessage.(*StreamWriteMessage_FromServer_InitResponse); ok {
		x.ServerMessage = nil
	}
}

func (x *StreamWriteMessage_FromServer) ClearWriteResponse() {
	if _, ok := x.ServerMessage.(*StreamWriteMessage_FromServer_WriteResponse); ok {
		x.ServerMessage = nil
	}
}

func (x *StreamWriteMessage_FromServer) ClearUpdateTokenResponse() {
	if _, ok := x.ServerMessage.(*StreamWriteMessage_FromServer_UpdateTokenResponse); ok {
		x.ServerMessage = nil
	}
}

const StreamWriteMessage_FromServer_ServerMessage_not_set_case case_StreamWriteMessage_FromServer_ServerMessage = 0
const StreamWriteMessage_FromServer_InitResponse_case case_StreamWriteMessage_FromServer_ServerMessage = 3
const StreamWriteMessage_FromServer_WriteResponse_case case_StreamWriteMessage_FromServer_ServerMessage = 4
const StreamWriteMessage_FromServer_UpdateTokenResponse_case case_StreamWriteMessage_FromServer_ServerMessage = 5

func (x *StreamWriteMessage_FromServer) WhichServerMessage() case_StreamWriteMessage_FromServer_ServerMessage {
	if x == nil {
		return StreamWriteMessage_FromServer_ServerMessage_not_set_case
	}
	switch x.ServerMessage.(type) {
	case *StreamWriteMessage_FromServer_InitResponse:
		return StreamWriteMessage_FromServer_InitResponse_case
	case *StreamWriteMessage_FromServer_WriteResponse:
		return StreamWriteMessage_FromServer_WriteResponse_case
	case *StreamWriteMessage_FromServer_UpdateTokenResponse:
		return StreamWriteMessage_FromServer_UpdateTokenResponse_case
	default:
		return StreamWriteMessage_FromServer_ServerMessage_not_set_case
	}
}

type StreamWriteMessage_FromServer_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Server status of response.
	Status *Ydb.StatusIds_StatusCode
	// Issues if any.
	Issues []*Ydb_Issue.IssueMessage
	// Fields of oneof ServerMessage:
	InitResponse        *StreamWriteMessage_InitResponse
	WriteResponse       *StreamWriteMessage_WriteResponse
	UpdateTokenResponse *UpdateTokenResponse
	// -- end of ServerMessage
}

func (b0 StreamWriteMessage_FromServer_builder) Build() *StreamWriteMessage_FromServer {
	m0 := &StreamWriteMessage_FromServer{}
	b, x := &b0, m0
	_, _ = b, x
	x.Status = b.Status
	x.Issues = b.Issues
	if b.InitResponse != nil {
		x.ServerMessage = &StreamWriteMessage_FromServer_InitResponse{b.InitResponse}
	}
	if b.WriteResponse != nil {
		x.ServerMessage = &StreamWriteMessage_FromServer_WriteResponse{b.WriteResponse}
	}
	if b.UpdateTokenResponse != nil {
		x.ServerMessage = &StreamWriteMessage_FromServer_UpdateTokenResponse{b.UpdateTokenResponse}
	}
	return m0
}

type case_StreamWriteMessage_FromServer_ServerMessage protoreflect.FieldNumber

func (x case_StreamWriteMessage_FromServer_ServerMessage) String() string {
	md := file_protos_ydb_topic_proto_msgTypes[47].Descriptor()
	if x == 0 {
		return "not set"
	}
	return protoimpl.X.MessageFieldStringOf(md, protoreflect.FieldNumber(x))
}

type isStreamWriteMessage_FromServer_ServerMessage interface {
	isStreamWriteMessage_FromServer_ServerMessage()
}

type StreamWriteMessage_FromServer_InitResponse struct {
	InitResponse *StreamWriteMessage_InitResponse `protobuf:"bytes,3,opt,name=init_response,json=initResponse,oneof"`
}

type StreamWriteMessage_FromServer_WriteResponse struct {
	WriteResponse *StreamWriteMessage_WriteResponse `protobuf:"bytes,4,opt,name=write_response,json=writeResponse,oneof"`
}

type StreamWriteMessage_FromServer_UpdateTokenResponse struct {
	UpdateTokenResponse *UpdateTokenResponse `protobuf:"bytes,5,opt,name=update_token_response,json=updateTokenResponse,oneof"`
}

func (*StreamWriteMessage_FromServer_InitResponse) isStreamWriteMessage_FromServer_ServerMessage() {}

func (*StreamWriteMessage_FromServer_WriteResponse) isStreamWriteMessage_FromServer_ServerMessage() {}

func (*StreamWriteMessage_FromServer_UpdateTokenResponse) isStreamWriteMessage_FromServer_ServerMessage() {
}

// Handshake request that must be sent to server first.
type StreamWriteMessage_InitRequest struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Full path of topic to write to.
	Path *string `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	// Producer identifier of client data stream.
	// Used for message deduplication by sequence numbers.
	ProducerId *string `protobuf:"bytes,2,opt,name=producer_id,json=producerId" json:"producer_id,omitempty"`
	// User metadata attached to this write session.
	// Reader will get this session meta data with each message read.
	WriteSessionMeta map[string]string `protobuf:"bytes,3,rep,name=write_session_meta,json=writeSessionMeta" json:"write_session_meta,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Option for setting order on messages.
	// If neither is set, no guarantees on ordering or partitions to write to.
	//
	// Types that are valid to be assigned to Partitioning:
	//
	//	*StreamWriteMessage_InitRequest_MessageGroupId
	//	*StreamWriteMessage_InitRequest_PartitionId
	//	*StreamWriteMessage_InitRequest_PartitionWithGeneration
	Partitioning isStreamWriteMessage_InitRequest_Partitioning `protobuf_oneof:"partitioning"`
	// Explicitly request for last sequential number
	// It may be expensive, if producer wrote to many partitions before.
	GetLastSeqNo  *bool `protobuf:"varint,6,opt,name=get_last_seq_no,json=getLastSeqNo" json:"get_last_seq_no,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamWriteMessage_InitRequest) Reset() {
	*x = StreamWriteMessage_InitRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[48]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamWriteMessage_InitRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamWriteMessage_InitRequest) ProtoMessage() {}

func (x *StreamWriteMessage_InitRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[48]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamWriteMessage_InitRequest) GetPath() string {
	if x != nil && x.Path != nil {
		return *x.Path
	}
	return ""
}

func (x *StreamWriteMessage_InitRequest) GetProducerId() string {
	if x != nil && x.ProducerId != nil {
		return *x.ProducerId
	}
	return ""
}

func (x *StreamWriteMessage_InitRequest) GetWriteSessionMeta() map[string]string {
	if x != nil {
		return x.WriteSessionMeta
	}
	return nil
}

func (x *StreamWriteMessage_InitRequest) GetPartitioning() isStreamWriteMessage_InitRequest_Partitioning {
	if x != nil {
		return x.Partitioning
	}
	return nil
}

func (x *StreamWriteMessage_InitRequest) GetMessageGroupId() string {
	if x != nil {
		if x, ok := x.Partitioning.(*StreamWriteMessage_InitRequest_MessageGroupId); ok {
			return x.MessageGroupId
		}
	}
	return ""
}

func (x *StreamWriteMessage_InitRequest) GetPartitionId() int64 {
	if x != nil {
		if x, ok := x.Partitioning.(*StreamWriteMessage_InitRequest_PartitionId); ok {
			return x.PartitionId
		}
	}
	return 0
}

func (x *StreamWriteMessage_InitRequest) GetPartitionWithGeneration() *PartitionWithGeneration {
	if x != nil {
		if x, ok := x.Partitioning.(*StreamWriteMessage_InitRequest_PartitionWithGeneration); ok {
			return x.PartitionWithGeneration
		}
	}
	return nil
}

func (x *StreamWriteMessage_InitRequest) GetGetLastSeqNo() bool {
	if x != nil && x.GetLastSeqNo != nil {
		return *x.GetLastSeqNo
	}
	return false
}

func (x *StreamWriteMessage_InitRequest) SetPath(v string) {
	x.Path = &v
}

func (x *StreamWriteMessage_InitRequest) SetProducerId(v string) {
	x.ProducerId = &v
}

func (x *StreamWriteMessage_InitRequest) SetWriteSessionMeta(v map[string]string) {
	x.WriteSessionMeta = v
}

func (x *StreamWriteMessage_InitRequest) SetMessageGroupId(v string) {
	x.Partitioning = &StreamWriteMessage_InitRequest_MessageGroupId{v}
}

func (x *StreamWriteMessage_InitRequest) SetPartitionId(v int64) {
	x.Partitioning = &StreamWriteMessage_InitRequest_PartitionId{v}
}

func (x *StreamWriteMessage_InitRequest) SetPartitionWithGeneration(v *PartitionWithGeneration) {
	if v == nil {
		x.Partitioning = nil
		return
	}
	x.Partitioning = &StreamWriteMessage_InitRequest_PartitionWithGeneration{v}
}

func (x *StreamWriteMessage_InitRequest) SetGetLastSeqNo(v bool) {
	x.GetLastSeqNo = &v
}

func (x *StreamWriteMessage_InitRequest) HasPath() bool {
	if x == nil {
		return false
	}
	return x.Path != nil
}

func (x *StreamWriteMessage_InitRequest) HasProducerId() bool {
	if x == nil {
		return false
	}
	return x.ProducerId != nil
}

func (x *StreamWriteMessage_InitRequest) HasPartitioning() bool {
	if x == nil {
		return false
	}
	return x.Partitioning != nil
}

func (x *StreamWriteMessage_InitRequest) HasMessageGroupId() bool {
	if x == nil {
		return false
	}
	_, ok := x.Partitioning.(*StreamWriteMessage_InitRequest_MessageGroupId)
	return ok
}

func (x *StreamWriteMessage_InitRequest) HasPartitionId() bool {
	if x == nil {
		return false
	}
	_, ok := x.Partitioning.(*StreamWriteMessage_InitRequest_PartitionId)
	return ok
}

func (x *StreamWriteMessage_InitRequest) HasPartitionWithGeneration() bool {
	if x == nil {
		return false
	}
	_, ok := x.Partitioning.(*StreamWriteMessage_InitRequest_PartitionWithGeneration)
	return ok
}

func (x *StreamWriteMessage_InitRequest) HasGetLastSeqNo() bool {
	if x == nil {
		return false
	}
	return x.GetLastSeqNo != nil
}

func (x *StreamWriteMessage_InitRequest) ClearPath() {
	x.Path = nil
}

func (x *StreamWriteMessage_InitRequest) ClearProducerId() {
	x.ProducerId = nil
}

func (x *StreamWriteMessage_InitRequest) ClearPartitioning() {
	x.Partitioning = nil
}

func (x *StreamWriteMessage_InitRequest) ClearMessageGroupId() {
	if _, ok := x.Partitioning.(*StreamWriteMessage_InitRequest_MessageGroupId); ok {
		x.Partitioning = nil
	}
}

func (x *StreamWriteMessage_InitRequest) ClearPartitionId() {
	if _, ok := x.Partitioning.(*StreamWriteMessage_InitRequest_PartitionId); ok {
		x.Partitioning = nil
	}
}

func (x *StreamWriteMessage_InitRequest) ClearPartitionWithGeneration() {
	if _, ok := x.Partitioning.(*StreamWriteMessage_InitRequest_PartitionWithGeneration); ok {
		x.Partitioning = nil
	}
}

func (x *StreamWriteMessage_InitRequest) ClearGetLastSeqNo() {
	x.GetLastSeqNo = nil
}

const StreamWriteMessage_InitRequest_Partitioning_not_set_case case_StreamWriteMessage_InitRequest_Partitioning = 0
const StreamWriteMessage_InitRequest_MessageGroupId_case case_StreamWriteMessage_InitRequest_Partitioning = 4
const StreamWriteMessage_InitRequest_PartitionId_case case_StreamWriteMessage_InitRequest_Partitioning = 5
const StreamWriteMessage_InitRequest_PartitionWithGeneration_case case_StreamWriteMessage_InitRequest_Partitioning = 7

func (x *StreamWriteMessage_InitRequest) WhichPartitioning() case_StreamWriteMessage_InitRequest_Partitioning {
	if x == nil {
		return StreamWriteMessage_InitRequest_Partitioning_not_set_case
	}
	switch x.Partitioning.(type) {
	case *StreamWriteMessage_InitRequest_MessageGroupId:
		return StreamWriteMessage_InitRequest_MessageGroupId_case
	case *StreamWriteMessage_InitRequest_PartitionId:
		return StreamWriteMessage_InitRequest_PartitionId_case
	case *StreamWriteMessage_InitRequest_PartitionWithGeneration:
		return StreamWriteMessage_InitRequest_PartitionWithGeneration_case
	default:
		return StreamWriteMessage_InitRequest_Partitioning_not_set_case
	}
}

type StreamWriteMessage_InitRequest_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Full path of topic to write to.
	Path *string
	// Producer identifier of client data stream.
	// Used for message deduplication by sequence numbers.
	ProducerId *string
	// User metadata attached to this write session.
	// Reader will get this session meta data with each message read.
	WriteSessionMeta map[string]string
	// Option for setting order on messages.
	// If neither is set, no guarantees on ordering or partitions to write to.

	// Fields of oneof Partitioning:
	// All messages with given pair (producer_id, message_group_id) go to single partition in order of writes.
	MessageGroupId *string
	// Explicit partition id to write to.
	PartitionId *int64
	// Explicit partition location to write to.
	PartitionWithGeneration *PartitionWithGeneration
	// -- end of Partitioning
	// Explicitly request for last sequential number
	// It may be expensive, if producer wrote to many partitions before.
	GetLastSeqNo *bool
}

func (b0 StreamWriteMessage_InitRequest_builder) Build() *StreamWriteMessage_InitRequest {
	m0 := &StreamWriteMessage_InitRequest{}
	b, x := &b0, m0
	_, _ = b, x
	x.Path = b.Path
	x.ProducerId = b.ProducerId
	x.WriteSessionMeta = b.WriteSessionMeta
	if b.MessageGroupId != nil {
		x.Partitioning = &StreamWriteMessage_InitRequest_MessageGroupId{*b.MessageGroupId}
	}
	if b.PartitionId != nil {
		x.Partitioning = &StreamWriteMessage_InitRequest_PartitionId{*b.PartitionId}
	}
	if b.PartitionWithGeneration != nil {
		x.Partitioning = &StreamWriteMessage_InitRequest_PartitionWithGeneration{b.PartitionWithGeneration}
	}
	x.GetLastSeqNo = b.GetLastSeqNo
	return m0
}

type case_StreamWriteMessage_InitRequest_Partitioning protoreflect.FieldNumber

func (x case_StreamWriteMessage_InitRequest_Partitioning) String() string {
	md := file_protos_ydb_topic_proto_msgTypes[48].Descriptor()
	if x == 0 {
		return "not set"
	}
	return protoimpl.X.MessageFieldStringOf(md, protoreflect.FieldNumber(x))
}

type isStreamWriteMessage_InitRequest_Partitioning interface {
	isStreamWriteMessage_InitRequest_Partitioning()
}

type StreamWriteMessage_InitRequest_MessageGroupId struct {
	// All messages with given pair (producer_id, message_group_id) go to single partition in order of writes.
	MessageGroupId string `protobuf:"bytes,4,opt,name=message_group_id,json=messageGroupId,oneof"`
}

type StreamWriteMessage_InitRequest_PartitionId struct {
	// Explicit partition id to write to.
	PartitionId int64 `protobuf:"varint,5,opt,name=partition_id,json=partitionId,oneof"`
}

type StreamWriteMessage_InitRequest_PartitionWithGeneration struct {
	// Explicit partition location to write to.
	PartitionWithGeneration *PartitionWithGeneration `protobuf:"bytes,7,opt,name=partition_with_generation,json=partitionWithGeneration,oneof"`
}

func (*StreamWriteMessage_InitRequest_MessageGroupId) isStreamWriteMessage_InitRequest_Partitioning() {
}

func (*StreamWriteMessage_InitRequest_PartitionId) isStreamWriteMessage_InitRequest_Partitioning() {}

func (*StreamWriteMessage_InitRequest_PartitionWithGeneration) isStreamWriteMessage_InitRequest_Partitioning() {
}

// Response to the handshake.
type StreamWriteMessage_InitResponse struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Last persisted message's sequence number for this producer.
	// Zero for new producer.
	LastSeqNo *int64 `protobuf:"varint,1,opt,name=last_seq_no,json=lastSeqNo" json:"last_seq_no,omitempty"`
	// Unique identifier of write session. Used for debug purposes.
	SessionId *string `protobuf:"bytes,2,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
	// Identifier of partition that is matched for this write session.
	PartitionId *int64 `protobuf:"varint,3,opt,name=partition_id,json=partitionId" json:"partition_id,omitempty"`
	// Client can only use compression codecs from this set to write messages to topic.
	// Otherwise session will be closed with BAD_REQUEST.
	SupportedCodecs *SupportedCodecs `protobuf:"bytes,4,opt,name=supported_codecs,json=supportedCodecs" json:"supported_codecs,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *StreamWriteMessage_InitResponse) Reset() {
	*x = StreamWriteMessage_InitResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[49]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamWriteMessage_InitResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamWriteMessage_InitResponse) ProtoMessage() {}

func (x *StreamWriteMessage_InitResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[49]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamWriteMessage_InitResponse) GetLastSeqNo() int64 {
	if x != nil && x.LastSeqNo != nil {
		return *x.LastSeqNo
	}
	return 0
}

func (x *StreamWriteMessage_InitResponse) GetSessionId() string {
	if x != nil && x.SessionId != nil {
		return *x.SessionId
	}
	return ""
}

func (x *StreamWriteMessage_InitResponse) GetPartitionId() int64 {
	if x != nil && x.PartitionId != nil {
		return *x.PartitionId
	}
	return 0
}

func (x *StreamWriteMessage_InitResponse) GetSupportedCodecs() *SupportedCodecs {
	if x != nil {
		return x.SupportedCodecs
	}
	return nil
}

func (x *StreamWriteMessage_InitResponse) SetLastSeqNo(v int64) {
	x.LastSeqNo = &v
}

func (x *StreamWriteMessage_InitResponse) SetSessionId(v string) {
	x.SessionId = &v
}

func (x *StreamWriteMessage_InitResponse) SetPartitionId(v int64) {
	x.PartitionId = &v
}

func (x *StreamWriteMessage_InitResponse) SetSupportedCodecs(v *SupportedCodecs) {
	x.SupportedCodecs = v
}

func (x *StreamWriteMessage_InitResponse) HasLastSeqNo() bool {
	if x == nil {
		return false
	}
	return x.LastSeqNo != nil
}

func (x *StreamWriteMessage_InitResponse) HasSessionId() bool {
	if x == nil {
		return false
	}
	return x.SessionId != nil
}

func (x *StreamWriteMessage_InitResponse) HasPartitionId() bool {
	if x == nil {
		return false
	}
	return x.PartitionId != nil
}

func (x *StreamWriteMessage_InitResponse) HasSupportedCodecs() bool {
	if x == nil {
		return false
	}
	return x.SupportedCodecs != nil
}

func (x *StreamWriteMessage_InitResponse) ClearLastSeqNo() {
	x.LastSeqNo = nil
}

func (x *StreamWriteMessage_InitResponse) ClearSessionId() {
	x.SessionId = nil
}

func (x *StreamWriteMessage_InitResponse) ClearPartitionId() {
	x.PartitionId = nil
}

func (x *StreamWriteMessage_InitResponse) ClearSupportedCodecs() {
	x.SupportedCodecs = nil
}

type StreamWriteMessage_InitResponse_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Last persisted message's sequence number for this producer.
	// Zero for new producer.
	LastSeqNo *int64
	// Unique identifier of write session. Used for debug purposes.
	SessionId *string
	// Identifier of partition that is matched for this write session.
	PartitionId *int64
	// Client can only use compression codecs from this set to write messages to topic.
	// Otherwise session will be closed with BAD_REQUEST.
	SupportedCodecs *SupportedCodecs
}

func (b0 StreamWriteMessage_InitResponse_builder) Build() *StreamWriteMessage_InitResponse {
	m0 := &StreamWriteMessage_InitResponse{}
	b, x := &b0, m0
	_, _ = b, x
	x.LastSeqNo = b.LastSeqNo
	x.SessionId = b.SessionId
	x.PartitionId = b.PartitionId
	x.SupportedCodecs = b.SupportedCodecs
	return m0
}

// Represents portion of client messages.
type StreamWriteMessage_WriteRequest struct {
	state    protoimpl.MessageState                         `protogen:"hybrid.v1"`
	Messages []*StreamWriteMessage_WriteRequest_MessageData `protobuf:"bytes,1,rep,name=messages" json:"messages,omitempty"`
	// Codec that is used for data compression.
	// See enum Codec above for values.
	Codec         *int32               `protobuf:"varint,2,opt,name=codec" json:"codec,omitempty"`
	Tx            *TransactionIdentity `protobuf:"bytes,3,opt,name=tx" json:"tx,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamWriteMessage_WriteRequest) Reset() {
	*x = StreamWriteMessage_WriteRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[50]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamWriteMessage_WriteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamWriteMessage_WriteRequest) ProtoMessage() {}

func (x *StreamWriteMessage_WriteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[50]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamWriteMessage_WriteRequest) GetMessages() []*StreamWriteMessage_WriteRequest_MessageData {
	if x != nil {
		return x.Messages
	}
	return nil
}

func (x *StreamWriteMessage_WriteRequest) GetCodec() int32 {
	if x != nil && x.Codec != nil {
		return *x.Codec
	}
	return 0
}

func (x *StreamWriteMessage_WriteRequest) GetTx() *TransactionIdentity {
	if x != nil {
		return x.Tx
	}
	return nil
}

func (x *StreamWriteMessage_WriteRequest) SetMessages(v []*StreamWriteMessage_WriteRequest_MessageData) {
	x.Messages = v
}

func (x *StreamWriteMessage_WriteRequest) SetCodec(v int32) {
	x.Codec = &v
}

func (x *StreamWriteMessage_WriteRequest) SetTx(v *TransactionIdentity) {
	x.Tx = v
}

func (x *StreamWriteMessage_WriteRequest) HasCodec() bool {
	if x == nil {
		return false
	}
	return x.Codec != nil
}

func (x *StreamWriteMessage_WriteRequest) HasTx() bool {
	if x == nil {
		return false
	}
	return x.Tx != nil
}

func (x *StreamWriteMessage_WriteRequest) ClearCodec() {
	x.Codec = nil
}

func (x *StreamWriteMessage_WriteRequest) ClearTx() {
	x.Tx = nil
}

type StreamWriteMessage_WriteRequest_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	Messages []*StreamWriteMessage_WriteRequest_MessageData
	// Codec that is used for data compression.
	// See enum Codec above for values.
	Codec *int32
	Tx    *TransactionIdentity
}

func (b0 StreamWriteMessage_WriteRequest_builder) Build() *StreamWriteMessage_WriteRequest {
	m0 := &StreamWriteMessage_WriteRequest{}
	b, x := &b0, m0
	_, _ = b, x
	x.Messages = b.Messages
	x.Codec = b.Codec
	x.Tx = b.Tx
	return m0
}

// Message that represents acknowledgment for sequence of client messages.
// This sequence is persisted together so write statistics is for messages batch.
type StreamWriteMessage_WriteResponse struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Number of acks is equal to number of messages in the corresponding WriteRequests.
	Acks []*StreamWriteMessage_WriteResponse_WriteAck `protobuf:"bytes,1,rep,name=acks" json:"acks,omitempty"`
	// Assigned partition for all client messages inside this batch.
	// This actual partition may differ from that returned in InitResponse
	// or other WriteResponses in this write session.
	PartitionId *int64 `protobuf:"varint,2,opt,name=partition_id,json=partitionId" json:"partition_id,omitempty"`
	// Write statistics for this sequence of client messages.
	WriteStatistics *StreamWriteMessage_WriteResponse_WriteStatistics `protobuf:"bytes,3,opt,name=write_statistics,json=writeStatistics" json:"write_statistics,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *StreamWriteMessage_WriteResponse) Reset() {
	*x = StreamWriteMessage_WriteResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[51]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamWriteMessage_WriteResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamWriteMessage_WriteResponse) ProtoMessage() {}

func (x *StreamWriteMessage_WriteResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[51]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamWriteMessage_WriteResponse) GetAcks() []*StreamWriteMessage_WriteResponse_WriteAck {
	if x != nil {
		return x.Acks
	}
	return nil
}

func (x *StreamWriteMessage_WriteResponse) GetPartitionId() int64 {
	if x != nil && x.PartitionId != nil {
		return *x.PartitionId
	}
	return 0
}

func (x *StreamWriteMessage_WriteResponse) GetWriteStatistics() *StreamWriteMessage_WriteResponse_WriteStatistics {
	if x != nil {
		return x.WriteStatistics
	}
	return nil
}

func (x *StreamWriteMessage_WriteResponse) SetAcks(v []*StreamWriteMessage_WriteResponse_WriteAck) {
	x.Acks = v
}

func (x *StreamWriteMessage_WriteResponse) SetPartitionId(v int64) {
	x.PartitionId = &v
}

func (x *StreamWriteMessage_WriteResponse) SetWriteStatistics(v *StreamWriteMessage_WriteResponse_WriteStatistics) {
	x.WriteStatistics = v
}

func (x *StreamWriteMessage_WriteResponse) HasPartitionId() bool {
	if x == nil {
		return false
	}
	return x.PartitionId != nil
}

func (x *StreamWriteMessage_WriteResponse) HasWriteStatistics() bool {
	if x == nil {
		return false
	}
	return x.WriteStatistics != nil
}

func (x *StreamWriteMessage_WriteResponse) ClearPartitionId() {
	x.PartitionId = nil
}

func (x *StreamWriteMessage_WriteResponse) ClearWriteStatistics() {
	x.WriteStatistics = nil
}

type StreamWriteMessage_WriteResponse_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Number of acks is equal to number of messages in the corresponding WriteRequests.
	Acks []*StreamWriteMessage_WriteResponse_WriteAck
	// Assigned partition for all client messages inside this batch.
	// This actual partition may differ from that returned in InitResponse
	// or other WriteResponses in this write session.
	PartitionId *int64
	// Write statistics for this sequence of client messages.
	WriteStatistics *StreamWriteMessage_WriteResponse_WriteStatistics
}

func (b0 StreamWriteMessage_WriteResponse_builder) Build() *StreamWriteMessage_WriteResponse {
	m0 := &StreamWriteMessage_WriteResponse{}
	b, x := &b0, m0
	_, _ = b, x
	x.Acks = b.Acks
	x.PartitionId = b.PartitionId
	x.WriteStatistics = b.WriteStatistics
	return m0
}

type StreamWriteMessage_WriteRequest_MessageData struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Message sequence number, provided by client for deduplication.
	// Starts at 1
	SeqNo *int64 `protobuf:"varint,1,opt,name=seq_no,json=seqNo" json:"seq_no,omitempty"`
	// Creation timestamp
	CreatedAt *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=created_at,json=createdAt" json:"created_at,omitempty"`
	// Compressed client message body.
	Data []byte `protobuf:"bytes,3,opt,name=data" json:"data,omitempty"`
	// Uncompressed size of client message body.
	UncompressedSize *int64 `protobuf:"varint,4,opt,name=uncompressed_size,json=uncompressedSize" json:"uncompressed_size,omitempty"`
	// Per-message override for respective write session settings.
	//
	// Types that are valid to be assigned to Partitioning:
	//
	//	*StreamWriteMessage_WriteRequest_MessageData_MessageGroupId
	//	*StreamWriteMessage_WriteRequest_MessageData_PartitionId
	//	*StreamWriteMessage_WriteRequest_MessageData_PartitionWithGeneration
	Partitioning isStreamWriteMessage_WriteRequest_MessageData_Partitioning `protobuf_oneof:"partitioning"`
	// Message metadata. Overall size is limited to 4096 symbols (all keys and values combined).
	MetadataItems []*MetadataItem `protobuf:"bytes,7,rep,name=metadata_items,json=metadataItems" json:"metadata_items,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamWriteMessage_WriteRequest_MessageData) Reset() {
	*x = StreamWriteMessage_WriteRequest_MessageData{}
	mi := &file_protos_ydb_topic_proto_msgTypes[53]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamWriteMessage_WriteRequest_MessageData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamWriteMessage_WriteRequest_MessageData) ProtoMessage() {}

func (x *StreamWriteMessage_WriteRequest_MessageData) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[53]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamWriteMessage_WriteRequest_MessageData) GetSeqNo() int64 {
	if x != nil && x.SeqNo != nil {
		return *x.SeqNo
	}
	return 0
}

func (x *StreamWriteMessage_WriteRequest_MessageData) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

func (x *StreamWriteMessage_WriteRequest_MessageData) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *StreamWriteMessage_WriteRequest_MessageData) GetUncompressedSize() int64 {
	if x != nil && x.UncompressedSize != nil {
		return *x.UncompressedSize
	}
	return 0
}

func (x *StreamWriteMessage_WriteRequest_MessageData) GetPartitioning() isStreamWriteMessage_WriteRequest_MessageData_Partitioning {
	if x != nil {
		return x.Partitioning
	}
	return nil
}

func (x *StreamWriteMessage_WriteRequest_MessageData) GetMessageGroupId() string {
	if x != nil {
		if x, ok := x.Partitioning.(*StreamWriteMessage_WriteRequest_MessageData_MessageGroupId); ok {
			return x.MessageGroupId
		}
	}
	return ""
}

func (x *StreamWriteMessage_WriteRequest_MessageData) GetPartitionId() int64 {
	if x != nil {
		if x, ok := x.Partitioning.(*StreamWriteMessage_WriteRequest_MessageData_PartitionId); ok {
			return x.PartitionId
		}
	}
	return 0
}

func (x *StreamWriteMessage_WriteRequest_MessageData) GetPartitionWithGeneration() *PartitionWithGeneration {
	if x != nil {
		if x, ok := x.Partitioning.(*StreamWriteMessage_WriteRequest_MessageData_PartitionWithGeneration); ok {
			return x.PartitionWithGeneration
		}
	}
	return nil
}

func (x *StreamWriteMessage_WriteRequest_MessageData) GetMetadataItems() []*MetadataItem {
	if x != nil {
		return x.MetadataItems
	}
	return nil
}

func (x *StreamWriteMessage_WriteRequest_MessageData) SetSeqNo(v int64) {
	x.SeqNo = &v
}

func (x *StreamWriteMessage_WriteRequest_MessageData) SetCreatedAt(v *timestamppb.Timestamp) {
	x.CreatedAt = v
}

func (x *StreamWriteMessage_WriteRequest_MessageData) SetData(v []byte) {
	if v == nil {
		v = []byte{}
	}
	x.Data = v
}

func (x *StreamWriteMessage_WriteRequest_MessageData) SetUncompressedSize(v int64) {
	x.UncompressedSize = &v
}

func (x *StreamWriteMessage_WriteRequest_MessageData) SetMessageGroupId(v string) {
	x.Partitioning = &StreamWriteMessage_WriteRequest_MessageData_MessageGroupId{v}
}

func (x *StreamWriteMessage_WriteRequest_MessageData) SetPartitionId(v int64) {
	x.Partitioning = &StreamWriteMessage_WriteRequest_MessageData_PartitionId{v}
}

func (x *StreamWriteMessage_WriteRequest_MessageData) SetPartitionWithGeneration(v *PartitionWithGeneration) {
	if v == nil {
		x.Partitioning = nil
		return
	}
	x.Partitioning = &StreamWriteMessage_WriteRequest_MessageData_PartitionWithGeneration{v}
}

func (x *StreamWriteMessage_WriteRequest_MessageData) SetMetadataItems(v []*MetadataItem) {
	x.MetadataItems = v
}

func (x *StreamWriteMessage_WriteRequest_MessageData) HasSeqNo() bool {
	if x == nil {
		return false
	}
	return x.SeqNo != nil
}

func (x *StreamWriteMessage_WriteRequest_MessageData) HasCreatedAt() bool {
	if x == nil {
		return false
	}
	return x.CreatedAt != nil
}

func (x *StreamWriteMessage_WriteRequest_MessageData) HasData() bool {
	if x == nil {
		return false
	}
	return x.Data != nil
}

func (x *StreamWriteMessage_WriteRequest_MessageData) HasUncompressedSize() bool {
	if x == nil {
		return false
	}
	return x.UncompressedSize != nil
}

func (x *StreamWriteMessage_WriteRequest_MessageData) HasPartitioning() bool {
	if x == nil {
		return false
	}
	return x.Partitioning != nil
}

func (x *StreamWriteMessage_WriteRequest_MessageData) HasMessageGroupId() bool {
	if x == nil {
		return false
	}
	_, ok := x.Partitioning.(*StreamWriteMessage_WriteRequest_MessageData_MessageGroupId)
	return ok
}

func (x *StreamWriteMessage_WriteRequest_MessageData) HasPartitionId() bool {
	if x == nil {
		return false
	}
	_, ok := x.Partitioning.(*StreamWriteMessage_WriteRequest_MessageData_PartitionId)
	return ok
}

func (x *StreamWriteMessage_WriteRequest_MessageData) HasPartitionWithGeneration() bool {
	if x == nil {
		return false
	}
	_, ok := x.Partitioning.(*StreamWriteMessage_WriteRequest_MessageData_PartitionWithGeneration)
	return ok
}

func (x *StreamWriteMessage_WriteRequest_MessageData) ClearSeqNo() {
	x.SeqNo = nil
}

func (x *StreamWriteMessage_WriteRequest_MessageData) ClearCreatedAt() {
	x.CreatedAt = nil
}

func (x *StreamWriteMessage_WriteRequest_MessageData) ClearData() {
	x.Data = nil
}

func (x *StreamWriteMessage_WriteRequest_MessageData) ClearUncompressedSize() {
	x.UncompressedSize = nil
}

func (x *StreamWriteMessage_WriteRequest_MessageData) ClearPartitioning() {
	x.Partitioning = nil
}

func (x *StreamWriteMessage_WriteRequest_MessageData) ClearMessageGroupId() {
	if _, ok := x.Partitioning.(*StreamWriteMessage_WriteRequest_MessageData_MessageGroupId); ok {
		x.Partitioning = nil
	}
}

func (x *StreamWriteMessage_WriteRequest_MessageData) ClearPartitionId() {
	if _, ok := x.Partitioning.(*StreamWriteMessage_WriteRequest_MessageData_PartitionId); ok {
		x.Partitioning = nil
	}
}

func (x *StreamWriteMessage_WriteRequest_MessageData) ClearPartitionWithGeneration() {
	if _, ok := x.Partitioning.(*StreamWriteMessage_WriteRequest_MessageData_PartitionWithGeneration); ok {
		x.Partitioning = nil
	}
}

const StreamWriteMessage_WriteRequest_MessageData_Partitioning_not_set_case case_StreamWriteMessage_WriteRequest_MessageData_Partitioning = 0
const StreamWriteMessage_WriteRequest_MessageData_MessageGroupId_case case_StreamWriteMessage_WriteRequest_MessageData_Partitioning = 5
const StreamWriteMessage_WriteRequest_MessageData_PartitionId_case case_StreamWriteMessage_WriteRequest_MessageData_Partitioning = 6
const StreamWriteMessage_WriteRequest_MessageData_PartitionWithGeneration_case case_StreamWriteMessage_WriteRequest_MessageData_Partitioning = 8

func (x *StreamWriteMessage_WriteRequest_MessageData) WhichPartitioning() case_StreamWriteMessage_WriteRequest_MessageData_Partitioning {
	if x == nil {
		return StreamWriteMessage_WriteRequest_MessageData_Partitioning_not_set_case
	}
	switch x.Partitioning.(type) {
	case *StreamWriteMessage_WriteRequest_MessageData_MessageGroupId:
		return StreamWriteMessage_WriteRequest_MessageData_MessageGroupId_case
	case *StreamWriteMessage_WriteRequest_MessageData_PartitionId:
		return StreamWriteMessage_WriteRequest_MessageData_PartitionId_case
	case *StreamWriteMessage_WriteRequest_MessageData_PartitionWithGeneration:
		return StreamWriteMessage_WriteRequest_MessageData_PartitionWithGeneration_case
	default:
		return StreamWriteMessage_WriteRequest_MessageData_Partitioning_not_set_case
	}
}

type StreamWriteMessage_WriteRequest_MessageData_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Message sequence number, provided by client for deduplication.
	// Starts at 1
	SeqNo *int64
	// Creation timestamp
	CreatedAt *timestamppb.Timestamp
	// Compressed client message body.
	Data []byte
	// Uncompressed size of client message body.
	UncompressedSize *int64
	// Per-message override for respective write session settings.

	// Fields of oneof Partitioning:
	// All messages with given pair (producer_id, message_group_id) go to single partition in order of writes.
	MessageGroupId *string
	// Explicit partition id to write to.
	PartitionId *int64
	// Explicit partition location to write to.
	PartitionWithGeneration *PartitionWithGeneration
	// -- end of Partitioning
	// Message metadata. Overall size is limited to 4096 symbols (all keys and values combined).
	MetadataItems []*MetadataItem
}

func (b0 StreamWriteMessage_WriteRequest_MessageData_builder) Build() *StreamWriteMessage_WriteRequest_MessageData {
	m0 := &StreamWriteMessage_WriteRequest_MessageData{}
	b, x := &b0, m0
	_, _ = b, x
	x.SeqNo = b.SeqNo
	x.CreatedAt = b.CreatedAt
	x.Data = b.Data
	x.UncompressedSize = b.UncompressedSize
	if b.MessageGroupId != nil {
		x.Partitioning = &StreamWriteMessage_WriteRequest_MessageData_MessageGroupId{*b.MessageGroupId}
	}
	if b.PartitionId != nil {
		x.Partitioning = &StreamWriteMessage_WriteRequest_MessageData_PartitionId{*b.PartitionId}
	}
	if b.PartitionWithGeneration != nil {
		x.Partitioning = &StreamWriteMessage_WriteRequest_MessageData_PartitionWithGeneration{b.PartitionWithGeneration}
	}
	x.MetadataItems = b.MetadataItems
	return m0
}

type case_StreamWriteMessage_WriteRequest_MessageData_Partitioning protoreflect.FieldNumber

func (x case_StreamWriteMessage_WriteRequest_MessageData_Partitioning) String() string {
	md := file_protos_ydb_topic_proto_msgTypes[53].Descriptor()
	if x == 0 {
		return "not set"
	}
	return protoimpl.X.MessageFieldStringOf(md, protoreflect.FieldNumber(x))
}

type isStreamWriteMessage_WriteRequest_MessageData_Partitioning interface {
	isStreamWriteMessage_WriteRequest_MessageData_Partitioning()
}

type StreamWriteMessage_WriteRequest_MessageData_MessageGroupId struct {
	// All messages with given pair (producer_id, message_group_id) go to single partition in order of writes.
	MessageGroupId string `protobuf:"bytes,5,opt,name=message_group_id,json=messageGroupId,oneof"`
}

type StreamWriteMessage_WriteRequest_MessageData_PartitionId struct {
	// Explicit partition id to write to.
	PartitionId int64 `protobuf:"varint,6,opt,name=partition_id,json=partitionId,oneof"`
}

type StreamWriteMessage_WriteRequest_MessageData_PartitionWithGeneration struct {
	// Explicit partition location to write to.
	PartitionWithGeneration *PartitionWithGeneration `protobuf:"bytes,8,opt,name=partition_with_generation,json=partitionWithGeneration,oneof"`
}

func (*StreamWriteMessage_WriteRequest_MessageData_MessageGroupId) isStreamWriteMessage_WriteRequest_MessageData_Partitioning() {
}

func (*StreamWriteMessage_WriteRequest_MessageData_PartitionId) isStreamWriteMessage_WriteRequest_MessageData_Partitioning() {
}

func (*StreamWriteMessage_WriteRequest_MessageData_PartitionWithGeneration) isStreamWriteMessage_WriteRequest_MessageData_Partitioning() {
}

// Acknowledgment for one persistently written message.
type StreamWriteMessage_WriteResponse_WriteAck struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Sequence number as in WriteRequest.
	SeqNo *int64 `protobuf:"varint,1,opt,name=seq_no,json=seqNo" json:"seq_no,omitempty"`
	// Either message is written for the first time or duplicate.
	//
	// Types that are valid to be assigned to MessageWriteStatus:
	//
	//	*StreamWriteMessage_WriteResponse_WriteAck_Written_
	//	*StreamWriteMessage_WriteResponse_WriteAck_Skipped_
	//	*StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx_
	MessageWriteStatus isStreamWriteMessage_WriteResponse_WriteAck_MessageWriteStatus `protobuf_oneof:"message_write_status"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *StreamWriteMessage_WriteResponse_WriteAck) Reset() {
	*x = StreamWriteMessage_WriteResponse_WriteAck{}
	mi := &file_protos_ydb_topic_proto_msgTypes[54]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamWriteMessage_WriteResponse_WriteAck) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamWriteMessage_WriteResponse_WriteAck) ProtoMessage() {}

func (x *StreamWriteMessage_WriteResponse_WriteAck) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[54]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamWriteMessage_WriteResponse_WriteAck) GetSeqNo() int64 {
	if x != nil && x.SeqNo != nil {
		return *x.SeqNo
	}
	return 0
}

func (x *StreamWriteMessage_WriteResponse_WriteAck) GetMessageWriteStatus() isStreamWriteMessage_WriteResponse_WriteAck_MessageWriteStatus {
	if x != nil {
		return x.MessageWriteStatus
	}
	return nil
}

func (x *StreamWriteMessage_WriteResponse_WriteAck) GetWritten() *StreamWriteMessage_WriteResponse_WriteAck_Written {
	if x != nil {
		if x, ok := x.MessageWriteStatus.(*StreamWriteMessage_WriteResponse_WriteAck_Written_); ok {
			return x.Written
		}
	}
	return nil
}

func (x *StreamWriteMessage_WriteResponse_WriteAck) GetSkipped() *StreamWriteMessage_WriteResponse_WriteAck_Skipped {
	if x != nil {
		if x, ok := x.MessageWriteStatus.(*StreamWriteMessage_WriteResponse_WriteAck_Skipped_); ok {
			return x.Skipped
		}
	}
	return nil
}

func (x *StreamWriteMessage_WriteResponse_WriteAck) GetWrittenInTx() *StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx {
	if x != nil {
		if x, ok := x.MessageWriteStatus.(*StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx_); ok {
			return x.WrittenInTx
		}
	}
	return nil
}

func (x *StreamWriteMessage_WriteResponse_WriteAck) SetSeqNo(v int64) {
	x.SeqNo = &v
}

func (x *StreamWriteMessage_WriteResponse_WriteAck) SetWritten(v *StreamWriteMessage_WriteResponse_WriteAck_Written) {
	if v == nil {
		x.MessageWriteStatus = nil
		return
	}
	x.MessageWriteStatus = &StreamWriteMessage_WriteResponse_WriteAck_Written_{v}
}

func (x *StreamWriteMessage_WriteResponse_WriteAck) SetSkipped(v *StreamWriteMessage_WriteResponse_WriteAck_Skipped) {
	if v == nil {
		x.MessageWriteStatus = nil
		return
	}
	x.MessageWriteStatus = &StreamWriteMessage_WriteResponse_WriteAck_Skipped_{v}
}

func (x *StreamWriteMessage_WriteResponse_WriteAck) SetWrittenInTx(v *StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx) {
	if v == nil {
		x.MessageWriteStatus = nil
		return
	}
	x.MessageWriteStatus = &StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx_{v}
}

func (x *StreamWriteMessage_WriteResponse_WriteAck) HasSeqNo() bool {
	if x == nil {
		return false
	}
	return x.SeqNo != nil
}

func (x *StreamWriteMessage_WriteResponse_WriteAck) HasMessageWriteStatus() bool {
	if x == nil {
		return false
	}
	return x.MessageWriteStatus != nil
}

func (x *StreamWriteMessage_WriteResponse_WriteAck) HasWritten() bool {
	if x == nil {
		return false
	}
	_, ok := x.MessageWriteStatus.(*StreamWriteMessage_WriteResponse_WriteAck_Written_)
	return ok
}

func (x *StreamWriteMessage_WriteResponse_WriteAck) HasSkipped() bool {
	if x == nil {
		return false
	}
	_, ok := x.MessageWriteStatus.(*StreamWriteMessage_WriteResponse_WriteAck_Skipped_)
	return ok
}

func (x *StreamWriteMessage_WriteResponse_WriteAck) HasWrittenInTx() bool {
	if x == nil {
		return false
	}
	_, ok := x.MessageWriteStatus.(*StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx_)
	return ok
}

func (x *StreamWriteMessage_WriteResponse_WriteAck) ClearSeqNo() {
	x.SeqNo = nil
}

func (x *StreamWriteMessage_WriteResponse_WriteAck) ClearMessageWriteStatus() {
	x.MessageWriteStatus = nil
}

func (x *StreamWriteMessage_WriteResponse_WriteAck) ClearWritten() {
	if _, ok := x.MessageWriteStatus.(*StreamWriteMessage_WriteResponse_WriteAck_Written_); ok {
		x.MessageWriteStatus = nil
	}
}

func (x *StreamWriteMessage_WriteResponse_WriteAck) ClearSkipped() {
	if _, ok := x.MessageWriteStatus.(*StreamWriteMessage_WriteResponse_WriteAck_Skipped_); ok {
		x.MessageWriteStatus = nil
	}
}

func (x *StreamWriteMessage_WriteResponse_WriteAck) ClearWrittenInTx() {
	if _, ok := x.MessageWriteStatus.(*StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx_); ok {
		x.MessageWriteStatus = nil
	}
}

const StreamWriteMessage_WriteResponse_WriteAck_MessageWriteStatus_not_set_case case_StreamWriteMessage_WriteResponse_WriteAck_MessageWriteStatus = 0
const StreamWriteMessage_WriteResponse_WriteAck_Written_case case_StreamWriteMessage_WriteResponse_WriteAck_MessageWriteStatus = 2
const StreamWriteMessage_WriteResponse_WriteAck_Skipped_case case_StreamWriteMessage_WriteResponse_WriteAck_MessageWriteStatus = 3
const StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx_case case_StreamWriteMessage_WriteResponse_WriteAck_MessageWriteStatus = 4

func (x *StreamWriteMessage_WriteResponse_WriteAck) WhichMessageWriteStatus() case_StreamWriteMessage_WriteResponse_WriteAck_MessageWriteStatus {
	if x == nil {
		return StreamWriteMessage_WriteResponse_WriteAck_MessageWriteStatus_not_set_case
	}
	switch x.MessageWriteStatus.(type) {
	case *StreamWriteMessage_WriteResponse_WriteAck_Written_:
		return StreamWriteMessage_WriteResponse_WriteAck_Written_case
	case *StreamWriteMessage_WriteResponse_WriteAck_Skipped_:
		return StreamWriteMessage_WriteResponse_WriteAck_Skipped_case
	case *StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx_:
		return StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx_case
	default:
		return StreamWriteMessage_WriteResponse_WriteAck_MessageWriteStatus_not_set_case
	}
}

type StreamWriteMessage_WriteResponse_WriteAck_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Sequence number as in WriteRequest.
	SeqNo *int64
	// Either message is written for the first time or duplicate.

	// Fields of oneof MessageWriteStatus:
	Written     *StreamWriteMessage_WriteResponse_WriteAck_Written
	Skipped     *StreamWriteMessage_WriteResponse_WriteAck_Skipped
	WrittenInTx *StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx
	// -- end of MessageWriteStatus
}

func (b0 StreamWriteMessage_WriteResponse_WriteAck_builder) Build() *StreamWriteMessage_WriteResponse_WriteAck {
	m0 := &StreamWriteMessage_WriteResponse_WriteAck{}
	b, x := &b0, m0
	_, _ = b, x
	x.SeqNo = b.SeqNo
	if b.Written != nil {
		x.MessageWriteStatus = &StreamWriteMessage_WriteResponse_WriteAck_Written_{b.Written}
	}
	if b.Skipped != nil {
		x.MessageWriteStatus = &StreamWriteMessage_WriteResponse_WriteAck_Skipped_{b.Skipped}
	}
	if b.WrittenInTx != nil {
		x.MessageWriteStatus = &StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx_{b.WrittenInTx}
	}
	return m0
}

type case_StreamWriteMessage_WriteResponse_WriteAck_MessageWriteStatus protoreflect.FieldNumber

func (x case_StreamWriteMessage_WriteResponse_WriteAck_MessageWriteStatus) String() string {
	md := file_protos_ydb_topic_proto_msgTypes[54].Descriptor()
	if x == 0 {
		return "not set"
	}
	return protoimpl.X.MessageFieldStringOf(md, protoreflect.FieldNumber(x))
}

type isStreamWriteMessage_WriteResponse_WriteAck_MessageWriteStatus interface {
	isStreamWriteMessage_WriteResponse_WriteAck_MessageWriteStatus()
}

type StreamWriteMessage_WriteResponse_WriteAck_Written_ struct {
	Written *StreamWriteMessage_WriteResponse_WriteAck_Written `protobuf:"bytes,2,opt,name=written,oneof"`
}

type StreamWriteMessage_WriteResponse_WriteAck_Skipped_ struct {
	Skipped *StreamWriteMessage_WriteResponse_WriteAck_Skipped `protobuf:"bytes,3,opt,name=skipped,oneof"`
}

type StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx_ struct {
	WrittenInTx *StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx `protobuf:"bytes,4,opt,name=written_in_tx,json=writtenInTx,oneof"`
}

func (*StreamWriteMessage_WriteResponse_WriteAck_Written_) isStreamWriteMessage_WriteResponse_WriteAck_MessageWriteStatus() {
}

func (*StreamWriteMessage_WriteResponse_WriteAck_Skipped_) isStreamWriteMessage_WriteResponse_WriteAck_MessageWriteStatus() {
}

func (*StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx_) isStreamWriteMessage_WriteResponse_WriteAck_MessageWriteStatus() {
}

// Message with write statistics.
type StreamWriteMessage_WriteResponse_WriteStatistics struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Time spent in persisting of data. Same for each message in response.
	PersistingTime *durationpb.Duration `protobuf:"bytes,1,opt,name=persisting_time,json=persistingTime" json:"persisting_time,omitempty"`
	// Time spent in queue before persisting, minimal of all messages in response.
	MinQueueWaitTime *durationpb.Duration `protobuf:"bytes,2,opt,name=min_queue_wait_time,json=minQueueWaitTime" json:"min_queue_wait_time,omitempty"`
	// Time spent in queue before persisting, maximal of all messages in response.
	MaxQueueWaitTime *durationpb.Duration `protobuf:"bytes,3,opt,name=max_queue_wait_time,json=maxQueueWaitTime" json:"max_queue_wait_time,omitempty"`
	// Time spent awaiting for partition write quota. Same for each message in response.
	PartitionQuotaWaitTime *durationpb.Duration `protobuf:"bytes,4,opt,name=partition_quota_wait_time,json=partitionQuotaWaitTime" json:"partition_quota_wait_time,omitempty"`
	// Time spent awaiting for topic write quota. Same for each message in response.
	TopicQuotaWaitTime *durationpb.Duration `protobuf:"bytes,5,opt,name=topic_quota_wait_time,json=topicQuotaWaitTime" json:"topic_quota_wait_time,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *StreamWriteMessage_WriteResponse_WriteStatistics) Reset() {
	*x = StreamWriteMessage_WriteResponse_WriteStatistics{}
	mi := &file_protos_ydb_topic_proto_msgTypes[55]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamWriteMessage_WriteResponse_WriteStatistics) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamWriteMessage_WriteResponse_WriteStatistics) ProtoMessage() {}

func (x *StreamWriteMessage_WriteResponse_WriteStatistics) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[55]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamWriteMessage_WriteResponse_WriteStatistics) GetPersistingTime() *durationpb.Duration {
	if x != nil {
		return x.PersistingTime
	}
	return nil
}

func (x *StreamWriteMessage_WriteResponse_WriteStatistics) GetMinQueueWaitTime() *durationpb.Duration {
	if x != nil {
		return x.MinQueueWaitTime
	}
	return nil
}

func (x *StreamWriteMessage_WriteResponse_WriteStatistics) GetMaxQueueWaitTime() *durationpb.Duration {
	if x != nil {
		return x.MaxQueueWaitTime
	}
	return nil
}

func (x *StreamWriteMessage_WriteResponse_WriteStatistics) GetPartitionQuotaWaitTime() *durationpb.Duration {
	if x != nil {
		return x.PartitionQuotaWaitTime
	}
	return nil
}

func (x *StreamWriteMessage_WriteResponse_WriteStatistics) GetTopicQuotaWaitTime() *durationpb.Duration {
	if x != nil {
		return x.TopicQuotaWaitTime
	}
	return nil
}

func (x *StreamWriteMessage_WriteResponse_WriteStatistics) SetPersistingTime(v *durationpb.Duration) {
	x.PersistingTime = v
}

func (x *StreamWriteMessage_WriteResponse_WriteStatistics) SetMinQueueWaitTime(v *durationpb.Duration) {
	x.MinQueueWaitTime = v
}

func (x *StreamWriteMessage_WriteResponse_WriteStatistics) SetMaxQueueWaitTime(v *durationpb.Duration) {
	x.MaxQueueWaitTime = v
}

func (x *StreamWriteMessage_WriteResponse_WriteStatistics) SetPartitionQuotaWaitTime(v *durationpb.Duration) {
	x.PartitionQuotaWaitTime = v
}

func (x *StreamWriteMessage_WriteResponse_WriteStatistics) SetTopicQuotaWaitTime(v *durationpb.Duration) {
	x.TopicQuotaWaitTime = v
}

func (x *StreamWriteMessage_WriteResponse_WriteStatistics) HasPersistingTime() bool {
	if x == nil {
		return false
	}
	return x.PersistingTime != nil
}

func (x *StreamWriteMessage_WriteResponse_WriteStatistics) HasMinQueueWaitTime() bool {
	if x == nil {
		return false
	}
	return x.MinQueueWaitTime != nil
}

func (x *StreamWriteMessage_WriteResponse_WriteStatistics) HasMaxQueueWaitTime() bool {
	if x == nil {
		return false
	}
	return x.MaxQueueWaitTime != nil
}

func (x *StreamWriteMessage_WriteResponse_WriteStatistics) HasPartitionQuotaWaitTime() bool {
	if x == nil {
		return false
	}
	return x.PartitionQuotaWaitTime != nil
}

func (x *StreamWriteMessage_WriteResponse_WriteStatistics) HasTopicQuotaWaitTime() bool {
	if x == nil {
		return false
	}
	return x.TopicQuotaWaitTime != nil
}

func (x *StreamWriteMessage_WriteResponse_WriteStatistics) ClearPersistingTime() {
	x.PersistingTime = nil
}

func (x *StreamWriteMessage_WriteResponse_WriteStatistics) ClearMinQueueWaitTime() {
	x.MinQueueWaitTime = nil
}

func (x *StreamWriteMessage_WriteResponse_WriteStatistics) ClearMaxQueueWaitTime() {
	x.MaxQueueWaitTime = nil
}

func (x *StreamWriteMessage_WriteResponse_WriteStatistics) ClearPartitionQuotaWaitTime() {
	x.PartitionQuotaWaitTime = nil
}

func (x *StreamWriteMessage_WriteResponse_WriteStatistics) ClearTopicQuotaWaitTime() {
	x.TopicQuotaWaitTime = nil
}

type StreamWriteMessage_WriteResponse_WriteStatistics_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Time spent in persisting of data. Same for each message in response.
	PersistingTime *durationpb.Duration
	// Time spent in queue before persisting, minimal of all messages in response.
	MinQueueWaitTime *durationpb.Duration
	// Time spent in queue before persisting, maximal of all messages in response.
	MaxQueueWaitTime *durationpb.Duration
	// Time spent awaiting for partition write quota. Same for each message in response.
	PartitionQuotaWaitTime *durationpb.Duration
	// Time spent awaiting for topic write quota. Same for each message in response.
	TopicQuotaWaitTime *durationpb.Duration
}

func (b0 StreamWriteMessage_WriteResponse_WriteStatistics_builder) Build() *StreamWriteMessage_WriteResponse_WriteStatistics {
	m0 := &StreamWriteMessage_WriteResponse_WriteStatistics{}
	b, x := &b0, m0
	_, _ = b, x
	x.PersistingTime = b.PersistingTime
	x.MinQueueWaitTime = b.MinQueueWaitTime
	x.MaxQueueWaitTime = b.MaxQueueWaitTime
	x.PartitionQuotaWaitTime = b.PartitionQuotaWaitTime
	x.TopicQuotaWaitTime = b.TopicQuotaWaitTime
	return m0
}

type StreamWriteMessage_WriteResponse_WriteAck_Written struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Assigned partition offset.
	Offset        *int64 `protobuf:"varint,1,opt,name=offset" json:"offset,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamWriteMessage_WriteResponse_WriteAck_Written) Reset() {
	*x = StreamWriteMessage_WriteResponse_WriteAck_Written{}
	mi := &file_protos_ydb_topic_proto_msgTypes[56]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamWriteMessage_WriteResponse_WriteAck_Written) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamWriteMessage_WriteResponse_WriteAck_Written) ProtoMessage() {}

func (x *StreamWriteMessage_WriteResponse_WriteAck_Written) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[56]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamWriteMessage_WriteResponse_WriteAck_Written) GetOffset() int64 {
	if x != nil && x.Offset != nil {
		return *x.Offset
	}
	return 0
}

func (x *StreamWriteMessage_WriteResponse_WriteAck_Written) SetOffset(v int64) {
	x.Offset = &v
}

func (x *StreamWriteMessage_WriteResponse_WriteAck_Written) HasOffset() bool {
	if x == nil {
		return false
	}
	return x.Offset != nil
}

func (x *StreamWriteMessage_WriteResponse_WriteAck_Written) ClearOffset() {
	x.Offset = nil
}

type StreamWriteMessage_WriteResponse_WriteAck_Written_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Assigned partition offset.
	Offset *int64
}

func (b0 StreamWriteMessage_WriteResponse_WriteAck_Written_builder) Build() *StreamWriteMessage_WriteResponse_WriteAck_Written {
	m0 := &StreamWriteMessage_WriteResponse_WriteAck_Written{}
	b, x := &b0, m0
	_, _ = b, x
	x.Offset = b.Offset
	return m0
}

type StreamWriteMessage_WriteResponse_WriteAck_Skipped struct {
	state         protoimpl.MessageState                                    `protogen:"hybrid.v1"`
	Reason        *StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason `protobuf:"varint,1,opt,name=reason,enum=Ydb.Topic.StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason" json:"reason,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamWriteMessage_WriteResponse_WriteAck_Skipped) Reset() {
	*x = StreamWriteMessage_WriteResponse_WriteAck_Skipped{}
	mi := &file_protos_ydb_topic_proto_msgTypes[57]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamWriteMessage_WriteResponse_WriteAck_Skipped) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamWriteMessage_WriteResponse_WriteAck_Skipped) ProtoMessage() {}

func (x *StreamWriteMessage_WriteResponse_WriteAck_Skipped) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[57]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamWriteMessage_WriteResponse_WriteAck_Skipped) GetReason() StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason {
	if x != nil && x.Reason != nil {
		return *x.Reason
	}
	return StreamWriteMessage_WriteResponse_WriteAck_Skipped_REASON_UNSPECIFIED
}

func (x *StreamWriteMessage_WriteResponse_WriteAck_Skipped) SetReason(v StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason) {
	x.Reason = &v
}

func (x *StreamWriteMessage_WriteResponse_WriteAck_Skipped) HasReason() bool {
	if x == nil {
		return false
	}
	return x.Reason != nil
}

func (x *StreamWriteMessage_WriteResponse_WriteAck_Skipped) ClearReason() {
	x.Reason = nil
}

type StreamWriteMessage_WriteResponse_WriteAck_Skipped_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	Reason *StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason
}

func (b0 StreamWriteMessage_WriteResponse_WriteAck_Skipped_builder) Build() *StreamWriteMessage_WriteResponse_WriteAck_Skipped {
	m0 := &StreamWriteMessage_WriteResponse_WriteAck_Skipped{}
	b, x := &b0, m0
	_, _ = b, x
	x.Reason = b.Reason
	return m0
}

type StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx struct {
	state         protoimpl.MessageState `protogen:"hybrid.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx) Reset() {
	*x = StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx{}
	mi := &file_protos_ydb_topic_proto_msgTypes[58]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx) ProtoMessage() {}

func (x *StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[58]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

type StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

}

func (b0 StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx_builder) Build() *StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx {
	m0 := &StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx{}
	b, x := &b0, m0
	_, _ = b, x
	return m0
}

// Within a StreamRead session delivered messages are separated by partition.
// Reads from a single partition are represented by a partition session.
type StreamReadMessage_PartitionSession struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Identifier of partition session. Unique inside one RPC call.
	PartitionSessionId *int64 `protobuf:"varint,1,opt,name=partition_session_id,json=partitionSessionId" json:"partition_session_id,omitempty"`
	// Topic path of partition.
	Path *string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	// Partition identifier.
	PartitionId   *int64 `protobuf:"varint,3,opt,name=partition_id,json=partitionId" json:"partition_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamReadMessage_PartitionSession) Reset() {
	*x = StreamReadMessage_PartitionSession{}
	mi := &file_protos_ydb_topic_proto_msgTypes[59]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_PartitionSession) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_PartitionSession) ProtoMessage() {}

func (x *StreamReadMessage_PartitionSession) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[59]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamReadMessage_PartitionSession) GetPartitionSessionId() int64 {
	if x != nil && x.PartitionSessionId != nil {
		return *x.PartitionSessionId
	}
	return 0
}

func (x *StreamReadMessage_PartitionSession) GetPath() string {
	if x != nil && x.Path != nil {
		return *x.Path
	}
	return ""
}

func (x *StreamReadMessage_PartitionSession) GetPartitionId() int64 {
	if x != nil && x.PartitionId != nil {
		return *x.PartitionId
	}
	return 0
}

func (x *StreamReadMessage_PartitionSession) SetPartitionSessionId(v int64) {
	x.PartitionSessionId = &v
}

func (x *StreamReadMessage_PartitionSession) SetPath(v string) {
	x.Path = &v
}

func (x *StreamReadMessage_PartitionSession) SetPartitionId(v int64) {
	x.PartitionId = &v
}

func (x *StreamReadMessage_PartitionSession) HasPartitionSessionId() bool {
	if x == nil {
		return false
	}
	return x.PartitionSessionId != nil
}

func (x *StreamReadMessage_PartitionSession) HasPath() bool {
	if x == nil {
		return false
	}
	return x.Path != nil
}

func (x *StreamReadMessage_PartitionSession) HasPartitionId() bool {
	if x == nil {
		return false
	}
	return x.PartitionId != nil
}

func (x *StreamReadMessage_PartitionSession) ClearPartitionSessionId() {
	x.PartitionSessionId = nil
}

func (x *StreamReadMessage_PartitionSession) ClearPath() {
	x.Path = nil
}

func (x *StreamReadMessage_PartitionSession) ClearPartitionId() {
	x.PartitionId = nil
}

type StreamReadMessage_PartitionSession_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Identifier of partition session. Unique inside one RPC call.
	PartitionSessionId *int64
	// Topic path of partition.
	Path *string
	// Partition identifier.
	PartitionId *int64
}

func (b0 StreamReadMessage_PartitionSession_builder) Build() *StreamReadMessage_PartitionSession {
	m0 := &StreamReadMessage_PartitionSession{}
	b, x := &b0, m0
	_, _ = b, x
	x.PartitionSessionId = b.PartitionSessionId
	x.Path = b.Path
	x.PartitionId = b.PartitionId
	return m0
}

// Client-server message for read session. Contains one of:
//
//	InitRequest - handshake request.
//	ReadRequest - request for data.
//	CommitOffsetRequest - request for commit of some read data.
//	PartitionSessionStatusRequest - request for session status
//	UpdateTokenRequest - request to update auth token
//	DirectReadAck - client signals it has finished direct reading from the partition node.
//
//	StartPartitionSessionResponse - Response to StreamReadServerMessage.StartPartitionSessionRequest.
//	    Client signals it is ready to get data from partition.
//	StopPartitionSessionResponse - Response to StreamReadServerMessage.StopPartitionSessionRequest.
//	    Client signals it has finished working with partition. Mandatory for graceful stop, optional otherwise.
type StreamReadMessage_FromClient struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Types that are valid to be assigned to ClientMessage:
	//
	//	*StreamReadMessage_FromClient_InitRequest
	//	*StreamReadMessage_FromClient_ReadRequest
	//	*StreamReadMessage_FromClient_CommitOffsetRequest
	//	*StreamReadMessage_FromClient_PartitionSessionStatusRequest
	//	*StreamReadMessage_FromClient_UpdateTokenRequest
	//	*StreamReadMessage_FromClient_DirectReadAck
	//	*StreamReadMessage_FromClient_StartPartitionSessionResponse
	//	*StreamReadMessage_FromClient_StopPartitionSessionResponse
	ClientMessage isStreamReadMessage_FromClient_ClientMessage `protobuf_oneof:"client_message"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamReadMessage_FromClient) Reset() {
	*x = StreamReadMessage_FromClient{}
	mi := &file_protos_ydb_topic_proto_msgTypes[60]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_FromClient) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_FromClient) ProtoMessage() {}

func (x *StreamReadMessage_FromClient) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[60]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamReadMessage_FromClient) GetClientMessage() isStreamReadMessage_FromClient_ClientMessage {
	if x != nil {
		return x.ClientMessage
	}
	return nil
}

func (x *StreamReadMessage_FromClient) GetInitRequest() *StreamReadMessage_InitRequest {
	if x != nil {
		if x, ok := x.ClientMessage.(*StreamReadMessage_FromClient_InitRequest); ok {
			return x.InitRequest
		}
	}
	return nil
}

func (x *StreamReadMessage_FromClient) GetReadRequest() *StreamReadMessage_ReadRequest {
	if x != nil {
		if x, ok := x.ClientMessage.(*StreamReadMessage_FromClient_ReadRequest); ok {
			return x.ReadRequest
		}
	}
	return nil
}

func (x *StreamReadMessage_FromClient) GetCommitOffsetRequest() *StreamReadMessage_CommitOffsetRequest {
	if x != nil {
		if x, ok := x.ClientMessage.(*StreamReadMessage_FromClient_CommitOffsetRequest); ok {
			return x.CommitOffsetRequest
		}
	}
	return nil
}

func (x *StreamReadMessage_FromClient) GetPartitionSessionStatusRequest() *StreamReadMessage_PartitionSessionStatusRequest {
	if x != nil {
		if x, ok := x.ClientMessage.(*StreamReadMessage_FromClient_PartitionSessionStatusRequest); ok {
			return x.PartitionSessionStatusRequest
		}
	}
	return nil
}

func (x *StreamReadMessage_FromClient) GetUpdateTokenRequest() *UpdateTokenRequest {
	if x != nil {
		if x, ok := x.ClientMessage.(*StreamReadMessage_FromClient_UpdateTokenRequest); ok {
			return x.UpdateTokenRequest
		}
	}
	return nil
}

func (x *StreamReadMessage_FromClient) GetDirectReadAck() *StreamReadMessage_DirectReadAck {
	if x != nil {
		if x, ok := x.ClientMessage.(*StreamReadMessage_FromClient_DirectReadAck); ok {
			return x.DirectReadAck
		}
	}
	return nil
}

func (x *StreamReadMessage_FromClient) GetStartPartitionSessionResponse() *StreamReadMessage_StartPartitionSessionResponse {
	if x != nil {
		if x, ok := x.ClientMessage.(*StreamReadMessage_FromClient_StartPartitionSessionResponse); ok {
			return x.StartPartitionSessionResponse
		}
	}
	return nil
}

func (x *StreamReadMessage_FromClient) GetStopPartitionSessionResponse() *StreamReadMessage_StopPartitionSessionResponse {
	if x != nil {
		if x, ok := x.ClientMessage.(*StreamReadMessage_FromClient_StopPartitionSessionResponse); ok {
			return x.StopPartitionSessionResponse
		}
	}
	return nil
}

func (x *StreamReadMessage_FromClient) SetInitRequest(v *StreamReadMessage_InitRequest) {
	if v == nil {
		x.ClientMessage = nil
		return
	}
	x.ClientMessage = &StreamReadMessage_FromClient_InitRequest{v}
}

func (x *StreamReadMessage_FromClient) SetReadRequest(v *StreamReadMessage_ReadRequest) {
	if v == nil {
		x.ClientMessage = nil
		return
	}
	x.ClientMessage = &StreamReadMessage_FromClient_ReadRequest{v}
}

func (x *StreamReadMessage_FromClient) SetCommitOffsetRequest(v *StreamReadMessage_CommitOffsetRequest) {
	if v == nil {
		x.ClientMessage = nil
		return
	}
	x.ClientMessage = &StreamReadMessage_FromClient_CommitOffsetRequest{v}
}

func (x *StreamReadMessage_FromClient) SetPartitionSessionStatusRequest(v *StreamReadMessage_PartitionSessionStatusRequest) {
	if v == nil {
		x.ClientMessage = nil
		return
	}
	x.ClientMessage = &StreamReadMessage_FromClient_PartitionSessionStatusRequest{v}
}

func (x *StreamReadMessage_FromClient) SetUpdateTokenRequest(v *UpdateTokenRequest) {
	if v == nil {
		x.ClientMessage = nil
		return
	}
	x.ClientMessage = &StreamReadMessage_FromClient_UpdateTokenRequest{v}
}

func (x *StreamReadMessage_FromClient) SetDirectReadAck(v *StreamReadMessage_DirectReadAck) {
	if v == nil {
		x.ClientMessage = nil
		return
	}
	x.ClientMessage = &StreamReadMessage_FromClient_DirectReadAck{v}
}

func (x *StreamReadMessage_FromClient) SetStartPartitionSessionResponse(v *StreamReadMessage_StartPartitionSessionResponse) {
	if v == nil {
		x.ClientMessage = nil
		return
	}
	x.ClientMessage = &StreamReadMessage_FromClient_StartPartitionSessionResponse{v}
}

func (x *StreamReadMessage_FromClient) SetStopPartitionSessionResponse(v *StreamReadMessage_StopPartitionSessionResponse) {
	if v == nil {
		x.ClientMessage = nil
		return
	}
	x.ClientMessage = &StreamReadMessage_FromClient_StopPartitionSessionResponse{v}
}

func (x *StreamReadMessage_FromClient) HasClientMessage() bool {
	if x == nil {
		return false
	}
	return x.ClientMessage != nil
}

func (x *StreamReadMessage_FromClient) HasInitRequest() bool {
	if x == nil {
		return false
	}
	_, ok := x.ClientMessage.(*StreamReadMessage_FromClient_InitRequest)
	return ok
}

func (x *StreamReadMessage_FromClient) HasReadRequest() bool {
	if x == nil {
		return false
	}
	_, ok := x.ClientMessage.(*StreamReadMessage_FromClient_ReadRequest)
	return ok
}

func (x *StreamReadMessage_FromClient) HasCommitOffsetRequest() bool {
	if x == nil {
		return false
	}
	_, ok := x.ClientMessage.(*StreamReadMessage_FromClient_CommitOffsetRequest)
	return ok
}

func (x *StreamReadMessage_FromClient) HasPartitionSessionStatusRequest() bool {
	if x == nil {
		return false
	}
	_, ok := x.ClientMessage.(*StreamReadMessage_FromClient_PartitionSessionStatusRequest)
	return ok
}

func (x *StreamReadMessage_FromClient) HasUpdateTokenRequest() bool {
	if x == nil {
		return false
	}
	_, ok := x.ClientMessage.(*StreamReadMessage_FromClient_UpdateTokenRequest)
	return ok
}

func (x *StreamReadMessage_FromClient) HasDirectReadAck() bool {
	if x == nil {
		return false
	}
	_, ok := x.ClientMessage.(*StreamReadMessage_FromClient_DirectReadAck)
	return ok
}

func (x *StreamReadMessage_FromClient) HasStartPartitionSessionResponse() bool {
	if x == nil {
		return false
	}
	_, ok := x.ClientMessage.(*StreamReadMessage_FromClient_StartPartitionSessionResponse)
	return ok
}

func (x *StreamReadMessage_FromClient) HasStopPartitionSessionResponse() bool {
	if x == nil {
		return false
	}
	_, ok := x.ClientMessage.(*StreamReadMessage_FromClient_StopPartitionSessionResponse)
	return ok
}

func (x *StreamReadMessage_FromClient) ClearClientMessage() {
	x.ClientMessage = nil
}

func (x *StreamReadMessage_FromClient) ClearInitRequest() {
	if _, ok := x.ClientMessage.(*StreamReadMessage_FromClient_InitRequest); ok {
		x.ClientMessage = nil
	}
}

func (x *StreamReadMessage_FromClient) ClearReadRequest() {
	if _, ok := x.ClientMessage.(*StreamReadMessage_FromClient_ReadRequest); ok {
		x.ClientMessage = nil
	}
}

func (x *StreamReadMessage_FromClient) ClearCommitOffsetRequest() {
	if _, ok := x.ClientMessage.(*StreamReadMessage_FromClient_CommitOffsetRequest); ok {
		x.ClientMessage = nil
	}
}

func (x *StreamReadMessage_FromClient) ClearPartitionSessionStatusRequest() {
	if _, ok := x.ClientMessage.(*StreamReadMessage_FromClient_PartitionSessionStatusRequest); ok {
		x.ClientMessage = nil
	}
}

func (x *StreamReadMessage_FromClient) ClearUpdateTokenRequest() {
	if _, ok := x.ClientMessage.(*StreamReadMessage_FromClient_UpdateTokenRequest); ok {
		x.ClientMessage = nil
	}
}

func (x *StreamReadMessage_FromClient) ClearDirectReadAck() {
	if _, ok := x.ClientMessage.(*StreamReadMessage_FromClient_DirectReadAck); ok {
		x.ClientMessage = nil
	}
}

func (x *StreamReadMessage_FromClient) ClearStartPartitionSessionResponse() {
	if _, ok := x.ClientMessage.(*StreamReadMessage_FromClient_StartPartitionSessionResponse); ok {
		x.ClientMessage = nil
	}
}

func (x *StreamReadMessage_FromClient) ClearStopPartitionSessionResponse() {
	if _, ok := x.ClientMessage.(*StreamReadMessage_FromClient_StopPartitionSessionResponse); ok {
		x.ClientMessage = nil
	}
}

const StreamReadMessage_FromClient_ClientMessage_not_set_case case_StreamReadMessage_FromClient_ClientMessage = 0
const StreamReadMessage_FromClient_InitRequest_case case_StreamReadMessage_FromClient_ClientMessage = 1
const StreamReadMessage_FromClient_ReadRequest_case case_StreamReadMessage_FromClient_ClientMessage = 2
const StreamReadMessage_FromClient_CommitOffsetRequest_case case_StreamReadMessage_FromClient_ClientMessage = 3
const StreamReadMessage_FromClient_PartitionSessionStatusRequest_case case_StreamReadMessage_FromClient_ClientMessage = 4
const StreamReadMessage_FromClient_UpdateTokenRequest_case case_StreamReadMessage_FromClient_ClientMessage = 5
const StreamReadMessage_FromClient_DirectReadAck_case case_StreamReadMessage_FromClient_ClientMessage = 8
const StreamReadMessage_FromClient_StartPartitionSessionResponse_case case_StreamReadMessage_FromClient_ClientMessage = 6
const StreamReadMessage_FromClient_StopPartitionSessionResponse_case case_StreamReadMessage_FromClient_ClientMessage = 7

func (x *StreamReadMessage_FromClient) WhichClientMessage() case_StreamReadMessage_FromClient_ClientMessage {
	if x == nil {
		return StreamReadMessage_FromClient_ClientMessage_not_set_case
	}
	switch x.ClientMessage.(type) {
	case *StreamReadMessage_FromClient_InitRequest:
		return StreamReadMessage_FromClient_InitRequest_case
	case *StreamReadMessage_FromClient_ReadRequest:
		return StreamReadMessage_FromClient_ReadRequest_case
	case *StreamReadMessage_FromClient_CommitOffsetRequest:
		return StreamReadMessage_FromClient_CommitOffsetRequest_case
	case *StreamReadMessage_FromClient_PartitionSessionStatusRequest:
		return StreamReadMessage_FromClient_PartitionSessionStatusRequest_case
	case *StreamReadMessage_FromClient_UpdateTokenRequest:
		return StreamReadMessage_FromClient_UpdateTokenRequest_case
	case *StreamReadMessage_FromClient_DirectReadAck:
		return StreamReadMessage_FromClient_DirectReadAck_case
	case *StreamReadMessage_FromClient_StartPartitionSessionResponse:
		return StreamReadMessage_FromClient_StartPartitionSessionResponse_case
	case *StreamReadMessage_FromClient_StopPartitionSessionResponse:
		return StreamReadMessage_FromClient_StopPartitionSessionResponse_case
	default:
		return StreamReadMessage_FromClient_ClientMessage_not_set_case
	}
}

type StreamReadMessage_FromClient_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Fields of oneof ClientMessage:
	// Client requests.
	InitRequest                   *StreamReadMessage_InitRequest
	ReadRequest                   *StreamReadMessage_ReadRequest
	CommitOffsetRequest           *StreamReadMessage_CommitOffsetRequest
	PartitionSessionStatusRequest *StreamReadMessage_PartitionSessionStatusRequest
	UpdateTokenRequest            *UpdateTokenRequest
	DirectReadAck                 *StreamReadMessage_DirectReadAck
	// Responses to respective server commands.
	StartPartitionSessionResponse *StreamReadMessage_StartPartitionSessionResponse
	StopPartitionSessionResponse  *StreamReadMessage_StopPartitionSessionResponse
	// -- end of ClientMessage
}

func (b0 StreamReadMessage_FromClient_builder) Build() *StreamReadMessage_FromClient {
	m0 := &StreamReadMessage_FromClient{}
	b, x := &b0, m0
	_, _ = b, x
	if b.InitRequest != nil {
		x.ClientMessage = &StreamReadMessage_FromClient_InitRequest{b.InitRequest}
	}
	if b.ReadRequest != nil {
		x.ClientMessage = &StreamReadMessage_FromClient_ReadRequest{b.ReadRequest}
	}
	if b.CommitOffsetRequest != nil {
		x.ClientMessage = &StreamReadMessage_FromClient_CommitOffsetRequest{b.CommitOffsetRequest}
	}
	if b.PartitionSessionStatusRequest != nil {
		x.ClientMessage = &StreamReadMessage_FromClient_PartitionSessionStatusRequest{b.PartitionSessionStatusRequest}
	}
	if b.UpdateTokenRequest != nil {
		x.ClientMessage = &StreamReadMessage_FromClient_UpdateTokenRequest{b.UpdateTokenRequest}
	}
	if b.DirectReadAck != nil {
		x.ClientMessage = &StreamReadMessage_FromClient_DirectReadAck{b.DirectReadAck}
	}
	if b.StartPartitionSessionResponse != nil {
		x.ClientMessage = &StreamReadMessage_FromClient_StartPartitionSessionResponse{b.StartPartitionSessionResponse}
	}
	if b.StopPartitionSessionResponse != nil {
		x.ClientMessage = &StreamReadMessage_FromClient_StopPartitionSessionResponse{b.StopPartitionSessionResponse}
	}
	return m0
}

type case_StreamReadMessage_FromClient_ClientMessage protoreflect.FieldNumber

func (x case_StreamReadMessage_FromClient_ClientMessage) String() string {
	md := file_protos_ydb_topic_proto_msgTypes[60].Descriptor()
	if x == 0 {
		return "not set"
	}
	return protoimpl.X.MessageFieldStringOf(md, protoreflect.FieldNumber(x))
}

type isStreamReadMessage_FromClient_ClientMessage interface {
	isStreamReadMessage_FromClient_ClientMessage()
}

type StreamReadMessage_FromClient_InitRequest struct {
	// Client requests.
	InitRequest *StreamReadMessage_InitRequest `protobuf:"bytes,1,opt,name=init_request,json=initRequest,oneof"`
}

type StreamReadMessage_FromClient_ReadRequest struct {
	ReadRequest *StreamReadMessage_ReadRequest `protobuf:"bytes,2,opt,name=read_request,json=readRequest,oneof"`
}

type StreamReadMessage_FromClient_CommitOffsetRequest struct {
	CommitOffsetRequest *StreamReadMessage_CommitOffsetRequest `protobuf:"bytes,3,opt,name=commit_offset_request,json=commitOffsetRequest,oneof"`
}

type StreamReadMessage_FromClient_PartitionSessionStatusRequest struct {
	PartitionSessionStatusRequest *StreamReadMessage_PartitionSessionStatusRequest `protobuf:"bytes,4,opt,name=partition_session_status_request,json=partitionSessionStatusRequest,oneof"`
}

type StreamReadMessage_FromClient_UpdateTokenRequest struct {
	UpdateTokenRequest *UpdateTokenRequest `protobuf:"bytes,5,opt,name=update_token_request,json=updateTokenRequest,oneof"`
}

type StreamReadMessage_FromClient_DirectReadAck struct {
	DirectReadAck *StreamReadMessage_DirectReadAck `protobuf:"bytes,8,opt,name=direct_read_ack,json=directReadAck,oneof"`
}

type StreamReadMessage_FromClient_StartPartitionSessionResponse struct {
	// Responses to respective server commands.
	StartPartitionSessionResponse *StreamReadMessage_StartPartitionSessionResponse `protobuf:"bytes,6,opt,name=start_partition_session_response,json=startPartitionSessionResponse,oneof"`
}

type StreamReadMessage_FromClient_StopPartitionSessionResponse struct {
	StopPartitionSessionResponse *StreamReadMessage_StopPartitionSessionResponse `protobuf:"bytes,7,opt,name=stop_partition_session_response,json=stopPartitionSessionResponse,oneof"`
}

func (*StreamReadMessage_FromClient_InitRequest) isStreamReadMessage_FromClient_ClientMessage() {}

func (*StreamReadMessage_FromClient_ReadRequest) isStreamReadMessage_FromClient_ClientMessage() {}

func (*StreamReadMessage_FromClient_CommitOffsetRequest) isStreamReadMessage_FromClient_ClientMessage() {
}

func (*StreamReadMessage_FromClient_PartitionSessionStatusRequest) isStreamReadMessage_FromClient_ClientMessage() {
}

func (*StreamReadMessage_FromClient_UpdateTokenRequest) isStreamReadMessage_FromClient_ClientMessage() {
}

func (*StreamReadMessage_FromClient_DirectReadAck) isStreamReadMessage_FromClient_ClientMessage() {}

func (*StreamReadMessage_FromClient_StartPartitionSessionResponse) isStreamReadMessage_FromClient_ClientMessage() {
}

func (*StreamReadMessage_FromClient_StopPartitionSessionResponse) isStreamReadMessage_FromClient_ClientMessage() {
}

// Server-client message for read session. Contains one of:
//
//	InitResponse - handshake response from server.
//	ReadResponse - portion of data.
//	CommitOffsetResponse - acknowledgment for commit.
//	PartitionSessionStatusResponse - server response with partition session status.
//	UpdateTokenResponse - acknowledgment of token update.
//
//	StartPartitionSessionRequest - command from server to create a partition session.
//	StopPartitionSessionRequest - command from server to destroy a partition session.
//	UpdatePartitionSession - command from server to update a partition session.
type StreamReadMessage_FromServer struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Server status of response.
	Status *Ydb.StatusIds_StatusCode `protobuf:"varint,1,opt,name=status,enum=Ydb.StatusIds_StatusCode" json:"status,omitempty"`
	// Issues if any.
	Issues []*Ydb_Issue.IssueMessage `protobuf:"bytes,2,rep,name=issues" json:"issues,omitempty"`
	// Types that are valid to be assigned to ServerMessage:
	//
	//	*StreamReadMessage_FromServer_InitResponse
	//	*StreamReadMessage_FromServer_ReadResponse
	//	*StreamReadMessage_FromServer_CommitOffsetResponse
	//	*StreamReadMessage_FromServer_PartitionSessionStatusResponse
	//	*StreamReadMessage_FromServer_UpdateTokenResponse
	//	*StreamReadMessage_FromServer_StartPartitionSessionRequest
	//	*StreamReadMessage_FromServer_StopPartitionSessionRequest
	//	*StreamReadMessage_FromServer_UpdatePartitionSession
	//	*StreamReadMessage_FromServer_EndPartitionSession
	ServerMessage isStreamReadMessage_FromServer_ServerMessage `protobuf_oneof:"server_message"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamReadMessage_FromServer) Reset() {
	*x = StreamReadMessage_FromServer{}
	mi := &file_protos_ydb_topic_proto_msgTypes[61]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_FromServer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_FromServer) ProtoMessage() {}

func (x *StreamReadMessage_FromServer) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[61]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamReadMessage_FromServer) GetStatus() Ydb.StatusIds_StatusCode {
	if x != nil && x.Status != nil {
		return *x.Status
	}
	return Ydb.StatusIds_StatusCode(0)
}

func (x *StreamReadMessage_FromServer) GetIssues() []*Ydb_Issue.IssueMessage {
	if x != nil {
		return x.Issues
	}
	return nil
}

func (x *StreamReadMessage_FromServer) GetServerMessage() isStreamReadMessage_FromServer_ServerMessage {
	if x != nil {
		return x.ServerMessage
	}
	return nil
}

func (x *StreamReadMessage_FromServer) GetInitResponse() *StreamReadMessage_InitResponse {
	if x != nil {
		if x, ok := x.ServerMessage.(*StreamReadMessage_FromServer_InitResponse); ok {
			return x.InitResponse
		}
	}
	return nil
}

func (x *StreamReadMessage_FromServer) GetReadResponse() *StreamReadMessage_ReadResponse {
	if x != nil {
		if x, ok := x.ServerMessage.(*StreamReadMessage_FromServer_ReadResponse); ok {
			return x.ReadResponse
		}
	}
	return nil
}

func (x *StreamReadMessage_FromServer) GetCommitOffsetResponse() *StreamReadMessage_CommitOffsetResponse {
	if x != nil {
		if x, ok := x.ServerMessage.(*StreamReadMessage_FromServer_CommitOffsetResponse); ok {
			return x.CommitOffsetResponse
		}
	}
	return nil
}

func (x *StreamReadMessage_FromServer) GetPartitionSessionStatusResponse() *StreamReadMessage_PartitionSessionStatusResponse {
	if x != nil {
		if x, ok := x.ServerMessage.(*StreamReadMessage_FromServer_PartitionSessionStatusResponse); ok {
			return x.PartitionSessionStatusResponse
		}
	}
	return nil
}

func (x *StreamReadMessage_FromServer) GetUpdateTokenResponse() *UpdateTokenResponse {
	if x != nil {
		if x, ok := x.ServerMessage.(*StreamReadMessage_FromServer_UpdateTokenResponse); ok {
			return x.UpdateTokenResponse
		}
	}
	return nil
}

func (x *StreamReadMessage_FromServer) GetStartPartitionSessionRequest() *StreamReadMessage_StartPartitionSessionRequest {
	if x != nil {
		if x, ok := x.ServerMessage.(*StreamReadMessage_FromServer_StartPartitionSessionRequest); ok {
			return x.StartPartitionSessionRequest
		}
	}
	return nil
}

func (x *StreamReadMessage_FromServer) GetStopPartitionSessionRequest() *StreamReadMessage_StopPartitionSessionRequest {
	if x != nil {
		if x, ok := x.ServerMessage.(*StreamReadMessage_FromServer_StopPartitionSessionRequest); ok {
			return x.StopPartitionSessionRequest
		}
	}
	return nil
}

func (x *StreamReadMessage_FromServer) GetUpdatePartitionSession() *StreamReadMessage_UpdatePartitionSession {
	if x != nil {
		if x, ok := x.ServerMessage.(*StreamReadMessage_FromServer_UpdatePartitionSession); ok {
			return x.UpdatePartitionSession
		}
	}
	return nil
}

func (x *StreamReadMessage_FromServer) GetEndPartitionSession() *StreamReadMessage_EndPartitionSession {
	if x != nil {
		if x, ok := x.ServerMessage.(*StreamReadMessage_FromServer_EndPartitionSession); ok {
			return x.EndPartitionSession
		}
	}
	return nil
}

func (x *StreamReadMessage_FromServer) SetStatus(v Ydb.StatusIds_StatusCode) {
	x.Status = &v
}

func (x *StreamReadMessage_FromServer) SetIssues(v []*Ydb_Issue.IssueMessage) {
	x.Issues = v
}

func (x *StreamReadMessage_FromServer) SetInitResponse(v *StreamReadMessage_InitResponse) {
	if v == nil {
		x.ServerMessage = nil
		return
	}
	x.ServerMessage = &StreamReadMessage_FromServer_InitResponse{v}
}

func (x *StreamReadMessage_FromServer) SetReadResponse(v *StreamReadMessage_ReadResponse) {
	if v == nil {
		x.ServerMessage = nil
		return
	}
	x.ServerMessage = &StreamReadMessage_FromServer_ReadResponse{v}
}

func (x *StreamReadMessage_FromServer) SetCommitOffsetResponse(v *StreamReadMessage_CommitOffsetResponse) {
	if v == nil {
		x.ServerMessage = nil
		return
	}
	x.ServerMessage = &StreamReadMessage_FromServer_CommitOffsetResponse{v}
}

func (x *StreamReadMessage_FromServer) SetPartitionSessionStatusResponse(v *StreamReadMessage_PartitionSessionStatusResponse) {
	if v == nil {
		x.ServerMessage = nil
		return
	}
	x.ServerMessage = &StreamReadMessage_FromServer_PartitionSessionStatusResponse{v}
}

func (x *StreamReadMessage_FromServer) SetUpdateTokenResponse(v *UpdateTokenResponse) {
	if v == nil {
		x.ServerMessage = nil
		return
	}
	x.ServerMessage = &StreamReadMessage_FromServer_UpdateTokenResponse{v}
}

func (x *StreamReadMessage_FromServer) SetStartPartitionSessionRequest(v *StreamReadMessage_StartPartitionSessionRequest) {
	if v == nil {
		x.ServerMessage = nil
		return
	}
	x.ServerMessage = &StreamReadMessage_FromServer_StartPartitionSessionRequest{v}
}

func (x *StreamReadMessage_FromServer) SetStopPartitionSessionRequest(v *StreamReadMessage_StopPartitionSessionRequest) {
	if v == nil {
		x.ServerMessage = nil
		return
	}
	x.ServerMessage = &StreamReadMessage_FromServer_StopPartitionSessionRequest{v}
}

func (x *StreamReadMessage_FromServer) SetUpdatePartitionSession(v *StreamReadMessage_UpdatePartitionSession) {
	if v == nil {
		x.ServerMessage = nil
		return
	}
	x.ServerMessage = &StreamReadMessage_FromServer_UpdatePartitionSession{v}
}

func (x *StreamReadMessage_FromServer) SetEndPartitionSession(v *StreamReadMessage_EndPartitionSession) {
	if v == nil {
		x.ServerMessage = nil
		return
	}
	x.ServerMessage = &StreamReadMessage_FromServer_EndPartitionSession{v}
}

func (x *StreamReadMessage_FromServer) HasStatus() bool {
	if x == nil {
		return false
	}
	return x.Status != nil
}

func (x *StreamReadMessage_FromServer) HasServerMessage() bool {
	if x == nil {
		return false
	}
	return x.ServerMessage != nil
}

func (x *StreamReadMessage_FromServer) HasInitResponse() bool {
	if x == nil {
		return false
	}
	_, ok := x.ServerMessage.(*StreamReadMessage_FromServer_InitResponse)
	return ok
}

func (x *StreamReadMessage_FromServer) HasReadResponse() bool {
	if x == nil {
		return false
	}
	_, ok := x.ServerMessage.(*StreamReadMessage_FromServer_ReadResponse)
	return ok
}

func (x *StreamReadMessage_FromServer) HasCommitOffsetResponse() bool {
	if x == nil {
		return false
	}
	_, ok := x.ServerMessage.(*StreamReadMessage_FromServer_CommitOffsetResponse)
	return ok
}

func (x *StreamReadMessage_FromServer) HasPartitionSessionStatusResponse() bool {
	if x == nil {
		return false
	}
	_, ok := x.ServerMessage.(*StreamReadMessage_FromServer_PartitionSessionStatusResponse)
	return ok
}

func (x *StreamReadMessage_FromServer) HasUpdateTokenResponse() bool {
	if x == nil {
		return false
	}
	_, ok := x.ServerMessage.(*StreamReadMessage_FromServer_UpdateTokenResponse)
	return ok
}

func (x *StreamReadMessage_FromServer) HasStartPartitionSessionRequest() bool {
	if x == nil {
		return false
	}
	_, ok := x.ServerMessage.(*StreamReadMessage_FromServer_StartPartitionSessionRequest)
	return ok
}

func (x *StreamReadMessage_FromServer) HasStopPartitionSessionRequest() bool {
	if x == nil {
		return false
	}
	_, ok := x.ServerMessage.(*StreamReadMessage_FromServer_StopPartitionSessionRequest)
	return ok
}

func (x *StreamReadMessage_FromServer) HasUpdatePartitionSession() bool {
	if x == nil {
		return false
	}
	_, ok := x.ServerMessage.(*StreamReadMessage_FromServer_UpdatePartitionSession)
	return ok
}

func (x *StreamReadMessage_FromServer) HasEndPartitionSession() bool {
	if x == nil {
		return false
	}
	_, ok := x.ServerMessage.(*StreamReadMessage_FromServer_EndPartitionSession)
	return ok
}

func (x *StreamReadMessage_FromServer) ClearStatus() {
	x.Status = nil
}

func (x *StreamReadMessage_FromServer) ClearServerMessage() {
	x.ServerMessage = nil
}

func (x *StreamReadMessage_FromServer) ClearInitResponse() {
	if _, ok := x.ServerMessage.(*StreamReadMessage_FromServer_InitResponse); ok {
		x.ServerMessage = nil
	}
}

func (x *StreamReadMessage_FromServer) ClearReadResponse() {
	if _, ok := x.ServerMessage.(*StreamReadMessage_FromServer_ReadResponse); ok {
		x.ServerMessage = nil
	}
}

func (x *StreamReadMessage_FromServer) ClearCommitOffsetResponse() {
	if _, ok := x.ServerMessage.(*StreamReadMessage_FromServer_CommitOffsetResponse); ok {
		x.ServerMessage = nil
	}
}

func (x *StreamReadMessage_FromServer) ClearPartitionSessionStatusResponse() {
	if _, ok := x.ServerMessage.(*StreamReadMessage_FromServer_PartitionSessionStatusResponse); ok {
		x.ServerMessage = nil
	}
}

func (x *StreamReadMessage_FromServer) ClearUpdateTokenResponse() {
	if _, ok := x.ServerMessage.(*StreamReadMessage_FromServer_UpdateTokenResponse); ok {
		x.ServerMessage = nil
	}
}

func (x *StreamReadMessage_FromServer) ClearStartPartitionSessionRequest() {
	if _, ok := x.ServerMessage.(*StreamReadMessage_FromServer_StartPartitionSessionRequest); ok {
		x.ServerMessage = nil
	}
}

func (x *StreamReadMessage_FromServer) ClearStopPartitionSessionRequest() {
	if _, ok := x.ServerMessage.(*StreamReadMessage_FromServer_StopPartitionSessionRequest); ok {
		x.ServerMessage = nil
	}
}

func (x *StreamReadMessage_FromServer) ClearUpdatePartitionSession() {
	if _, ok := x.ServerMessage.(*StreamReadMessage_FromServer_UpdatePartitionSession); ok {
		x.ServerMessage = nil
	}
}

func (x *StreamReadMessage_FromServer) ClearEndPartitionSession() {
	if _, ok := x.ServerMessage.(*StreamReadMessage_FromServer_EndPartitionSession); ok {
		x.ServerMessage = nil
	}
}

const StreamReadMessage_FromServer_ServerMessage_not_set_case case_StreamReadMessage_FromServer_ServerMessage = 0
const StreamReadMessage_FromServer_InitResponse_case case_StreamReadMessage_FromServer_ServerMessage = 3
const StreamReadMessage_FromServer_ReadResponse_case case_StreamReadMessage_FromServer_ServerMessage = 4
const StreamReadMessage_FromServer_CommitOffsetResponse_case case_StreamReadMessage_FromServer_ServerMessage = 5
const StreamReadMessage_FromServer_PartitionSessionStatusResponse_case case_StreamReadMessage_FromServer_ServerMessage = 6
const StreamReadMessage_FromServer_UpdateTokenResponse_case case_StreamReadMessage_FromServer_ServerMessage = 7
const StreamReadMessage_FromServer_StartPartitionSessionRequest_case case_StreamReadMessage_FromServer_ServerMessage = 8
const StreamReadMessage_FromServer_StopPartitionSessionRequest_case case_StreamReadMessage_FromServer_ServerMessage = 9
const StreamReadMessage_FromServer_UpdatePartitionSession_case case_StreamReadMessage_FromServer_ServerMessage = 10
const StreamReadMessage_FromServer_EndPartitionSession_case case_StreamReadMessage_FromServer_ServerMessage = 11

func (x *StreamReadMessage_FromServer) WhichServerMessage() case_StreamReadMessage_FromServer_ServerMessage {
	if x == nil {
		return StreamReadMessage_FromServer_ServerMessage_not_set_case
	}
	switch x.ServerMessage.(type) {
	case *StreamReadMessage_FromServer_InitResponse:
		return StreamReadMessage_FromServer_InitResponse_case
	case *StreamReadMessage_FromServer_ReadResponse:
		return StreamReadMessage_FromServer_ReadResponse_case
	case *StreamReadMessage_FromServer_CommitOffsetResponse:
		return StreamReadMessage_FromServer_CommitOffsetResponse_case
	case *StreamReadMessage_FromServer_PartitionSessionStatusResponse:
		return StreamReadMessage_FromServer_PartitionSessionStatusResponse_case
	case *StreamReadMessage_FromServer_UpdateTokenResponse:
		return StreamReadMessage_FromServer_UpdateTokenResponse_case
	case *StreamReadMessage_FromServer_StartPartitionSessionRequest:
		return StreamReadMessage_FromServer_StartPartitionSessionRequest_case
	case *StreamReadMessage_FromServer_StopPartitionSessionRequest:
		return StreamReadMessage_FromServer_StopPartitionSessionRequest_case
	case *StreamReadMessage_FromServer_UpdatePartitionSession:
		return StreamReadMessage_FromServer_UpdatePartitionSession_case
	case *StreamReadMessage_FromServer_EndPartitionSession:
		return StreamReadMessage_FromServer_EndPartitionSession_case
	default:
		return StreamReadMessage_FromServer_ServerMessage_not_set_case
	}
}

type StreamReadMessage_FromServer_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Server status of response.
	Status *Ydb.StatusIds_StatusCode
	// Issues if any.
	Issues []*Ydb_Issue.IssueMessage
	// Fields of oneof ServerMessage:
	// Responses to respective client requests.
	InitResponse                   *StreamReadMessage_InitResponse
	ReadResponse                   *StreamReadMessage_ReadResponse
	CommitOffsetResponse           *StreamReadMessage_CommitOffsetResponse
	PartitionSessionStatusResponse *StreamReadMessage_PartitionSessionStatusResponse
	UpdateTokenResponse            *UpdateTokenResponse
	// Server commands.
	StartPartitionSessionRequest *StreamReadMessage_StartPartitionSessionRequest
	StopPartitionSessionRequest  *StreamReadMessage_StopPartitionSessionRequest
	UpdatePartitionSession       *StreamReadMessage_UpdatePartitionSession
	EndPartitionSession          *StreamReadMessage_EndPartitionSession
	// -- end of ServerMessage
}

func (b0 StreamReadMessage_FromServer_builder) Build() *StreamReadMessage_FromServer {
	m0 := &StreamReadMessage_FromServer{}
	b, x := &b0, m0
	_, _ = b, x
	x.Status = b.Status
	x.Issues = b.Issues
	if b.InitResponse != nil {
		x.ServerMessage = &StreamReadMessage_FromServer_InitResponse{b.InitResponse}
	}
	if b.ReadResponse != nil {
		x.ServerMessage = &StreamReadMessage_FromServer_ReadResponse{b.ReadResponse}
	}
	if b.CommitOffsetResponse != nil {
		x.ServerMessage = &StreamReadMessage_FromServer_CommitOffsetResponse{b.CommitOffsetResponse}
	}
	if b.PartitionSessionStatusResponse != nil {
		x.ServerMessage = &StreamReadMessage_FromServer_PartitionSessionStatusResponse{b.PartitionSessionStatusResponse}
	}
	if b.UpdateTokenResponse != nil {
		x.ServerMessage = &StreamReadMessage_FromServer_UpdateTokenResponse{b.UpdateTokenResponse}
	}
	if b.StartPartitionSessionRequest != nil {
		x.ServerMessage = &StreamReadMessage_FromServer_StartPartitionSessionRequest{b.StartPartitionSessionRequest}
	}
	if b.StopPartitionSessionRequest != nil {
		x.ServerMessage = &StreamReadMessage_FromServer_StopPartitionSessionRequest{b.StopPartitionSessionRequest}
	}
	if b.UpdatePartitionSession != nil {
		x.ServerMessage = &StreamReadMessage_FromServer_UpdatePartitionSession{b.UpdatePartitionSession}
	}
	if b.EndPartitionSession != nil {
		x.ServerMessage = &StreamReadMessage_FromServer_EndPartitionSession{b.EndPartitionSession}
	}
	return m0
}

type case_StreamReadMessage_FromServer_ServerMessage protoreflect.FieldNumber

func (x case_StreamReadMessage_FromServer_ServerMessage) String() string {
	md := file_protos_ydb_topic_proto_msgTypes[61].Descriptor()
	if x == 0 {
		return "not set"
	}
	return protoimpl.X.MessageFieldStringOf(md, protoreflect.FieldNumber(x))
}

type isStreamReadMessage_FromServer_ServerMessage interface {
	isStreamReadMessage_FromServer_ServerMessage()
}

type StreamReadMessage_FromServer_InitResponse struct {
	// Responses to respective client requests.
	InitResponse *StreamReadMessage_InitResponse `protobuf:"bytes,3,opt,name=init_response,json=initResponse,oneof"`
}

type StreamReadMessage_FromServer_ReadResponse struct {
	ReadResponse *StreamReadMessage_ReadResponse `protobuf:"bytes,4,opt,name=read_response,json=readResponse,oneof"`
}

type StreamReadMessage_FromServer_CommitOffsetResponse struct {
	CommitOffsetResponse *StreamReadMessage_CommitOffsetResponse `protobuf:"bytes,5,opt,name=commit_offset_response,json=commitOffsetResponse,oneof"`
}

type StreamReadMessage_FromServer_PartitionSessionStatusResponse struct {
	PartitionSessionStatusResponse *StreamReadMessage_PartitionSessionStatusResponse `protobuf:"bytes,6,opt,name=partition_session_status_response,json=partitionSessionStatusResponse,oneof"`
}

type StreamReadMessage_FromServer_UpdateTokenResponse struct {
	UpdateTokenResponse *UpdateTokenResponse `protobuf:"bytes,7,opt,name=update_token_response,json=updateTokenResponse,oneof"`
}

type StreamReadMessage_FromServer_StartPartitionSessionRequest struct {
	// Server commands.
	StartPartitionSessionRequest *StreamReadMessage_StartPartitionSessionRequest `protobuf:"bytes,8,opt,name=start_partition_session_request,json=startPartitionSessionRequest,oneof"`
}

type StreamReadMessage_FromServer_StopPartitionSessionRequest struct {
	StopPartitionSessionRequest *StreamReadMessage_StopPartitionSessionRequest `protobuf:"bytes,9,opt,name=stop_partition_session_request,json=stopPartitionSessionRequest,oneof"`
}

type StreamReadMessage_FromServer_UpdatePartitionSession struct {
	UpdatePartitionSession *StreamReadMessage_UpdatePartitionSession `protobuf:"bytes,10,opt,name=update_partition_session,json=updatePartitionSession,oneof"`
}

type StreamReadMessage_FromServer_EndPartitionSession struct {
	EndPartitionSession *StreamReadMessage_EndPartitionSession `protobuf:"bytes,11,opt,name=end_partition_session,json=endPartitionSession,oneof"`
}

func (*StreamReadMessage_FromServer_InitResponse) isStreamReadMessage_FromServer_ServerMessage() {}

func (*StreamReadMessage_FromServer_ReadResponse) isStreamReadMessage_FromServer_ServerMessage() {}

func (*StreamReadMessage_FromServer_CommitOffsetResponse) isStreamReadMessage_FromServer_ServerMessage() {
}

func (*StreamReadMessage_FromServer_PartitionSessionStatusResponse) isStreamReadMessage_FromServer_ServerMessage() {
}

func (*StreamReadMessage_FromServer_UpdateTokenResponse) isStreamReadMessage_FromServer_ServerMessage() {
}

func (*StreamReadMessage_FromServer_StartPartitionSessionRequest) isStreamReadMessage_FromServer_ServerMessage() {
}

func (*StreamReadMessage_FromServer_StopPartitionSessionRequest) isStreamReadMessage_FromServer_ServerMessage() {
}

func (*StreamReadMessage_FromServer_UpdatePartitionSession) isStreamReadMessage_FromServer_ServerMessage() {
}

func (*StreamReadMessage_FromServer_EndPartitionSession) isStreamReadMessage_FromServer_ServerMessage() {
}

// Handshake request.
type StreamReadMessage_InitRequest struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Message that describes topic to read.
	// Topics that will be read by this session.
	TopicsReadSettings []*StreamReadMessage_InitRequest_TopicReadSettings `protobuf:"bytes,1,rep,name=topics_read_settings,json=topicsReadSettings" json:"topics_read_settings,omitempty"`
	// Path of consumer that is used for reading by this session.
	Consumer *string `protobuf:"bytes,2,opt,name=consumer" json:"consumer,omitempty"`
	// Optional name. Will be shown in debug stat.
	ReaderName *string `protobuf:"bytes,3,opt,name=reader_name,json=readerName" json:"reader_name,omitempty"`
	// Direct reading from a partition node.
	DirectRead *bool `protobuf:"varint,4,opt,name=direct_read,json=directRead" json:"direct_read,omitempty"`
	// Indicates that the SDK supports auto partitioning.
	AutoPartitioningSupport *bool `protobuf:"varint,5,opt,name=auto_partitioning_support,json=autoPartitioningSupport" json:"auto_partitioning_support,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *StreamReadMessage_InitRequest) Reset() {
	*x = StreamReadMessage_InitRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[62]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_InitRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_InitRequest) ProtoMessage() {}

func (x *StreamReadMessage_InitRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[62]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamReadMessage_InitRequest) GetTopicsReadSettings() []*StreamReadMessage_InitRequest_TopicReadSettings {
	if x != nil {
		return x.TopicsReadSettings
	}
	return nil
}

func (x *StreamReadMessage_InitRequest) GetConsumer() string {
	if x != nil && x.Consumer != nil {
		return *x.Consumer
	}
	return ""
}

func (x *StreamReadMessage_InitRequest) GetReaderName() string {
	if x != nil && x.ReaderName != nil {
		return *x.ReaderName
	}
	return ""
}

func (x *StreamReadMessage_InitRequest) GetDirectRead() bool {
	if x != nil && x.DirectRead != nil {
		return *x.DirectRead
	}
	return false
}

func (x *StreamReadMessage_InitRequest) GetAutoPartitioningSupport() bool {
	if x != nil && x.AutoPartitioningSupport != nil {
		return *x.AutoPartitioningSupport
	}
	return false
}

func (x *StreamReadMessage_InitRequest) SetTopicsReadSettings(v []*StreamReadMessage_InitRequest_TopicReadSettings) {
	x.TopicsReadSettings = v
}

func (x *StreamReadMessage_InitRequest) SetConsumer(v string) {
	x.Consumer = &v
}

func (x *StreamReadMessage_InitRequest) SetReaderName(v string) {
	x.ReaderName = &v
}

func (x *StreamReadMessage_InitRequest) SetDirectRead(v bool) {
	x.DirectRead = &v
}

func (x *StreamReadMessage_InitRequest) SetAutoPartitioningSupport(v bool) {
	x.AutoPartitioningSupport = &v
}

func (x *StreamReadMessage_InitRequest) HasConsumer() bool {
	if x == nil {
		return false
	}
	return x.Consumer != nil
}

func (x *StreamReadMessage_InitRequest) HasReaderName() bool {
	if x == nil {
		return false
	}
	return x.ReaderName != nil
}

func (x *StreamReadMessage_InitRequest) HasDirectRead() bool {
	if x == nil {
		return false
	}
	return x.DirectRead != nil
}

func (x *StreamReadMessage_InitRequest) HasAutoPartitioningSupport() bool {
	if x == nil {
		return false
	}
	return x.AutoPartitioningSupport != nil
}

func (x *StreamReadMessage_InitRequest) ClearConsumer() {
	x.Consumer = nil
}

func (x *StreamReadMessage_InitRequest) ClearReaderName() {
	x.ReaderName = nil
}

func (x *StreamReadMessage_InitRequest) ClearDirectRead() {
	x.DirectRead = nil
}

func (x *StreamReadMessage_InitRequest) ClearAutoPartitioningSupport() {
	x.AutoPartitioningSupport = nil
}

type StreamReadMessage_InitRequest_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Message that describes topic to read.
	// Topics that will be read by this session.
	TopicsReadSettings []*StreamReadMessage_InitRequest_TopicReadSettings
	// Path of consumer that is used for reading by this session.
	Consumer *string
	// Optional name. Will be shown in debug stat.
	ReaderName *string
	// Direct reading from a partition node.
	DirectRead *bool
	// Indicates that the SDK supports auto partitioning.
	AutoPartitioningSupport *bool
}

func (b0 StreamReadMessage_InitRequest_builder) Build() *StreamReadMessage_InitRequest {
	m0 := &StreamReadMessage_InitRequest{}
	b, x := &b0, m0
	_, _ = b, x
	x.TopicsReadSettings = b.TopicsReadSettings
	x.Consumer = b.Consumer
	x.ReaderName = b.ReaderName
	x.DirectRead = b.DirectRead
	x.AutoPartitioningSupport = b.AutoPartitioningSupport
	return m0
}

// Handshake response.
type StreamReadMessage_InitResponse struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Read session identifier.
	SessionId     *string `protobuf:"bytes,1,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamReadMessage_InitResponse) Reset() {
	*x = StreamReadMessage_InitResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[63]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_InitResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_InitResponse) ProtoMessage() {}

func (x *StreamReadMessage_InitResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[63]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamReadMessage_InitResponse) GetSessionId() string {
	if x != nil && x.SessionId != nil {
		return *x.SessionId
	}
	return ""
}

func (x *StreamReadMessage_InitResponse) SetSessionId(v string) {
	x.SessionId = &v
}

func (x *StreamReadMessage_InitResponse) HasSessionId() bool {
	if x == nil {
		return false
	}
	return x.SessionId != nil
}

func (x *StreamReadMessage_InitResponse) ClearSessionId() {
	x.SessionId = nil
}

type StreamReadMessage_InitResponse_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Read session identifier.
	SessionId *string
}

func (b0 StreamReadMessage_InitResponse_builder) Build() *StreamReadMessage_InitResponse {
	m0 := &StreamReadMessage_InitResponse{}
	b, x := &b0, m0
	_, _ = b, x
	x.SessionId = b.SessionId
	return m0
}

// Message that represents client readiness for receiving more data.
type StreamReadMessage_ReadRequest struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Server and client each keep track of total bytes size of all ReadResponses.
	// When client is ready to receive N more bytes in responses (to increment possible total by N),
	// it sends a ReadRequest with bytes_size = N.
	// bytes_size value must be positive.
	// So in expression 'A = (sum of bytes_size in all ReadRequests) - (sum of bytes_size in all ReadResponses)'
	//
	//	server will keep A (available size for responses) non-negative.
	//
	// But there is an exception. If server receives ReadRequest, and the first message in response exceeds A -
	// then it will still be delivered, and A will become negative until enough additional ReadRequests.
	//
	// Example:
	//  1. Let client have 200 bytes buffer. It sends ReadRequest with bytes_size = 200;
	//  2. Server may return one ReadResponse with bytes_size = 70 and than another 80 bytes response;
	//     now client buffer has 50 free bytes, server is free to send up to 50 bytes in responses.
	//  3. Client processes 100 bytes from buffer, now buffer free space is 150 bytes,
	//     so client sends ReadRequest with bytes_size = 100;
	//  4. Server is free to send up to 50 + 100 = 150 bytes. But the next read message is too big,
	//     and it sends 160 bytes ReadResponse.
	//  5. Let's assume client somehow processes it, and its 200 bytes buffer is free again.
	//     It should account for excess 10 bytes and send ReadRequest with bytes_size = 210.
	BytesSize     *int64 `protobuf:"varint,1,opt,name=bytes_size,json=bytesSize" json:"bytes_size,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamReadMessage_ReadRequest) Reset() {
	*x = StreamReadMessage_ReadRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[64]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_ReadRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_ReadRequest) ProtoMessage() {}

func (x *StreamReadMessage_ReadRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[64]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamReadMessage_ReadRequest) GetBytesSize() int64 {
	if x != nil && x.BytesSize != nil {
		return *x.BytesSize
	}
	return 0
}

func (x *StreamReadMessage_ReadRequest) SetBytesSize(v int64) {
	x.BytesSize = &v
}

func (x *StreamReadMessage_ReadRequest) HasBytesSize() bool {
	if x == nil {
		return false
	}
	return x.BytesSize != nil
}

func (x *StreamReadMessage_ReadRequest) ClearBytesSize() {
	x.BytesSize = nil
}

type StreamReadMessage_ReadRequest_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Server and client each keep track of total bytes size of all ReadResponses.
	// When client is ready to receive N more bytes in responses (to increment possible total by N),
	// it sends a ReadRequest with bytes_size = N.
	// bytes_size value must be positive.
	// So in expression 'A = (sum of bytes_size in all ReadRequests) - (sum of bytes_size in all ReadResponses)'
	//
	//	server will keep A (available size for responses) non-negative.
	//
	// But there is an exception. If server receives ReadRequest, and the first message in response exceeds A -
	// then it will still be delivered, and A will become negative until enough additional ReadRequests.
	//
	// Example:
	//  1. Let client have 200 bytes buffer. It sends ReadRequest with bytes_size = 200;
	//  2. Server may return one ReadResponse with bytes_size = 70 and than another 80 bytes response;
	//     now client buffer has 50 free bytes, server is free to send up to 50 bytes in responses.
	//  3. Client processes 100 bytes from buffer, now buffer free space is 150 bytes,
	//     so client sends ReadRequest with bytes_size = 100;
	//  4. Server is free to send up to 50 + 100 = 150 bytes. But the next read message is too big,
	//     and it sends 160 bytes ReadResponse.
	//  5. Let's assume client somehow processes it, and its 200 bytes buffer is free again.
	//     It should account for excess 10 bytes and send ReadRequest with bytes_size = 210.
	BytesSize *int64
}

func (b0 StreamReadMessage_ReadRequest_builder) Build() *StreamReadMessage_ReadRequest {
	m0 := &StreamReadMessage_ReadRequest{}
	b, x := &b0, m0
	_, _ = b, x
	x.BytesSize = b.BytesSize
	return m0
}

// Data read.
type StreamReadMessage_ReadResponse struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Client messages, divided by partitions.
	PartitionData []*StreamReadMessage_ReadResponse_PartitionData `protobuf:"bytes,1,rep,name=partition_data,json=partitionData" json:"partition_data,omitempty"`
	// Total size in bytes of this response as calculated by server.
	// See ReadRequest comment above.
	BytesSize     *int64 `protobuf:"varint,2,opt,name=bytes_size,json=bytesSize" json:"bytes_size,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamReadMessage_ReadResponse) Reset() {
	*x = StreamReadMessage_ReadResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[65]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_ReadResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_ReadResponse) ProtoMessage() {}

func (x *StreamReadMessage_ReadResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[65]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamReadMessage_ReadResponse) GetPartitionData() []*StreamReadMessage_ReadResponse_PartitionData {
	if x != nil {
		return x.PartitionData
	}
	return nil
}

func (x *StreamReadMessage_ReadResponse) GetBytesSize() int64 {
	if x != nil && x.BytesSize != nil {
		return *x.BytesSize
	}
	return 0
}

func (x *StreamReadMessage_ReadResponse) SetPartitionData(v []*StreamReadMessage_ReadResponse_PartitionData) {
	x.PartitionData = v
}

func (x *StreamReadMessage_ReadResponse) SetBytesSize(v int64) {
	x.BytesSize = &v
}

func (x *StreamReadMessage_ReadResponse) HasBytesSize() bool {
	if x == nil {
		return false
	}
	return x.BytesSize != nil
}

func (x *StreamReadMessage_ReadResponse) ClearBytesSize() {
	x.BytesSize = nil
}

type StreamReadMessage_ReadResponse_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Client messages, divided by partitions.
	PartitionData []*StreamReadMessage_ReadResponse_PartitionData
	// Total size in bytes of this response as calculated by server.
	// See ReadRequest comment above.
	BytesSize *int64
}

func (b0 StreamReadMessage_ReadResponse_builder) Build() *StreamReadMessage_ReadResponse {
	m0 := &StreamReadMessage_ReadResponse{}
	b, x := &b0, m0
	_, _ = b, x
	x.PartitionData = b.PartitionData
	x.BytesSize = b.BytesSize
	return m0
}

// Signal for server that client processed some read data.
type StreamReadMessage_CommitOffsetRequest struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Partition offsets that indicates processed data.
	CommitOffsets []*StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset `protobuf:"bytes,1,rep,name=commit_offsets,json=commitOffsets" json:"commit_offsets,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamReadMessage_CommitOffsetRequest) Reset() {
	*x = StreamReadMessage_CommitOffsetRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[66]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_CommitOffsetRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_CommitOffsetRequest) ProtoMessage() {}

func (x *StreamReadMessage_CommitOffsetRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[66]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamReadMessage_CommitOffsetRequest) GetCommitOffsets() []*StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset {
	if x != nil {
		return x.CommitOffsets
	}
	return nil
}

func (x *StreamReadMessage_CommitOffsetRequest) SetCommitOffsets(v []*StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset) {
	x.CommitOffsets = v
}

type StreamReadMessage_CommitOffsetRequest_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Partition offsets that indicates processed data.
	CommitOffsets []*StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset
}

func (b0 StreamReadMessage_CommitOffsetRequest_builder) Build() *StreamReadMessage_CommitOffsetRequest {
	m0 := &StreamReadMessage_CommitOffsetRequest{}
	b, x := &b0, m0
	_, _ = b, x
	x.CommitOffsets = b.CommitOffsets
	return m0
}

// Acknowledgement for commits.
type StreamReadMessage_CommitOffsetResponse struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Partitions with progress.
	PartitionsCommittedOffsets []*StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset `protobuf:"bytes,1,rep,name=partitions_committed_offsets,json=partitionsCommittedOffsets" json:"partitions_committed_offsets,omitempty"`
	unknownFields              protoimpl.UnknownFields
	sizeCache                  protoimpl.SizeCache
}

func (x *StreamReadMessage_CommitOffsetResponse) Reset() {
	*x = StreamReadMessage_CommitOffsetResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[67]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_CommitOffsetResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_CommitOffsetResponse) ProtoMessage() {}

func (x *StreamReadMessage_CommitOffsetResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[67]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamReadMessage_CommitOffsetResponse) GetPartitionsCommittedOffsets() []*StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset {
	if x != nil {
		return x.PartitionsCommittedOffsets
	}
	return nil
}

func (x *StreamReadMessage_CommitOffsetResponse) SetPartitionsCommittedOffsets(v []*StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset) {
	x.PartitionsCommittedOffsets = v
}

type StreamReadMessage_CommitOffsetResponse_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Partitions with progress.
	PartitionsCommittedOffsets []*StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset
}

func (b0 StreamReadMessage_CommitOffsetResponse_builder) Build() *StreamReadMessage_CommitOffsetResponse {
	m0 := &StreamReadMessage_CommitOffsetResponse{}
	b, x := &b0, m0
	_, _ = b, x
	x.PartitionsCommittedOffsets = b.PartitionsCommittedOffsets
	return m0
}

type StreamReadMessage_PartitionSessionStatusRequest struct {
	state              protoimpl.MessageState `protogen:"hybrid.v1"`
	PartitionSessionId *int64                 `protobuf:"varint,1,opt,name=partition_session_id,json=partitionSessionId" json:"partition_session_id,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *StreamReadMessage_PartitionSessionStatusRequest) Reset() {
	*x = StreamReadMessage_PartitionSessionStatusRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[68]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_PartitionSessionStatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_PartitionSessionStatusRequest) ProtoMessage() {}

func (x *StreamReadMessage_PartitionSessionStatusRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[68]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamReadMessage_PartitionSessionStatusRequest) GetPartitionSessionId() int64 {
	if x != nil && x.PartitionSessionId != nil {
		return *x.PartitionSessionId
	}
	return 0
}

func (x *StreamReadMessage_PartitionSessionStatusRequest) SetPartitionSessionId(v int64) {
	x.PartitionSessionId = &v
}

func (x *StreamReadMessage_PartitionSessionStatusRequest) HasPartitionSessionId() bool {
	if x == nil {
		return false
	}
	return x.PartitionSessionId != nil
}

func (x *StreamReadMessage_PartitionSessionStatusRequest) ClearPartitionSessionId() {
	x.PartitionSessionId = nil
}

type StreamReadMessage_PartitionSessionStatusRequest_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	PartitionSessionId *int64
}

func (b0 StreamReadMessage_PartitionSessionStatusRequest_builder) Build() *StreamReadMessage_PartitionSessionStatusRequest {
	m0 := &StreamReadMessage_PartitionSessionStatusRequest{}
	b, x := &b0, m0
	_, _ = b, x
	x.PartitionSessionId = b.PartitionSessionId
	return m0
}

// Response to status request.
type StreamReadMessage_PartitionSessionStatusResponse struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Identifier of partition session whose status was requested.
	PartitionSessionId *int64 `protobuf:"varint,1,opt,name=partition_session_id,json=partitionSessionId" json:"partition_session_id,omitempty"`
	// Partition contains messages with offsets in range [start, end).
	PartitionOffsets *OffsetsRange `protobuf:"bytes,2,opt,name=partition_offsets,json=partitionOffsets" json:"partition_offsets,omitempty"`
	// Each offset up to and including (committed_offset - 1) was fully processed.
	CommittedOffset *int64 `protobuf:"varint,3,opt,name=committed_offset,json=committedOffset" json:"committed_offset,omitempty"`
	// Write timestamp of next message written to this partition will be no less than write_time_high_watermark.
	WriteTimeHighWatermark *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=write_time_high_watermark,json=writeTimeHighWatermark" json:"write_time_high_watermark,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *StreamReadMessage_PartitionSessionStatusResponse) Reset() {
	*x = StreamReadMessage_PartitionSessionStatusResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[69]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_PartitionSessionStatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_PartitionSessionStatusResponse) ProtoMessage() {}

func (x *StreamReadMessage_PartitionSessionStatusResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[69]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamReadMessage_PartitionSessionStatusResponse) GetPartitionSessionId() int64 {
	if x != nil && x.PartitionSessionId != nil {
		return *x.PartitionSessionId
	}
	return 0
}

func (x *StreamReadMessage_PartitionSessionStatusResponse) GetPartitionOffsets() *OffsetsRange {
	if x != nil {
		return x.PartitionOffsets
	}
	return nil
}

func (x *StreamReadMessage_PartitionSessionStatusResponse) GetCommittedOffset() int64 {
	if x != nil && x.CommittedOffset != nil {
		return *x.CommittedOffset
	}
	return 0
}

func (x *StreamReadMessage_PartitionSessionStatusResponse) GetWriteTimeHighWatermark() *timestamppb.Timestamp {
	if x != nil {
		return x.WriteTimeHighWatermark
	}
	return nil
}

func (x *StreamReadMessage_PartitionSessionStatusResponse) SetPartitionSessionId(v int64) {
	x.PartitionSessionId = &v
}

func (x *StreamReadMessage_PartitionSessionStatusResponse) SetPartitionOffsets(v *OffsetsRange) {
	x.PartitionOffsets = v
}

func (x *StreamReadMessage_PartitionSessionStatusResponse) SetCommittedOffset(v int64) {
	x.CommittedOffset = &v
}

func (x *StreamReadMessage_PartitionSessionStatusResponse) SetWriteTimeHighWatermark(v *timestamppb.Timestamp) {
	x.WriteTimeHighWatermark = v
}

func (x *StreamReadMessage_PartitionSessionStatusResponse) HasPartitionSessionId() bool {
	if x == nil {
		return false
	}
	return x.PartitionSessionId != nil
}

func (x *StreamReadMessage_PartitionSessionStatusResponse) HasPartitionOffsets() bool {
	if x == nil {
		return false
	}
	return x.PartitionOffsets != nil
}

func (x *StreamReadMessage_PartitionSessionStatusResponse) HasCommittedOffset() bool {
	if x == nil {
		return false
	}
	return x.CommittedOffset != nil
}

func (x *StreamReadMessage_PartitionSessionStatusResponse) HasWriteTimeHighWatermark() bool {
	if x == nil {
		return false
	}
	return x.WriteTimeHighWatermark != nil
}

func (x *StreamReadMessage_PartitionSessionStatusResponse) ClearPartitionSessionId() {
	x.PartitionSessionId = nil
}

func (x *StreamReadMessage_PartitionSessionStatusResponse) ClearPartitionOffsets() {
	x.PartitionOffsets = nil
}

func (x *StreamReadMessage_PartitionSessionStatusResponse) ClearCommittedOffset() {
	x.CommittedOffset = nil
}

func (x *StreamReadMessage_PartitionSessionStatusResponse) ClearWriteTimeHighWatermark() {
	x.WriteTimeHighWatermark = nil
}

type StreamReadMessage_PartitionSessionStatusResponse_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Identifier of partition session whose status was requested.
	PartitionSessionId *int64
	// Partition contains messages with offsets in range [start, end).
	PartitionOffsets *OffsetsRange
	// Each offset up to and including (committed_offset - 1) was fully processed.
	CommittedOffset *int64
	// Write timestamp of next message written to this partition will be no less than write_time_high_watermark.
	WriteTimeHighWatermark *timestamppb.Timestamp
}

func (b0 StreamReadMessage_PartitionSessionStatusResponse_builder) Build() *StreamReadMessage_PartitionSessionStatusResponse {
	m0 := &StreamReadMessage_PartitionSessionStatusResponse{}
	b, x := &b0, m0
	_, _ = b, x
	x.PartitionSessionId = b.PartitionSessionId
	x.PartitionOffsets = b.PartitionOffsets
	x.CommittedOffset = b.CommittedOffset
	x.WriteTimeHighWatermark = b.WriteTimeHighWatermark
	return m0
}

// Command from server to create and start a partition session.
// Client must respond with StartPartitionSessionResponse when ready to receive data from this partition.
type StreamReadMessage_StartPartitionSessionRequest struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Partition session description.
	PartitionSession *StreamReadMessage_PartitionSession `protobuf:"bytes,1,opt,name=partition_session,json=partitionSession" json:"partition_session,omitempty"`
	// Each offset up to and including (committed_offset - 1) was fully processed.
	CommittedOffset *int64 `protobuf:"varint,2,opt,name=committed_offset,json=committedOffset" json:"committed_offset,omitempty"`
	// Partition contains messages with offsets in range [start, end).
	PartitionOffsets *OffsetsRange `protobuf:"bytes,3,opt,name=partition_offsets,json=partitionOffsets" json:"partition_offsets,omitempty"`
	// Partition location, filled only when InitRequest.direct_read is true.
	PartitionLocation *PartitionLocation `protobuf:"bytes,4,opt,name=partition_location,json=partitionLocation" json:"partition_location,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *StreamReadMessage_StartPartitionSessionRequest) Reset() {
	*x = StreamReadMessage_StartPartitionSessionRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[70]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_StartPartitionSessionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_StartPartitionSessionRequest) ProtoMessage() {}

func (x *StreamReadMessage_StartPartitionSessionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[70]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamReadMessage_StartPartitionSessionRequest) GetPartitionSession() *StreamReadMessage_PartitionSession {
	if x != nil {
		return x.PartitionSession
	}
	return nil
}

func (x *StreamReadMessage_StartPartitionSessionRequest) GetCommittedOffset() int64 {
	if x != nil && x.CommittedOffset != nil {
		return *x.CommittedOffset
	}
	return 0
}

func (x *StreamReadMessage_StartPartitionSessionRequest) GetPartitionOffsets() *OffsetsRange {
	if x != nil {
		return x.PartitionOffsets
	}
	return nil
}

func (x *StreamReadMessage_StartPartitionSessionRequest) GetPartitionLocation() *PartitionLocation {
	if x != nil {
		return x.PartitionLocation
	}
	return nil
}

func (x *StreamReadMessage_StartPartitionSessionRequest) SetPartitionSession(v *StreamReadMessage_PartitionSession) {
	x.PartitionSession = v
}

func (x *StreamReadMessage_StartPartitionSessionRequest) SetCommittedOffset(v int64) {
	x.CommittedOffset = &v
}

func (x *StreamReadMessage_StartPartitionSessionRequest) SetPartitionOffsets(v *OffsetsRange) {
	x.PartitionOffsets = v
}

func (x *StreamReadMessage_StartPartitionSessionRequest) SetPartitionLocation(v *PartitionLocation) {
	x.PartitionLocation = v
}

func (x *StreamReadMessage_StartPartitionSessionRequest) HasPartitionSession() bool {
	if x == nil {
		return false
	}
	return x.PartitionSession != nil
}

func (x *StreamReadMessage_StartPartitionSessionRequest) HasCommittedOffset() bool {
	if x == nil {
		return false
	}
	return x.CommittedOffset != nil
}

func (x *StreamReadMessage_StartPartitionSessionRequest) HasPartitionOffsets() bool {
	if x == nil {
		return false
	}
	return x.PartitionOffsets != nil
}

func (x *StreamReadMessage_StartPartitionSessionRequest) HasPartitionLocation() bool {
	if x == nil {
		return false
	}
	return x.PartitionLocation != nil
}

func (x *StreamReadMessage_StartPartitionSessionRequest) ClearPartitionSession() {
	x.PartitionSession = nil
}

func (x *StreamReadMessage_StartPartitionSessionRequest) ClearCommittedOffset() {
	x.CommittedOffset = nil
}

func (x *StreamReadMessage_StartPartitionSessionRequest) ClearPartitionOffsets() {
	x.PartitionOffsets = nil
}

func (x *StreamReadMessage_StartPartitionSessionRequest) ClearPartitionLocation() {
	x.PartitionLocation = nil
}

type StreamReadMessage_StartPartitionSessionRequest_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Partition session description.
	PartitionSession *StreamReadMessage_PartitionSession
	// Each offset up to and including (committed_offset - 1) was fully processed.
	CommittedOffset *int64
	// Partition contains messages with offsets in range [start, end).
	PartitionOffsets *OffsetsRange
	// Partition location, filled only when InitRequest.direct_read is true.
	PartitionLocation *PartitionLocation
}

func (b0 StreamReadMessage_StartPartitionSessionRequest_builder) Build() *StreamReadMessage_StartPartitionSessionRequest {
	m0 := &StreamReadMessage_StartPartitionSessionRequest{}
	b, x := &b0, m0
	_, _ = b, x
	x.PartitionSession = b.PartitionSession
	x.CommittedOffset = b.CommittedOffset
	x.PartitionOffsets = b.PartitionOffsets
	x.PartitionLocation = b.PartitionLocation
	return m0
}

// Signal for server that client is ready to recive data for partition.
type StreamReadMessage_StartPartitionSessionResponse struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Partition session identifier of partition to start read.
	PartitionSessionId *int64 `protobuf:"varint,1,opt,name=partition_session_id,json=partitionSessionId" json:"partition_session_id,omitempty"`
	// Reads in this partition session will start from offset no less than read_offset.
	// If read_offset is set, server will check that read_offset is no less that actual committed offset.
	// If check fails then server will send an error message (status != SUCCESS) and close stream.
	//
	// If read_offset is not set, no check will be made.
	// InitRequest.max_lag and InitRequest.read_from could lead to skip of more messages.
	// Server will return data starting from offset that is maximum of actual committed offset, read_offset (if set)
	// and offsets calculated from InitRequest.max_lag and InitRequest.read_from.
	ReadOffset *int64 `protobuf:"varint,2,opt,name=read_offset,json=readOffset" json:"read_offset,omitempty"`
	// All messages with offset less than commit_offset are processed by client.
	// Server will commit this position if this is not done yet.
	CommitOffset  *int64 `protobuf:"varint,3,opt,name=commit_offset,json=commitOffset" json:"commit_offset,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamReadMessage_StartPartitionSessionResponse) Reset() {
	*x = StreamReadMessage_StartPartitionSessionResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[71]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_StartPartitionSessionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_StartPartitionSessionResponse) ProtoMessage() {}

func (x *StreamReadMessage_StartPartitionSessionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[71]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamReadMessage_StartPartitionSessionResponse) GetPartitionSessionId() int64 {
	if x != nil && x.PartitionSessionId != nil {
		return *x.PartitionSessionId
	}
	return 0
}

func (x *StreamReadMessage_StartPartitionSessionResponse) GetReadOffset() int64 {
	if x != nil && x.ReadOffset != nil {
		return *x.ReadOffset
	}
	return 0
}

func (x *StreamReadMessage_StartPartitionSessionResponse) GetCommitOffset() int64 {
	if x != nil && x.CommitOffset != nil {
		return *x.CommitOffset
	}
	return 0
}

func (x *StreamReadMessage_StartPartitionSessionResponse) SetPartitionSessionId(v int64) {
	x.PartitionSessionId = &v
}

func (x *StreamReadMessage_StartPartitionSessionResponse) SetReadOffset(v int64) {
	x.ReadOffset = &v
}

func (x *StreamReadMessage_StartPartitionSessionResponse) SetCommitOffset(v int64) {
	x.CommitOffset = &v
}

func (x *StreamReadMessage_StartPartitionSessionResponse) HasPartitionSessionId() bool {
	if x == nil {
		return false
	}
	return x.PartitionSessionId != nil
}

func (x *StreamReadMessage_StartPartitionSessionResponse) HasReadOffset() bool {
	if x == nil {
		return false
	}
	return x.ReadOffset != nil
}

func (x *StreamReadMessage_StartPartitionSessionResponse) HasCommitOffset() bool {
	if x == nil {
		return false
	}
	return x.CommitOffset != nil
}

func (x *StreamReadMessage_StartPartitionSessionResponse) ClearPartitionSessionId() {
	x.PartitionSessionId = nil
}

func (x *StreamReadMessage_StartPartitionSessionResponse) ClearReadOffset() {
	x.ReadOffset = nil
}

func (x *StreamReadMessage_StartPartitionSessionResponse) ClearCommitOffset() {
	x.CommitOffset = nil
}

type StreamReadMessage_StartPartitionSessionResponse_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Partition session identifier of partition to start read.
	PartitionSessionId *int64
	// Reads in this partition session will start from offset no less than read_offset.
	// If read_offset is set, server will check that read_offset is no less that actual committed offset.
	// If check fails then server will send an error message (status != SUCCESS) and close stream.
	//
	// If read_offset is not set, no check will be made.
	// InitRequest.max_lag and InitRequest.read_from could lead to skip of more messages.
	// Server will return data starting from offset that is maximum of actual committed offset, read_offset (if set)
	// and offsets calculated from InitRequest.max_lag and InitRequest.read_from.
	ReadOffset *int64
	// All messages with offset less than commit_offset are processed by client.
	// Server will commit this position if this is not done yet.
	CommitOffset *int64
}

func (b0 StreamReadMessage_StartPartitionSessionResponse_builder) Build() *StreamReadMessage_StartPartitionSessionResponse {
	m0 := &StreamReadMessage_StartPartitionSessionResponse{}
	b, x := &b0, m0
	_, _ = b, x
	x.PartitionSessionId = b.PartitionSessionId
	x.ReadOffset = b.ReadOffset
	x.CommitOffset = b.CommitOffset
	return m0
}

// Command from server to stop and destroy concrete partition session.
type StreamReadMessage_StopPartitionSessionRequest struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Identifier of partition session that is ready to be closed by server.
	PartitionSessionId *int64 `protobuf:"varint,1,opt,name=partition_session_id,json=partitionSessionId" json:"partition_session_id,omitempty"`
	// Flag of graceful stop.
	// If set, server will wait for response from client before giving this partition to other read session.
	// Server will not send more data from this partition.
	// Client can process all received data and wait for commit and only after send response.
	// If False then server gives partition for other session right now.
	// All further commits for this partition session has no effect. Server is not waiting for response.
	Graceful *bool `protobuf:"varint,2,opt,name=graceful" json:"graceful,omitempty"`
	// Upper bound for committed offsets.
	CommittedOffset *int64 `protobuf:"varint,3,opt,name=committed_offset,json=committedOffset" json:"committed_offset,omitempty"`
	// Upper bound for read request identifiers, filled only when InitRequest.direct_read is true and graceful is true.
	LastDirectReadId *int64 `protobuf:"varint,4,opt,name=last_direct_read_id,json=lastDirectReadId" json:"last_direct_read_id,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *StreamReadMessage_StopPartitionSessionRequest) Reset() {
	*x = StreamReadMessage_StopPartitionSessionRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[72]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_StopPartitionSessionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_StopPartitionSessionRequest) ProtoMessage() {}

func (x *StreamReadMessage_StopPartitionSessionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[72]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamReadMessage_StopPartitionSessionRequest) GetPartitionSessionId() int64 {
	if x != nil && x.PartitionSessionId != nil {
		return *x.PartitionSessionId
	}
	return 0
}

func (x *StreamReadMessage_StopPartitionSessionRequest) GetGraceful() bool {
	if x != nil && x.Graceful != nil {
		return *x.Graceful
	}
	return false
}

func (x *StreamReadMessage_StopPartitionSessionRequest) GetCommittedOffset() int64 {
	if x != nil && x.CommittedOffset != nil {
		return *x.CommittedOffset
	}
	return 0
}

func (x *StreamReadMessage_StopPartitionSessionRequest) GetLastDirectReadId() int64 {
	if x != nil && x.LastDirectReadId != nil {
		return *x.LastDirectReadId
	}
	return 0
}

func (x *StreamReadMessage_StopPartitionSessionRequest) SetPartitionSessionId(v int64) {
	x.PartitionSessionId = &v
}

func (x *StreamReadMessage_StopPartitionSessionRequest) SetGraceful(v bool) {
	x.Graceful = &v
}

func (x *StreamReadMessage_StopPartitionSessionRequest) SetCommittedOffset(v int64) {
	x.CommittedOffset = &v
}

func (x *StreamReadMessage_StopPartitionSessionRequest) SetLastDirectReadId(v int64) {
	x.LastDirectReadId = &v
}

func (x *StreamReadMessage_StopPartitionSessionRequest) HasPartitionSessionId() bool {
	if x == nil {
		return false
	}
	return x.PartitionSessionId != nil
}

func (x *StreamReadMessage_StopPartitionSessionRequest) HasGraceful() bool {
	if x == nil {
		return false
	}
	return x.Graceful != nil
}

func (x *StreamReadMessage_StopPartitionSessionRequest) HasCommittedOffset() bool {
	if x == nil {
		return false
	}
	return x.CommittedOffset != nil
}

func (x *StreamReadMessage_StopPartitionSessionRequest) HasLastDirectReadId() bool {
	if x == nil {
		return false
	}
	return x.LastDirectReadId != nil
}

func (x *StreamReadMessage_StopPartitionSessionRequest) ClearPartitionSessionId() {
	x.PartitionSessionId = nil
}

func (x *StreamReadMessage_StopPartitionSessionRequest) ClearGraceful() {
	x.Graceful = nil
}

func (x *StreamReadMessage_StopPartitionSessionRequest) ClearCommittedOffset() {
	x.CommittedOffset = nil
}

func (x *StreamReadMessage_StopPartitionSessionRequest) ClearLastDirectReadId() {
	x.LastDirectReadId = nil
}

type StreamReadMessage_StopPartitionSessionRequest_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Identifier of partition session that is ready to be closed by server.
	PartitionSessionId *int64
	// Flag of graceful stop.
	// If set, server will wait for response from client before giving this partition to other read session.
	// Server will not send more data from this partition.
	// Client can process all received data and wait for commit and only after send response.
	// If False then server gives partition for other session right now.
	// All further commits for this partition session has no effect. Server is not waiting for response.
	Graceful *bool
	// Upper bound for committed offsets.
	CommittedOffset *int64
	// Upper bound for read request identifiers, filled only when InitRequest.direct_read is true and graceful is true.
	LastDirectReadId *int64
}

func (b0 StreamReadMessage_StopPartitionSessionRequest_builder) Build() *StreamReadMessage_StopPartitionSessionRequest {
	m0 := &StreamReadMessage_StopPartitionSessionRequest{}
	b, x := &b0, m0
	_, _ = b, x
	x.PartitionSessionId = b.PartitionSessionId
	x.Graceful = b.Graceful
	x.CommittedOffset = b.CommittedOffset
	x.LastDirectReadId = b.LastDirectReadId
	return m0
}

// Signal for server that client finished working with this partition.
// Must be sent only after corresponding StopPartitionSessionRequest from server.
// Server will give this partition to other read session only after StopPartitionSessionResponse signal.
type StreamReadMessage_StopPartitionSessionResponse struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Partition session identifier of partition session that is released by client.
	PartitionSessionId *int64 `protobuf:"varint,1,opt,name=partition_session_id,json=partitionSessionId" json:"partition_session_id,omitempty"`
	// Flag of graceful stop, used only when InitRequest.direct_read is true
	// Client must pass this value unchanged from the StopPartitionSessionRequest.
	// Server can sent two StopPartitionSessionRequests, the first with graceful=true, the second with graceful=false. The client must answer both of them.
	Graceful      *bool `protobuf:"varint,2,opt,name=graceful" json:"graceful,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamReadMessage_StopPartitionSessionResponse) Reset() {
	*x = StreamReadMessage_StopPartitionSessionResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[73]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_StopPartitionSessionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_StopPartitionSessionResponse) ProtoMessage() {}

func (x *StreamReadMessage_StopPartitionSessionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[73]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamReadMessage_StopPartitionSessionResponse) GetPartitionSessionId() int64 {
	if x != nil && x.PartitionSessionId != nil {
		return *x.PartitionSessionId
	}
	return 0
}

func (x *StreamReadMessage_StopPartitionSessionResponse) GetGraceful() bool {
	if x != nil && x.Graceful != nil {
		return *x.Graceful
	}
	return false
}

func (x *StreamReadMessage_StopPartitionSessionResponse) SetPartitionSessionId(v int64) {
	x.PartitionSessionId = &v
}

func (x *StreamReadMessage_StopPartitionSessionResponse) SetGraceful(v bool) {
	x.Graceful = &v
}

func (x *StreamReadMessage_StopPartitionSessionResponse) HasPartitionSessionId() bool {
	if x == nil {
		return false
	}
	return x.PartitionSessionId != nil
}

func (x *StreamReadMessage_StopPartitionSessionResponse) HasGraceful() bool {
	if x == nil {
		return false
	}
	return x.Graceful != nil
}

func (x *StreamReadMessage_StopPartitionSessionResponse) ClearPartitionSessionId() {
	x.PartitionSessionId = nil
}

func (x *StreamReadMessage_StopPartitionSessionResponse) ClearGraceful() {
	x.Graceful = nil
}

type StreamReadMessage_StopPartitionSessionResponse_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Partition session identifier of partition session that is released by client.
	PartitionSessionId *int64
	// Flag of graceful stop, used only when InitRequest.direct_read is true
	// Client must pass this value unchanged from the StopPartitionSessionRequest.
	// Server can sent two StopPartitionSessionRequests, the first with graceful=true, the second with graceful=false. The client must answer both of them.
	Graceful *bool
}

func (b0 StreamReadMessage_StopPartitionSessionResponse_builder) Build() *StreamReadMessage_StopPartitionSessionResponse {
	m0 := &StreamReadMessage_StopPartitionSessionResponse{}
	b, x := &b0, m0
	_, _ = b, x
	x.PartitionSessionId = b.PartitionSessionId
	x.Graceful = b.Graceful
	return m0
}

// Command from server to notify about a partition session update.
// Client should not send a response to the command.
type StreamReadMessage_UpdatePartitionSession struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Partition session identifier.
	PartitionSessionId *int64 `protobuf:"varint,1,opt,name=partition_session_id,json=partitionSessionId" json:"partition_session_id,omitempty"`
	// Partition location, filled only when InitRequest.direct_read is true.
	PartitionLocation *PartitionLocation `protobuf:"bytes,2,opt,name=partition_location,json=partitionLocation" json:"partition_location,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *StreamReadMessage_UpdatePartitionSession) Reset() {
	*x = StreamReadMessage_UpdatePartitionSession{}
	mi := &file_protos_ydb_topic_proto_msgTypes[74]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_UpdatePartitionSession) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_UpdatePartitionSession) ProtoMessage() {}

func (x *StreamReadMessage_UpdatePartitionSession) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[74]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamReadMessage_UpdatePartitionSession) GetPartitionSessionId() int64 {
	if x != nil && x.PartitionSessionId != nil {
		return *x.PartitionSessionId
	}
	return 0
}

func (x *StreamReadMessage_UpdatePartitionSession) GetPartitionLocation() *PartitionLocation {
	if x != nil {
		return x.PartitionLocation
	}
	return nil
}

func (x *StreamReadMessage_UpdatePartitionSession) SetPartitionSessionId(v int64) {
	x.PartitionSessionId = &v
}

func (x *StreamReadMessage_UpdatePartitionSession) SetPartitionLocation(v *PartitionLocation) {
	x.PartitionLocation = v
}

func (x *StreamReadMessage_UpdatePartitionSession) HasPartitionSessionId() bool {
	if x == nil {
		return false
	}
	return x.PartitionSessionId != nil
}

func (x *StreamReadMessage_UpdatePartitionSession) HasPartitionLocation() bool {
	if x == nil {
		return false
	}
	return x.PartitionLocation != nil
}

func (x *StreamReadMessage_UpdatePartitionSession) ClearPartitionSessionId() {
	x.PartitionSessionId = nil
}

func (x *StreamReadMessage_UpdatePartitionSession) ClearPartitionLocation() {
	x.PartitionLocation = nil
}

type StreamReadMessage_UpdatePartitionSession_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Partition session identifier.
	PartitionSessionId *int64
	// Partition location, filled only when InitRequest.direct_read is true.
	PartitionLocation *PartitionLocation
}

func (b0 StreamReadMessage_UpdatePartitionSession_builder) Build() *StreamReadMessage_UpdatePartitionSession {
	m0 := &StreamReadMessage_UpdatePartitionSession{}
	b, x := &b0, m0
	_, _ = b, x
	x.PartitionSessionId = b.PartitionSessionId
	x.PartitionLocation = b.PartitionLocation
	return m0
}

// Signal for server that client has finished direct reading.
// Server should not send a response to the command.
type StreamReadMessage_DirectReadAck struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Partition session identifier.
	PartitionSessionId *int64 `protobuf:"varint,1,opt,name=partition_session_id,json=partitionSessionId" json:"partition_session_id,omitempty"`
	// Identifier of the successfully completed read request.
	DirectReadId  *int64 `protobuf:"varint,2,opt,name=direct_read_id,json=directReadId" json:"direct_read_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamReadMessage_DirectReadAck) Reset() {
	*x = StreamReadMessage_DirectReadAck{}
	mi := &file_protos_ydb_topic_proto_msgTypes[75]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_DirectReadAck) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_DirectReadAck) ProtoMessage() {}

func (x *StreamReadMessage_DirectReadAck) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[75]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamReadMessage_DirectReadAck) GetPartitionSessionId() int64 {
	if x != nil && x.PartitionSessionId != nil {
		return *x.PartitionSessionId
	}
	return 0
}

func (x *StreamReadMessage_DirectReadAck) GetDirectReadId() int64 {
	if x != nil && x.DirectReadId != nil {
		return *x.DirectReadId
	}
	return 0
}

func (x *StreamReadMessage_DirectReadAck) SetPartitionSessionId(v int64) {
	x.PartitionSessionId = &v
}

func (x *StreamReadMessage_DirectReadAck) SetDirectReadId(v int64) {
	x.DirectReadId = &v
}

func (x *StreamReadMessage_DirectReadAck) HasPartitionSessionId() bool {
	if x == nil {
		return false
	}
	return x.PartitionSessionId != nil
}

func (x *StreamReadMessage_DirectReadAck) HasDirectReadId() bool {
	if x == nil {
		return false
	}
	return x.DirectReadId != nil
}

func (x *StreamReadMessage_DirectReadAck) ClearPartitionSessionId() {
	x.PartitionSessionId = nil
}

func (x *StreamReadMessage_DirectReadAck) ClearDirectReadId() {
	x.DirectReadId = nil
}

type StreamReadMessage_DirectReadAck_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Partition session identifier.
	PartitionSessionId *int64
	// Identifier of the successfully completed read request.
	DirectReadId *int64
}

func (b0 StreamReadMessage_DirectReadAck_builder) Build() *StreamReadMessage_DirectReadAck {
	m0 := &StreamReadMessage_DirectReadAck{}
	b, x := &b0, m0
	_, _ = b, x
	x.PartitionSessionId = b.PartitionSessionId
	x.DirectReadId = b.DirectReadId
	return m0
}

// Signal from server that client has finished reading the partition and all messages have been read.
// Once a partition has been finished no further messages will ever arrive to that partition.
// This command is a hint to the client to commit offsets, after which the child partitions will be balanced independently in different reading sessions.
// Unlike StopPartitionSessionRequest, the client does not have to close the reading session.
// Client should not send a response to the command.
type StreamReadMessage_EndPartitionSession struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Partition session identifier.
	PartitionSessionId *int64 `protobuf:"varint,1,opt,name=partition_session_id,json=partitionSessionId" json:"partition_session_id,omitempty"`
	// Ids of partitions which were merged with the ended partition.
	AdjacentPartitionIds []int64 `protobuf:"varint,2,rep,packed,name=adjacent_partition_ids,json=adjacentPartitionIds" json:"adjacent_partition_ids,omitempty"`
	// Ids of partitions which was formed when the ended partition was split or merged.
	ChildPartitionIds []int64 `protobuf:"varint,3,rep,packed,name=child_partition_ids,json=childPartitionIds" json:"child_partition_ids,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *StreamReadMessage_EndPartitionSession) Reset() {
	*x = StreamReadMessage_EndPartitionSession{}
	mi := &file_protos_ydb_topic_proto_msgTypes[76]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_EndPartitionSession) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_EndPartitionSession) ProtoMessage() {}

func (x *StreamReadMessage_EndPartitionSession) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[76]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamReadMessage_EndPartitionSession) GetPartitionSessionId() int64 {
	if x != nil && x.PartitionSessionId != nil {
		return *x.PartitionSessionId
	}
	return 0
}

func (x *StreamReadMessage_EndPartitionSession) GetAdjacentPartitionIds() []int64 {
	if x != nil {
		return x.AdjacentPartitionIds
	}
	return nil
}

func (x *StreamReadMessage_EndPartitionSession) GetChildPartitionIds() []int64 {
	if x != nil {
		return x.ChildPartitionIds
	}
	return nil
}

func (x *StreamReadMessage_EndPartitionSession) SetPartitionSessionId(v int64) {
	x.PartitionSessionId = &v
}

func (x *StreamReadMessage_EndPartitionSession) SetAdjacentPartitionIds(v []int64) {
	x.AdjacentPartitionIds = v
}

func (x *StreamReadMessage_EndPartitionSession) SetChildPartitionIds(v []int64) {
	x.ChildPartitionIds = v
}

func (x *StreamReadMessage_EndPartitionSession) HasPartitionSessionId() bool {
	if x == nil {
		return false
	}
	return x.PartitionSessionId != nil
}

func (x *StreamReadMessage_EndPartitionSession) ClearPartitionSessionId() {
	x.PartitionSessionId = nil
}

type StreamReadMessage_EndPartitionSession_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Partition session identifier.
	PartitionSessionId *int64
	// Ids of partitions which were merged with the ended partition.
	AdjacentPartitionIds []int64
	// Ids of partitions which was formed when the ended partition was split or merged.
	ChildPartitionIds []int64
}

func (b0 StreamReadMessage_EndPartitionSession_builder) Build() *StreamReadMessage_EndPartitionSession {
	m0 := &StreamReadMessage_EndPartitionSession{}
	b, x := &b0, m0
	_, _ = b, x
	x.PartitionSessionId = b.PartitionSessionId
	x.AdjacentPartitionIds = b.AdjacentPartitionIds
	x.ChildPartitionIds = b.ChildPartitionIds
	return m0
}

type StreamReadMessage_InitRequest_TopicReadSettings struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Topic path.
	Path *string `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	// Partitions that will be read by this session.
	// If list is empty - then session will read all partitions.
	PartitionIds []int64 `protobuf:"varint,2,rep,packed,name=partition_ids,json=partitionIds" json:"partition_ids,omitempty"`
	// Skip all messages that has write timestamp smaller than now - max_lag.
	// Zero means infinite lag.
	MaxLag *durationpb.Duration `protobuf:"bytes,3,opt,name=max_lag,json=maxLag" json:"max_lag,omitempty"`
	// Read data only after this timestamp from this topic.
	// Read only messages with 'written_at' value greater or equal than this timestamp.
	ReadFrom      *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=read_from,json=readFrom" json:"read_from,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamReadMessage_InitRequest_TopicReadSettings) Reset() {
	*x = StreamReadMessage_InitRequest_TopicReadSettings{}
	mi := &file_protos_ydb_topic_proto_msgTypes[77]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_InitRequest_TopicReadSettings) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_InitRequest_TopicReadSettings) ProtoMessage() {}

func (x *StreamReadMessage_InitRequest_TopicReadSettings) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[77]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamReadMessage_InitRequest_TopicReadSettings) GetPath() string {
	if x != nil && x.Path != nil {
		return *x.Path
	}
	return ""
}

func (x *StreamReadMessage_InitRequest_TopicReadSettings) GetPartitionIds() []int64 {
	if x != nil {
		return x.PartitionIds
	}
	return nil
}

func (x *StreamReadMessage_InitRequest_TopicReadSettings) GetMaxLag() *durationpb.Duration {
	if x != nil {
		return x.MaxLag
	}
	return nil
}

func (x *StreamReadMessage_InitRequest_TopicReadSettings) GetReadFrom() *timestamppb.Timestamp {
	if x != nil {
		return x.ReadFrom
	}
	return nil
}

func (x *StreamReadMessage_InitRequest_TopicReadSettings) SetPath(v string) {
	x.Path = &v
}

func (x *StreamReadMessage_InitRequest_TopicReadSettings) SetPartitionIds(v []int64) {
	x.PartitionIds = v
}

func (x *StreamReadMessage_InitRequest_TopicReadSettings) SetMaxLag(v *durationpb.Duration) {
	x.MaxLag = v
}

func (x *StreamReadMessage_InitRequest_TopicReadSettings) SetReadFrom(v *timestamppb.Timestamp) {
	x.ReadFrom = v
}

func (x *StreamReadMessage_InitRequest_TopicReadSettings) HasPath() bool {
	if x == nil {
		return false
	}
	return x.Path != nil
}

func (x *StreamReadMessage_InitRequest_TopicReadSettings) HasMaxLag() bool {
	if x == nil {
		return false
	}
	return x.MaxLag != nil
}

func (x *StreamReadMessage_InitRequest_TopicReadSettings) HasReadFrom() bool {
	if x == nil {
		return false
	}
	return x.ReadFrom != nil
}

func (x *StreamReadMessage_InitRequest_TopicReadSettings) ClearPath() {
	x.Path = nil
}

func (x *StreamReadMessage_InitRequest_TopicReadSettings) ClearMaxLag() {
	x.MaxLag = nil
}

func (x *StreamReadMessage_InitRequest_TopicReadSettings) ClearReadFrom() {
	x.ReadFrom = nil
}

type StreamReadMessage_InitRequest_TopicReadSettings_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Topic path.
	Path *string
	// Partitions that will be read by this session.
	// If list is empty - then session will read all partitions.
	PartitionIds []int64
	// Skip all messages that has write timestamp smaller than now - max_lag.
	// Zero means infinite lag.
	MaxLag *durationpb.Duration
	// Read data only after this timestamp from this topic.
	// Read only messages with 'written_at' value greater or equal than this timestamp.
	ReadFrom *timestamppb.Timestamp
}

func (b0 StreamReadMessage_InitRequest_TopicReadSettings_builder) Build() *StreamReadMessage_InitRequest_TopicReadSettings {
	m0 := &StreamReadMessage_InitRequest_TopicReadSettings{}
	b, x := &b0, m0
	_, _ = b, x
	x.Path = b.Path
	x.PartitionIds = b.PartitionIds
	x.MaxLag = b.MaxLag
	x.ReadFrom = b.ReadFrom
	return m0
}

// One client message representation.
type StreamReadMessage_ReadResponse_MessageData struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Partition offset in partition that assigned for message.
	Offset *int64 `protobuf:"varint,1,opt,name=offset" json:"offset,omitempty"` //unique value for client side deduplication - Topic:Partition:Offset
	// Sequence number that provided with message on write from client.
	SeqNo *int64 `protobuf:"varint,2,opt,name=seq_no,json=seqNo" json:"seq_no,omitempty"`
	// Timestamp of creation of message provided on write from client.
	CreatedAt *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=created_at,json=createdAt" json:"created_at,omitempty"`
	// Compressed client message body.
	Data []byte `protobuf:"bytes,5,opt,name=data" json:"data,omitempty"`
	// Uncompressed size of client message body.
	// sent as is from WriteRequest, without check on server side. May be empty (for writes from old client) or wrong (if bug in writer).
	// Use it for optimization purposes only, don't trust it.
	UncompressedSize *int64 `protobuf:"varint,6,opt,name=uncompressed_size,json=uncompressedSize" json:"uncompressed_size,omitempty"`
	// Filled if message_group_id was set on message write.
	MessageGroupId *string         `protobuf:"bytes,7,opt,name=message_group_id,json=messageGroupId" json:"message_group_id,omitempty"`
	MetadataItems  []*MetadataItem `protobuf:"bytes,8,rep,name=metadata_items,json=metadataItems" json:"metadata_items,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *StreamReadMessage_ReadResponse_MessageData) Reset() {
	*x = StreamReadMessage_ReadResponse_MessageData{}
	mi := &file_protos_ydb_topic_proto_msgTypes[78]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_ReadResponse_MessageData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_ReadResponse_MessageData) ProtoMessage() {}

func (x *StreamReadMessage_ReadResponse_MessageData) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[78]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamReadMessage_ReadResponse_MessageData) GetOffset() int64 {
	if x != nil && x.Offset != nil {
		return *x.Offset
	}
	return 0
}

func (x *StreamReadMessage_ReadResponse_MessageData) GetSeqNo() int64 {
	if x != nil && x.SeqNo != nil {
		return *x.SeqNo
	}
	return 0
}

func (x *StreamReadMessage_ReadResponse_MessageData) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

func (x *StreamReadMessage_ReadResponse_MessageData) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *StreamReadMessage_ReadResponse_MessageData) GetUncompressedSize() int64 {
	if x != nil && x.UncompressedSize != nil {
		return *x.UncompressedSize
	}
	return 0
}

func (x *StreamReadMessage_ReadResponse_MessageData) GetMessageGroupId() string {
	if x != nil && x.MessageGroupId != nil {
		return *x.MessageGroupId
	}
	return ""
}

func (x *StreamReadMessage_ReadResponse_MessageData) GetMetadataItems() []*MetadataItem {
	if x != nil {
		return x.MetadataItems
	}
	return nil
}

func (x *StreamReadMessage_ReadResponse_MessageData) SetOffset(v int64) {
	x.Offset = &v
}

func (x *StreamReadMessage_ReadResponse_MessageData) SetSeqNo(v int64) {
	x.SeqNo = &v
}

func (x *StreamReadMessage_ReadResponse_MessageData) SetCreatedAt(v *timestamppb.Timestamp) {
	x.CreatedAt = v
}

func (x *StreamReadMessage_ReadResponse_MessageData) SetData(v []byte) {
	if v == nil {
		v = []byte{}
	}
	x.Data = v
}

func (x *StreamReadMessage_ReadResponse_MessageData) SetUncompressedSize(v int64) {
	x.UncompressedSize = &v
}

func (x *StreamReadMessage_ReadResponse_MessageData) SetMessageGroupId(v string) {
	x.MessageGroupId = &v
}

func (x *StreamReadMessage_ReadResponse_MessageData) SetMetadataItems(v []*MetadataItem) {
	x.MetadataItems = v
}

func (x *StreamReadMessage_ReadResponse_MessageData) HasOffset() bool {
	if x == nil {
		return false
	}
	return x.Offset != nil
}

func (x *StreamReadMessage_ReadResponse_MessageData) HasSeqNo() bool {
	if x == nil {
		return false
	}
	return x.SeqNo != nil
}

func (x *StreamReadMessage_ReadResponse_MessageData) HasCreatedAt() bool {
	if x == nil {
		return false
	}
	return x.CreatedAt != nil
}

func (x *StreamReadMessage_ReadResponse_MessageData) HasData() bool {
	if x == nil {
		return false
	}
	return x.Data != nil
}

func (x *StreamReadMessage_ReadResponse_MessageData) HasUncompressedSize() bool {
	if x == nil {
		return false
	}
	return x.UncompressedSize != nil
}

func (x *StreamReadMessage_ReadResponse_MessageData) HasMessageGroupId() bool {
	if x == nil {
		return false
	}
	return x.MessageGroupId != nil
}

func (x *StreamReadMessage_ReadResponse_MessageData) ClearOffset() {
	x.Offset = nil
}

func (x *StreamReadMessage_ReadResponse_MessageData) ClearSeqNo() {
	x.SeqNo = nil
}

func (x *StreamReadMessage_ReadResponse_MessageData) ClearCreatedAt() {
	x.CreatedAt = nil
}

func (x *StreamReadMessage_ReadResponse_MessageData) ClearData() {
	x.Data = nil
}

func (x *StreamReadMessage_ReadResponse_MessageData) ClearUncompressedSize() {
	x.UncompressedSize = nil
}

func (x *StreamReadMessage_ReadResponse_MessageData) ClearMessageGroupId() {
	x.MessageGroupId = nil
}

type StreamReadMessage_ReadResponse_MessageData_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Partition offset in partition that assigned for message.
	Offset *int64
	// Sequence number that provided with message on write from client.
	SeqNo *int64
	// Timestamp of creation of message provided on write from client.
	CreatedAt *timestamppb.Timestamp
	// Compressed client message body.
	Data []byte
	// Uncompressed size of client message body.
	// sent as is from WriteRequest, without check on server side. May be empty (for writes from old client) or wrong (if bug in writer).
	// Use it for optimization purposes only, don't trust it.
	UncompressedSize *int64
	// Filled if message_group_id was set on message write.
	MessageGroupId *string
	MetadataItems  []*MetadataItem
}

func (b0 StreamReadMessage_ReadResponse_MessageData_builder) Build() *StreamReadMessage_ReadResponse_MessageData {
	m0 := &StreamReadMessage_ReadResponse_MessageData{}
	b, x := &b0, m0
	_, _ = b, x
	x.Offset = b.Offset
	x.SeqNo = b.SeqNo
	x.CreatedAt = b.CreatedAt
	x.Data = b.Data
	x.UncompressedSize = b.UncompressedSize
	x.MessageGroupId = b.MessageGroupId
	x.MetadataItems = b.MetadataItems
	return m0
}

// Representation of sequence of client messages from one write session.
type StreamReadMessage_ReadResponse_Batch struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// List of client messages.
	MessageData []*StreamReadMessage_ReadResponse_MessageData `protobuf:"bytes,1,rep,name=message_data,json=messageData" json:"message_data,omitempty"`
	// Producer identifier provided by client for this batch of client messages.
	ProducerId *string `protobuf:"bytes,2,opt,name=producer_id,json=producerId" json:"producer_id,omitempty"`
	// Client metadata attached to write session, the same for all messages in batch.
	WriteSessionMeta map[string]string `protobuf:"bytes,3,rep,name=write_session_meta,json=writeSessionMeta" json:"write_session_meta,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Codec that is used for data compression.
	// See enum Codec above for values.
	Codec *int32 `protobuf:"varint,4,opt,name=codec" json:"codec,omitempty"`
	// Persist timestamp on server for batch.
	WrittenAt     *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=written_at,json=writtenAt" json:"written_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamReadMessage_ReadResponse_Batch) Reset() {
	*x = StreamReadMessage_ReadResponse_Batch{}
	mi := &file_protos_ydb_topic_proto_msgTypes[79]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_ReadResponse_Batch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_ReadResponse_Batch) ProtoMessage() {}

func (x *StreamReadMessage_ReadResponse_Batch) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[79]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamReadMessage_ReadResponse_Batch) GetMessageData() []*StreamReadMessage_ReadResponse_MessageData {
	if x != nil {
		return x.MessageData
	}
	return nil
}

func (x *StreamReadMessage_ReadResponse_Batch) GetProducerId() string {
	if x != nil && x.ProducerId != nil {
		return *x.ProducerId
	}
	return ""
}

func (x *StreamReadMessage_ReadResponse_Batch) GetWriteSessionMeta() map[string]string {
	if x != nil {
		return x.WriteSessionMeta
	}
	return nil
}

func (x *StreamReadMessage_ReadResponse_Batch) GetCodec() int32 {
	if x != nil && x.Codec != nil {
		return *x.Codec
	}
	return 0
}

func (x *StreamReadMessage_ReadResponse_Batch) GetWrittenAt() *timestamppb.Timestamp {
	if x != nil {
		return x.WrittenAt
	}
	return nil
}

func (x *StreamReadMessage_ReadResponse_Batch) SetMessageData(v []*StreamReadMessage_ReadResponse_MessageData) {
	x.MessageData = v
}

func (x *StreamReadMessage_ReadResponse_Batch) SetProducerId(v string) {
	x.ProducerId = &v
}

func (x *StreamReadMessage_ReadResponse_Batch) SetWriteSessionMeta(v map[string]string) {
	x.WriteSessionMeta = v
}

func (x *StreamReadMessage_ReadResponse_Batch) SetCodec(v int32) {
	x.Codec = &v
}

func (x *StreamReadMessage_ReadResponse_Batch) SetWrittenAt(v *timestamppb.Timestamp) {
	x.WrittenAt = v
}

func (x *StreamReadMessage_ReadResponse_Batch) HasProducerId() bool {
	if x == nil {
		return false
	}
	return x.ProducerId != nil
}

func (x *StreamReadMessage_ReadResponse_Batch) HasCodec() bool {
	if x == nil {
		return false
	}
	return x.Codec != nil
}

func (x *StreamReadMessage_ReadResponse_Batch) HasWrittenAt() bool {
	if x == nil {
		return false
	}
	return x.WrittenAt != nil
}

func (x *StreamReadMessage_ReadResponse_Batch) ClearProducerId() {
	x.ProducerId = nil
}

func (x *StreamReadMessage_ReadResponse_Batch) ClearCodec() {
	x.Codec = nil
}

func (x *StreamReadMessage_ReadResponse_Batch) ClearWrittenAt() {
	x.WrittenAt = nil
}

type StreamReadMessage_ReadResponse_Batch_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// List of client messages.
	MessageData []*StreamReadMessage_ReadResponse_MessageData
	// Producer identifier provided by client for this batch of client messages.
	ProducerId *string
	// Client metadata attached to write session, the same for all messages in batch.
	WriteSessionMeta map[string]string
	// Codec that is used for data compression.
	// See enum Codec above for values.
	Codec *int32
	// Persist timestamp on server for batch.
	WrittenAt *timestamppb.Timestamp
}

func (b0 StreamReadMessage_ReadResponse_Batch_builder) Build() *StreamReadMessage_ReadResponse_Batch {
	m0 := &StreamReadMessage_ReadResponse_Batch{}
	b, x := &b0, m0
	_, _ = b, x
	x.MessageData = b.MessageData
	x.ProducerId = b.ProducerId
	x.WriteSessionMeta = b.WriteSessionMeta
	x.Codec = b.Codec
	x.WrittenAt = b.WrittenAt
	return m0
}

// Representation of sequence of messages from one partition.
type StreamReadMessage_ReadResponse_PartitionData struct {
	state              protoimpl.MessageState `protogen:"hybrid.v1"`
	PartitionSessionId *int64                 `protobuf:"varint,1,opt,name=partition_session_id,json=partitionSessionId" json:"partition_session_id,omitempty"`
	// Client messages, divided by write sessions.
	Batches       []*StreamReadMessage_ReadResponse_Batch `protobuf:"bytes,2,rep,name=batches" json:"batches,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamReadMessage_ReadResponse_PartitionData) Reset() {
	*x = StreamReadMessage_ReadResponse_PartitionData{}
	mi := &file_protos_ydb_topic_proto_msgTypes[80]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_ReadResponse_PartitionData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_ReadResponse_PartitionData) ProtoMessage() {}

func (x *StreamReadMessage_ReadResponse_PartitionData) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[80]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamReadMessage_ReadResponse_PartitionData) GetPartitionSessionId() int64 {
	if x != nil && x.PartitionSessionId != nil {
		return *x.PartitionSessionId
	}
	return 0
}

func (x *StreamReadMessage_ReadResponse_PartitionData) GetBatches() []*StreamReadMessage_ReadResponse_Batch {
	if x != nil {
		return x.Batches
	}
	return nil
}

func (x *StreamReadMessage_ReadResponse_PartitionData) SetPartitionSessionId(v int64) {
	x.PartitionSessionId = &v
}

func (x *StreamReadMessage_ReadResponse_PartitionData) SetBatches(v []*StreamReadMessage_ReadResponse_Batch) {
	x.Batches = v
}

func (x *StreamReadMessage_ReadResponse_PartitionData) HasPartitionSessionId() bool {
	if x == nil {
		return false
	}
	return x.PartitionSessionId != nil
}

func (x *StreamReadMessage_ReadResponse_PartitionData) ClearPartitionSessionId() {
	x.PartitionSessionId = nil
}

type StreamReadMessage_ReadResponse_PartitionData_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	PartitionSessionId *int64
	// Client messages, divided by write sessions.
	Batches []*StreamReadMessage_ReadResponse_Batch
}

func (b0 StreamReadMessage_ReadResponse_PartitionData_builder) Build() *StreamReadMessage_ReadResponse_PartitionData {
	m0 := &StreamReadMessage_ReadResponse_PartitionData{}
	b, x := &b0, m0
	_, _ = b, x
	x.PartitionSessionId = b.PartitionSessionId
	x.Batches = b.Batches
	return m0
}

// Message that is used for describing commit.
type StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Identifier of partition session with data to commit.
	PartitionSessionId *int64 `protobuf:"varint,1,opt,name=partition_session_id,json=partitionSessionId" json:"partition_session_id,omitempty"`
	// Processed offsets ranges, repeated in case of disjoint ranges.
	Offsets       []*OffsetsRange `protobuf:"bytes,2,rep,name=offsets" json:"offsets,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset) Reset() {
	*x = StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset{}
	mi := &file_protos_ydb_topic_proto_msgTypes[82]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset) ProtoMessage() {}

func (x *StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[82]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset) GetPartitionSessionId() int64 {
	if x != nil && x.PartitionSessionId != nil {
		return *x.PartitionSessionId
	}
	return 0
}

func (x *StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset) GetOffsets() []*OffsetsRange {
	if x != nil {
		return x.Offsets
	}
	return nil
}

func (x *StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset) SetPartitionSessionId(v int64) {
	x.PartitionSessionId = &v
}

func (x *StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset) SetOffsets(v []*OffsetsRange) {
	x.Offsets = v
}

func (x *StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset) HasPartitionSessionId() bool {
	if x == nil {
		return false
	}
	return x.PartitionSessionId != nil
}

func (x *StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset) ClearPartitionSessionId() {
	x.PartitionSessionId = nil
}

type StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Identifier of partition session with data to commit.
	PartitionSessionId *int64
	// Processed offsets ranges, repeated in case of disjoint ranges.
	Offsets []*OffsetsRange
}

func (b0 StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset_builder) Build() *StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset {
	m0 := &StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset{}
	b, x := &b0, m0
	_, _ = b, x
	x.PartitionSessionId = b.PartitionSessionId
	x.Offsets = b.Offsets
	return m0
}

// Per-partition commit representation.
type StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Partition session identifier.
	PartitionSessionId *int64 `protobuf:"varint,1,opt,name=partition_session_id,json=partitionSessionId" json:"partition_session_id,omitempty"`
	// Upper bound for committed offsets.
	CommittedOffset *int64 `protobuf:"varint,2,opt,name=committed_offset,json=committedOffset" json:"committed_offset,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset) Reset() {
	*x = StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset{}
	mi := &file_protos_ydb_topic_proto_msgTypes[83]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset) ProtoMessage() {}

func (x *StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[83]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset) GetPartitionSessionId() int64 {
	if x != nil && x.PartitionSessionId != nil {
		return *x.PartitionSessionId
	}
	return 0
}

func (x *StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset) GetCommittedOffset() int64 {
	if x != nil && x.CommittedOffset != nil {
		return *x.CommittedOffset
	}
	return 0
}

func (x *StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset) SetPartitionSessionId(v int64) {
	x.PartitionSessionId = &v
}

func (x *StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset) SetCommittedOffset(v int64) {
	x.CommittedOffset = &v
}

func (x *StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset) HasPartitionSessionId() bool {
	if x == nil {
		return false
	}
	return x.PartitionSessionId != nil
}

func (x *StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset) HasCommittedOffset() bool {
	if x == nil {
		return false
	}
	return x.CommittedOffset != nil
}

func (x *StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset) ClearPartitionSessionId() {
	x.PartitionSessionId = nil
}

func (x *StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset) ClearCommittedOffset() {
	x.CommittedOffset = nil
}

type StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Partition session identifier.
	PartitionSessionId *int64
	// Upper bound for committed offsets.
	CommittedOffset *int64
}

func (b0 StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset_builder) Build() *StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset {
	m0 := &StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset{}
	b, x := &b0, m0
	_, _ = b, x
	x.PartitionSessionId = b.PartitionSessionId
	x.CommittedOffset = b.CommittedOffset
	return m0
}

// Client-server message for direct read session.
//
//	InitRequest - command from client to create and start a direct read session.
//	StartDirectReadPartitionSessionRequest - command from client to create and start a direct read partition session.
//	    Client signals it is ready to get data from partition.
//	UpdateTokenRequest - request to update auth token
type StreamDirectReadMessage_FromClient struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Types that are valid to be assigned to ClientMessage:
	//
	//	*StreamDirectReadMessage_FromClient_InitRequest
	//	*StreamDirectReadMessage_FromClient_StartDirectReadPartitionSessionRequest
	//	*StreamDirectReadMessage_FromClient_UpdateTokenRequest
	ClientMessage isStreamDirectReadMessage_FromClient_ClientMessage `protobuf_oneof:"client_message"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamDirectReadMessage_FromClient) Reset() {
	*x = StreamDirectReadMessage_FromClient{}
	mi := &file_protos_ydb_topic_proto_msgTypes[84]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamDirectReadMessage_FromClient) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamDirectReadMessage_FromClient) ProtoMessage() {}

func (x *StreamDirectReadMessage_FromClient) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[84]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamDirectReadMessage_FromClient) GetClientMessage() isStreamDirectReadMessage_FromClient_ClientMessage {
	if x != nil {
		return x.ClientMessage
	}
	return nil
}

func (x *StreamDirectReadMessage_FromClient) GetInitRequest() *StreamDirectReadMessage_InitRequest {
	if x != nil {
		if x, ok := x.ClientMessage.(*StreamDirectReadMessage_FromClient_InitRequest); ok {
			return x.InitRequest
		}
	}
	return nil
}

func (x *StreamDirectReadMessage_FromClient) GetStartDirectReadPartitionSessionRequest() *StreamDirectReadMessage_StartDirectReadPartitionSessionRequest {
	if x != nil {
		if x, ok := x.ClientMessage.(*StreamDirectReadMessage_FromClient_StartDirectReadPartitionSessionRequest); ok {
			return x.StartDirectReadPartitionSessionRequest
		}
	}
	return nil
}

func (x *StreamDirectReadMessage_FromClient) GetUpdateTokenRequest() *UpdateTokenRequest {
	if x != nil {
		if x, ok := x.ClientMessage.(*StreamDirectReadMessage_FromClient_UpdateTokenRequest); ok {
			return x.UpdateTokenRequest
		}
	}
	return nil
}

func (x *StreamDirectReadMessage_FromClient) SetInitRequest(v *StreamDirectReadMessage_InitRequest) {
	if v == nil {
		x.ClientMessage = nil
		return
	}
	x.ClientMessage = &StreamDirectReadMessage_FromClient_InitRequest{v}
}

func (x *StreamDirectReadMessage_FromClient) SetStartDirectReadPartitionSessionRequest(v *StreamDirectReadMessage_StartDirectReadPartitionSessionRequest) {
	if v == nil {
		x.ClientMessage = nil
		return
	}
	x.ClientMessage = &StreamDirectReadMessage_FromClient_StartDirectReadPartitionSessionRequest{v}
}

func (x *StreamDirectReadMessage_FromClient) SetUpdateTokenRequest(v *UpdateTokenRequest) {
	if v == nil {
		x.ClientMessage = nil
		return
	}
	x.ClientMessage = &StreamDirectReadMessage_FromClient_UpdateTokenRequest{v}
}

func (x *StreamDirectReadMessage_FromClient) HasClientMessage() bool {
	if x == nil {
		return false
	}
	return x.ClientMessage != nil
}

func (x *StreamDirectReadMessage_FromClient) HasInitRequest() bool {
	if x == nil {
		return false
	}
	_, ok := x.ClientMessage.(*StreamDirectReadMessage_FromClient_InitRequest)
	return ok
}

func (x *StreamDirectReadMessage_FromClient) HasStartDirectReadPartitionSessionRequest() bool {
	if x == nil {
		return false
	}
	_, ok := x.ClientMessage.(*StreamDirectReadMessage_FromClient_StartDirectReadPartitionSessionRequest)
	return ok
}

func (x *StreamDirectReadMessage_FromClient) HasUpdateTokenRequest() bool {
	if x == nil {
		return false
	}
	_, ok := x.ClientMessage.(*StreamDirectReadMessage_FromClient_UpdateTokenRequest)
	return ok
}

func (x *StreamDirectReadMessage_FromClient) ClearClientMessage() {
	x.ClientMessage = nil
}

func (x *StreamDirectReadMessage_FromClient) ClearInitRequest() {
	if _, ok := x.ClientMessage.(*StreamDirectReadMessage_FromClient_InitRequest); ok {
		x.ClientMessage = nil
	}
}

func (x *StreamDirectReadMessage_FromClient) ClearStartDirectReadPartitionSessionRequest() {
	if _, ok := x.ClientMessage.(*StreamDirectReadMessage_FromClient_StartDirectReadPartitionSessionRequest); ok {
		x.ClientMessage = nil
	}
}

func (x *StreamDirectReadMessage_FromClient) ClearUpdateTokenRequest() {
	if _, ok := x.ClientMessage.(*StreamDirectReadMessage_FromClient_UpdateTokenRequest); ok {
		x.ClientMessage = nil
	}
}

const StreamDirectReadMessage_FromClient_ClientMessage_not_set_case case_StreamDirectReadMessage_FromClient_ClientMessage = 0
const StreamDirectReadMessage_FromClient_InitRequest_case case_StreamDirectReadMessage_FromClient_ClientMessage = 1
const StreamDirectReadMessage_FromClient_StartDirectReadPartitionSessionRequest_case case_StreamDirectReadMessage_FromClient_ClientMessage = 2
const StreamDirectReadMessage_FromClient_UpdateTokenRequest_case case_StreamDirectReadMessage_FromClient_ClientMessage = 3

func (x *StreamDirectReadMessage_FromClient) WhichClientMessage() case_StreamDirectReadMessage_FromClient_ClientMessage {
	if x == nil {
		return StreamDirectReadMessage_FromClient_ClientMessage_not_set_case
	}
	switch x.ClientMessage.(type) {
	case *StreamDirectReadMessage_FromClient_InitRequest:
		return StreamDirectReadMessage_FromClient_InitRequest_case
	case *StreamDirectReadMessage_FromClient_StartDirectReadPartitionSessionRequest:
		return StreamDirectReadMessage_FromClient_StartDirectReadPartitionSessionRequest_case
	case *StreamDirectReadMessage_FromClient_UpdateTokenRequest:
		return StreamDirectReadMessage_FromClient_UpdateTokenRequest_case
	default:
		return StreamDirectReadMessage_FromClient_ClientMessage_not_set_case
	}
}

type StreamDirectReadMessage_FromClient_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Fields of oneof ClientMessage:
	InitRequest                            *StreamDirectReadMessage_InitRequest
	StartDirectReadPartitionSessionRequest *StreamDirectReadMessage_StartDirectReadPartitionSessionRequest
	UpdateTokenRequest                     *UpdateTokenRequest
	// -- end of ClientMessage
}

func (b0 StreamDirectReadMessage_FromClient_builder) Build() *StreamDirectReadMessage_FromClient {
	m0 := &StreamDirectReadMessage_FromClient{}
	b, x := &b0, m0
	_, _ = b, x
	if b.InitRequest != nil {
		x.ClientMessage = &StreamDirectReadMessage_FromClient_InitRequest{b.InitRequest}
	}
	if b.StartDirectReadPartitionSessionRequest != nil {
		x.ClientMessage = &StreamDirectReadMessage_FromClient_StartDirectReadPartitionSessionRequest{b.StartDirectReadPartitionSessionRequest}
	}
	if b.UpdateTokenRequest != nil {
		x.ClientMessage = &StreamDirectReadMessage_FromClient_UpdateTokenRequest{b.UpdateTokenRequest}
	}
	return m0
}

type case_StreamDirectReadMessage_FromClient_ClientMessage protoreflect.FieldNumber

func (x case_StreamDirectReadMessage_FromClient_ClientMessage) String() string {
	md := file_protos_ydb_topic_proto_msgTypes[84].Descriptor()
	if x == 0 {
		return "not set"
	}
	return protoimpl.X.MessageFieldStringOf(md, protoreflect.FieldNumber(x))
}

type isStreamDirectReadMessage_FromClient_ClientMessage interface {
	isStreamDirectReadMessage_FromClient_ClientMessage()
}

type StreamDirectReadMessage_FromClient_InitRequest struct {
	InitRequest *StreamDirectReadMessage_InitRequest `protobuf:"bytes,1,opt,name=init_request,json=initRequest,oneof"`
}

type StreamDirectReadMessage_FromClient_StartDirectReadPartitionSessionRequest struct {
	StartDirectReadPartitionSessionRequest *StreamDirectReadMessage_StartDirectReadPartitionSessionRequest `protobuf:"bytes,2,opt,name=start_direct_read_partition_session_request,json=startDirectReadPartitionSessionRequest,oneof"`
}

type StreamDirectReadMessage_FromClient_UpdateTokenRequest struct {
	UpdateTokenRequest *UpdateTokenRequest `protobuf:"bytes,3,opt,name=update_token_request,json=updateTokenRequest,oneof"`
}

func (*StreamDirectReadMessage_FromClient_InitRequest) isStreamDirectReadMessage_FromClient_ClientMessage() {
}

func (*StreamDirectReadMessage_FromClient_StartDirectReadPartitionSessionRequest) isStreamDirectReadMessage_FromClient_ClientMessage() {
}

func (*StreamDirectReadMessage_FromClient_UpdateTokenRequest) isStreamDirectReadMessage_FromClient_ClientMessage() {
}

// Server-client message for direct read session.
//
//	InitResponse - correct handshake response.
//	StartDirectReadPartitionSessionResponse - Response to StartDirectReadPartitionSessionRequest.
//	DirectReadResponse - portion of message data.
//	StopDirectReadPartitionSession - command from server to stop a direct read partition session.
//	UpdateTokenResponse - acknowledgment of token update.
type StreamDirectReadMessage_FromServer struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Server status of response.
	Status *Ydb.StatusIds_StatusCode `protobuf:"varint,1,opt,name=status,enum=Ydb.StatusIds_StatusCode" json:"status,omitempty"`
	// Issues if any.
	Issues []*Ydb_Issue.IssueMessage `protobuf:"bytes,2,rep,name=issues" json:"issues,omitempty"`
	// Types that are valid to be assigned to ServerMessage:
	//
	//	*StreamDirectReadMessage_FromServer_InitResponse
	//	*StreamDirectReadMessage_FromServer_StartDirectReadPartitionSessionResponse
	//	*StreamDirectReadMessage_FromServer_StopDirectReadPartitionSession
	//	*StreamDirectReadMessage_FromServer_DirectReadResponse
	//	*StreamDirectReadMessage_FromServer_UpdateTokenResponse
	ServerMessage isStreamDirectReadMessage_FromServer_ServerMessage `protobuf_oneof:"server_message"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamDirectReadMessage_FromServer) Reset() {
	*x = StreamDirectReadMessage_FromServer{}
	mi := &file_protos_ydb_topic_proto_msgTypes[85]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamDirectReadMessage_FromServer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamDirectReadMessage_FromServer) ProtoMessage() {}

func (x *StreamDirectReadMessage_FromServer) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[85]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamDirectReadMessage_FromServer) GetStatus() Ydb.StatusIds_StatusCode {
	if x != nil && x.Status != nil {
		return *x.Status
	}
	return Ydb.StatusIds_StatusCode(0)
}

func (x *StreamDirectReadMessage_FromServer) GetIssues() []*Ydb_Issue.IssueMessage {
	if x != nil {
		return x.Issues
	}
	return nil
}

func (x *StreamDirectReadMessage_FromServer) GetServerMessage() isStreamDirectReadMessage_FromServer_ServerMessage {
	if x != nil {
		return x.ServerMessage
	}
	return nil
}

func (x *StreamDirectReadMessage_FromServer) GetInitResponse() *StreamDirectReadMessage_InitResponse {
	if x != nil {
		if x, ok := x.ServerMessage.(*StreamDirectReadMessage_FromServer_InitResponse); ok {
			return x.InitResponse
		}
	}
	return nil
}

func (x *StreamDirectReadMessage_FromServer) GetStartDirectReadPartitionSessionResponse() *StreamDirectReadMessage_StartDirectReadPartitionSessionResponse {
	if x != nil {
		if x, ok := x.ServerMessage.(*StreamDirectReadMessage_FromServer_StartDirectReadPartitionSessionResponse); ok {
			return x.StartDirectReadPartitionSessionResponse
		}
	}
	return nil
}

func (x *StreamDirectReadMessage_FromServer) GetStopDirectReadPartitionSession() *StreamDirectReadMessage_StopDirectReadPartitionSession {
	if x != nil {
		if x, ok := x.ServerMessage.(*StreamDirectReadMessage_FromServer_StopDirectReadPartitionSession); ok {
			return x.StopDirectReadPartitionSession
		}
	}
	return nil
}

func (x *StreamDirectReadMessage_FromServer) GetDirectReadResponse() *StreamDirectReadMessage_DirectReadResponse {
	if x != nil {
		if x, ok := x.ServerMessage.(*StreamDirectReadMessage_FromServer_DirectReadResponse); ok {
			return x.DirectReadResponse
		}
	}
	return nil
}

func (x *StreamDirectReadMessage_FromServer) GetUpdateTokenResponse() *UpdateTokenResponse {
	if x != nil {
		if x, ok := x.ServerMessage.(*StreamDirectReadMessage_FromServer_UpdateTokenResponse); ok {
			return x.UpdateTokenResponse
		}
	}
	return nil
}

func (x *StreamDirectReadMessage_FromServer) SetStatus(v Ydb.StatusIds_StatusCode) {
	x.Status = &v
}

func (x *StreamDirectReadMessage_FromServer) SetIssues(v []*Ydb_Issue.IssueMessage) {
	x.Issues = v
}

func (x *StreamDirectReadMessage_FromServer) SetInitResponse(v *StreamDirectReadMessage_InitResponse) {
	if v == nil {
		x.ServerMessage = nil
		return
	}
	x.ServerMessage = &StreamDirectReadMessage_FromServer_InitResponse{v}
}

func (x *StreamDirectReadMessage_FromServer) SetStartDirectReadPartitionSessionResponse(v *StreamDirectReadMessage_StartDirectReadPartitionSessionResponse) {
	if v == nil {
		x.ServerMessage = nil
		return
	}
	x.ServerMessage = &StreamDirectReadMessage_FromServer_StartDirectReadPartitionSessionResponse{v}
}

func (x *StreamDirectReadMessage_FromServer) SetStopDirectReadPartitionSession(v *StreamDirectReadMessage_StopDirectReadPartitionSession) {
	if v == nil {
		x.ServerMessage = nil
		return
	}
	x.ServerMessage = &StreamDirectReadMessage_FromServer_StopDirectReadPartitionSession{v}
}

func (x *StreamDirectReadMessage_FromServer) SetDirectReadResponse(v *StreamDirectReadMessage_DirectReadResponse) {
	if v == nil {
		x.ServerMessage = nil
		return
	}
	x.ServerMessage = &StreamDirectReadMessage_FromServer_DirectReadResponse{v}
}

func (x *StreamDirectReadMessage_FromServer) SetUpdateTokenResponse(v *UpdateTokenResponse) {
	if v == nil {
		x.ServerMessage = nil
		return
	}
	x.ServerMessage = &StreamDirectReadMessage_FromServer_UpdateTokenResponse{v}
}

func (x *StreamDirectReadMessage_FromServer) HasStatus() bool {
	if x == nil {
		return false
	}
	return x.Status != nil
}

func (x *StreamDirectReadMessage_FromServer) HasServerMessage() bool {
	if x == nil {
		return false
	}
	return x.ServerMessage != nil
}

func (x *StreamDirectReadMessage_FromServer) HasInitResponse() bool {
	if x == nil {
		return false
	}
	_, ok := x.ServerMessage.(*StreamDirectReadMessage_FromServer_InitResponse)
	return ok
}

func (x *StreamDirectReadMessage_FromServer) HasStartDirectReadPartitionSessionResponse() bool {
	if x == nil {
		return false
	}
	_, ok := x.ServerMessage.(*StreamDirectReadMessage_FromServer_StartDirectReadPartitionSessionResponse)
	return ok
}

func (x *StreamDirectReadMessage_FromServer) HasStopDirectReadPartitionSession() bool {
	if x == nil {
		return false
	}
	_, ok := x.ServerMessage.(*StreamDirectReadMessage_FromServer_StopDirectReadPartitionSession)
	return ok
}

func (x *StreamDirectReadMessage_FromServer) HasDirectReadResponse() bool {
	if x == nil {
		return false
	}
	_, ok := x.ServerMessage.(*StreamDirectReadMessage_FromServer_DirectReadResponse)
	return ok
}

func (x *StreamDirectReadMessage_FromServer) HasUpdateTokenResponse() bool {
	if x == nil {
		return false
	}
	_, ok := x.ServerMessage.(*StreamDirectReadMessage_FromServer_UpdateTokenResponse)
	return ok
}

func (x *StreamDirectReadMessage_FromServer) ClearStatus() {
	x.Status = nil
}

func (x *StreamDirectReadMessage_FromServer) ClearServerMessage() {
	x.ServerMessage = nil
}

func (x *StreamDirectReadMessage_FromServer) ClearInitResponse() {
	if _, ok := x.ServerMessage.(*StreamDirectReadMessage_FromServer_InitResponse); ok {
		x.ServerMessage = nil
	}
}

func (x *StreamDirectReadMessage_FromServer) ClearStartDirectReadPartitionSessionResponse() {
	if _, ok := x.ServerMessage.(*StreamDirectReadMessage_FromServer_StartDirectReadPartitionSessionResponse); ok {
		x.ServerMessage = nil
	}
}

func (x *StreamDirectReadMessage_FromServer) ClearStopDirectReadPartitionSession() {
	if _, ok := x.ServerMessage.(*StreamDirectReadMessage_FromServer_StopDirectReadPartitionSession); ok {
		x.ServerMessage = nil
	}
}

func (x *StreamDirectReadMessage_FromServer) ClearDirectReadResponse() {
	if _, ok := x.ServerMessage.(*StreamDirectReadMessage_FromServer_DirectReadResponse); ok {
		x.ServerMessage = nil
	}
}

func (x *StreamDirectReadMessage_FromServer) ClearUpdateTokenResponse() {
	if _, ok := x.ServerMessage.(*StreamDirectReadMessage_FromServer_UpdateTokenResponse); ok {
		x.ServerMessage = nil
	}
}

const StreamDirectReadMessage_FromServer_ServerMessage_not_set_case case_StreamDirectReadMessage_FromServer_ServerMessage = 0
const StreamDirectReadMessage_FromServer_InitResponse_case case_StreamDirectReadMessage_FromServer_ServerMessage = 6
const StreamDirectReadMessage_FromServer_StartDirectReadPartitionSessionResponse_case case_StreamDirectReadMessage_FromServer_ServerMessage = 7
const StreamDirectReadMessage_FromServer_StopDirectReadPartitionSession_case case_StreamDirectReadMessage_FromServer_ServerMessage = 3
const StreamDirectReadMessage_FromServer_DirectReadResponse_case case_StreamDirectReadMessage_FromServer_ServerMessage = 4
const StreamDirectReadMessage_FromServer_UpdateTokenResponse_case case_StreamDirectReadMessage_FromServer_ServerMessage = 5

func (x *StreamDirectReadMessage_FromServer) WhichServerMessage() case_StreamDirectReadMessage_FromServer_ServerMessage {
	if x == nil {
		return StreamDirectReadMessage_FromServer_ServerMessage_not_set_case
	}
	switch x.ServerMessage.(type) {
	case *StreamDirectReadMessage_FromServer_InitResponse:
		return StreamDirectReadMessage_FromServer_InitResponse_case
	case *StreamDirectReadMessage_FromServer_StartDirectReadPartitionSessionResponse:
		return StreamDirectReadMessage_FromServer_StartDirectReadPartitionSessionResponse_case
	case *StreamDirectReadMessage_FromServer_StopDirectReadPartitionSession:
		return StreamDirectReadMessage_FromServer_StopDirectReadPartitionSession_case
	case *StreamDirectReadMessage_FromServer_DirectReadResponse:
		return StreamDirectReadMessage_FromServer_DirectReadResponse_case
	case *StreamDirectReadMessage_FromServer_UpdateTokenResponse:
		return StreamDirectReadMessage_FromServer_UpdateTokenResponse_case
	default:
		return StreamDirectReadMessage_FromServer_ServerMessage_not_set_case
	}
}

type StreamDirectReadMessage_FromServer_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Server status of response.
	Status *Ydb.StatusIds_StatusCode
	// Issues if any.
	Issues []*Ydb_Issue.IssueMessage
	// Fields of oneof ServerMessage:
	InitResponse                            *StreamDirectReadMessage_InitResponse
	StartDirectReadPartitionSessionResponse *StreamDirectReadMessage_StartDirectReadPartitionSessionResponse
	StopDirectReadPartitionSession          *StreamDirectReadMessage_StopDirectReadPartitionSession
	DirectReadResponse                      *StreamDirectReadMessage_DirectReadResponse
	UpdateTokenResponse                     *UpdateTokenResponse
	// -- end of ServerMessage
}

func (b0 StreamDirectReadMessage_FromServer_builder) Build() *StreamDirectReadMessage_FromServer {
	m0 := &StreamDirectReadMessage_FromServer{}
	b, x := &b0, m0
	_, _ = b, x
	x.Status = b.Status
	x.Issues = b.Issues
	if b.InitResponse != nil {
		x.ServerMessage = &StreamDirectReadMessage_FromServer_InitResponse{b.InitResponse}
	}
	if b.StartDirectReadPartitionSessionResponse != nil {
		x.ServerMessage = &StreamDirectReadMessage_FromServer_StartDirectReadPartitionSessionResponse{b.StartDirectReadPartitionSessionResponse}
	}
	if b.StopDirectReadPartitionSession != nil {
		x.ServerMessage = &StreamDirectReadMessage_FromServer_StopDirectReadPartitionSession{b.StopDirectReadPartitionSession}
	}
	if b.DirectReadResponse != nil {
		x.ServerMessage = &StreamDirectReadMessage_FromServer_DirectReadResponse{b.DirectReadResponse}
	}
	if b.UpdateTokenResponse != nil {
		x.ServerMessage = &StreamDirectReadMessage_FromServer_UpdateTokenResponse{b.UpdateTokenResponse}
	}
	return m0
}

type case_StreamDirectReadMessage_FromServer_ServerMessage protoreflect.FieldNumber

func (x case_StreamDirectReadMessage_FromServer_ServerMessage) String() string {
	md := file_protos_ydb_topic_proto_msgTypes[85].Descriptor()
	if x == 0 {
		return "not set"
	}
	return protoimpl.X.MessageFieldStringOf(md, protoreflect.FieldNumber(x))
}

type isStreamDirectReadMessage_FromServer_ServerMessage interface {
	isStreamDirectReadMessage_FromServer_ServerMessage()
}

type StreamDirectReadMessage_FromServer_InitResponse struct {
	InitResponse *StreamDirectReadMessage_InitResponse `protobuf:"bytes,6,opt,name=init_response,json=initResponse,oneof"`
}

type StreamDirectReadMessage_FromServer_StartDirectReadPartitionSessionResponse struct {
	StartDirectReadPartitionSessionResponse *StreamDirectReadMessage_StartDirectReadPartitionSessionResponse `protobuf:"bytes,7,opt,name=start_direct_read_partition_session_response,json=startDirectReadPartitionSessionResponse,oneof"`
}

type StreamDirectReadMessage_FromServer_StopDirectReadPartitionSession struct {
	StopDirectReadPartitionSession *StreamDirectReadMessage_StopDirectReadPartitionSession `protobuf:"bytes,3,opt,name=stop_direct_read_partition_session,json=stopDirectReadPartitionSession,oneof"`
}

type StreamDirectReadMessage_FromServer_DirectReadResponse struct {
	DirectReadResponse *StreamDirectReadMessage_DirectReadResponse `protobuf:"bytes,4,opt,name=direct_read_response,json=directReadResponse,oneof"`
}

type StreamDirectReadMessage_FromServer_UpdateTokenResponse struct {
	UpdateTokenResponse *UpdateTokenResponse `protobuf:"bytes,5,opt,name=update_token_response,json=updateTokenResponse,oneof"`
}

func (*StreamDirectReadMessage_FromServer_InitResponse) isStreamDirectReadMessage_FromServer_ServerMessage() {
}

func (*StreamDirectReadMessage_FromServer_StartDirectReadPartitionSessionResponse) isStreamDirectReadMessage_FromServer_ServerMessage() {
}

func (*StreamDirectReadMessage_FromServer_StopDirectReadPartitionSession) isStreamDirectReadMessage_FromServer_ServerMessage() {
}

func (*StreamDirectReadMessage_FromServer_DirectReadResponse) isStreamDirectReadMessage_FromServer_ServerMessage() {
}

func (*StreamDirectReadMessage_FromServer_UpdateTokenResponse) isStreamDirectReadMessage_FromServer_ServerMessage() {
}

// Command from client to create and start a direct read session.
// Server should not send a response to the command.
type StreamDirectReadMessage_InitRequest struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Read session identifier.
	SessionId *string `protobuf:"bytes,1,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
	// Topics that will be read by this session.
	TopicsReadSettings []*StreamDirectReadMessage_InitRequest_TopicReadSettings `protobuf:"bytes,2,rep,name=topics_read_settings,json=topicsReadSettings" json:"topics_read_settings,omitempty"`
	// Path of consumer that is used for reading by this session.
	Consumer      *string `protobuf:"bytes,3,opt,name=consumer" json:"consumer,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamDirectReadMessage_InitRequest) Reset() {
	*x = StreamDirectReadMessage_InitRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[86]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamDirectReadMessage_InitRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamDirectReadMessage_InitRequest) ProtoMessage() {}

func (x *StreamDirectReadMessage_InitRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[86]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamDirectReadMessage_InitRequest) GetSessionId() string {
	if x != nil && x.SessionId != nil {
		return *x.SessionId
	}
	return ""
}

func (x *StreamDirectReadMessage_InitRequest) GetTopicsReadSettings() []*StreamDirectReadMessage_InitRequest_TopicReadSettings {
	if x != nil {
		return x.TopicsReadSettings
	}
	return nil
}

func (x *StreamDirectReadMessage_InitRequest) GetConsumer() string {
	if x != nil && x.Consumer != nil {
		return *x.Consumer
	}
	return ""
}

func (x *StreamDirectReadMessage_InitRequest) SetSessionId(v string) {
	x.SessionId = &v
}

func (x *StreamDirectReadMessage_InitRequest) SetTopicsReadSettings(v []*StreamDirectReadMessage_InitRequest_TopicReadSettings) {
	x.TopicsReadSettings = v
}

func (x *StreamDirectReadMessage_InitRequest) SetConsumer(v string) {
	x.Consumer = &v
}

func (x *StreamDirectReadMessage_InitRequest) HasSessionId() bool {
	if x == nil {
		return false
	}
	return x.SessionId != nil
}

func (x *StreamDirectReadMessage_InitRequest) HasConsumer() bool {
	if x == nil {
		return false
	}
	return x.Consumer != nil
}

func (x *StreamDirectReadMessage_InitRequest) ClearSessionId() {
	x.SessionId = nil
}

func (x *StreamDirectReadMessage_InitRequest) ClearConsumer() {
	x.Consumer = nil
}

type StreamDirectReadMessage_InitRequest_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Read session identifier.
	SessionId *string
	// Topics that will be read by this session.
	TopicsReadSettings []*StreamDirectReadMessage_InitRequest_TopicReadSettings
	// Path of consumer that is used for reading by this session.
	Consumer *string
}

func (b0 StreamDirectReadMessage_InitRequest_builder) Build() *StreamDirectReadMessage_InitRequest {
	m0 := &StreamDirectReadMessage_InitRequest{}
	b, x := &b0, m0
	_, _ = b, x
	x.SessionId = b.SessionId
	x.TopicsReadSettings = b.TopicsReadSettings
	x.Consumer = b.Consumer
	return m0
}

// Response to the handshake.
type StreamDirectReadMessage_InitResponse struct {
	state         protoimpl.MessageState `protogen:"hybrid.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamDirectReadMessage_InitResponse) Reset() {
	*x = StreamDirectReadMessage_InitResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[87]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamDirectReadMessage_InitResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamDirectReadMessage_InitResponse) ProtoMessage() {}

func (x *StreamDirectReadMessage_InitResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[87]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

type StreamDirectReadMessage_InitResponse_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

}

func (b0 StreamDirectReadMessage_InitResponse_builder) Build() *StreamDirectReadMessage_InitResponse {
	m0 := &StreamDirectReadMessage_InitResponse{}
	b, x := &b0, m0
	_, _ = b, x
	return m0
}

// Command from client to create and start a direct read partition session.
type StreamDirectReadMessage_StartDirectReadPartitionSessionRequest struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Partition session identifier.
	PartitionSessionId *int64 `protobuf:"varint,1,opt,name=partition_session_id,json=partitionSessionId" json:"partition_session_id,omitempty"`
	// Upper bound for read request identifiers.
	LastDirectReadId *int64 `protobuf:"varint,2,opt,name=last_direct_read_id,json=lastDirectReadId" json:"last_direct_read_id,omitempty"`
	// Partition generation.
	Generation    *int64 `protobuf:"varint,3,opt,name=generation" json:"generation,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionRequest) Reset() {
	*x = StreamDirectReadMessage_StartDirectReadPartitionSessionRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[88]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamDirectReadMessage_StartDirectReadPartitionSessionRequest) ProtoMessage() {}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[88]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionRequest) GetPartitionSessionId() int64 {
	if x != nil && x.PartitionSessionId != nil {
		return *x.PartitionSessionId
	}
	return 0
}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionRequest) GetLastDirectReadId() int64 {
	if x != nil && x.LastDirectReadId != nil {
		return *x.LastDirectReadId
	}
	return 0
}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionRequest) GetGeneration() int64 {
	if x != nil && x.Generation != nil {
		return *x.Generation
	}
	return 0
}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionRequest) SetPartitionSessionId(v int64) {
	x.PartitionSessionId = &v
}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionRequest) SetLastDirectReadId(v int64) {
	x.LastDirectReadId = &v
}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionRequest) SetGeneration(v int64) {
	x.Generation = &v
}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionRequest) HasPartitionSessionId() bool {
	if x == nil {
		return false
	}
	return x.PartitionSessionId != nil
}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionRequest) HasLastDirectReadId() bool {
	if x == nil {
		return false
	}
	return x.LastDirectReadId != nil
}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionRequest) HasGeneration() bool {
	if x == nil {
		return false
	}
	return x.Generation != nil
}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionRequest) ClearPartitionSessionId() {
	x.PartitionSessionId = nil
}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionRequest) ClearLastDirectReadId() {
	x.LastDirectReadId = nil
}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionRequest) ClearGeneration() {
	x.Generation = nil
}

type StreamDirectReadMessage_StartDirectReadPartitionSessionRequest_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Partition session identifier.
	PartitionSessionId *int64
	// Upper bound for read request identifiers.
	LastDirectReadId *int64
	// Partition generation.
	Generation *int64
}

func (b0 StreamDirectReadMessage_StartDirectReadPartitionSessionRequest_builder) Build() *StreamDirectReadMessage_StartDirectReadPartitionSessionRequest {
	m0 := &StreamDirectReadMessage_StartDirectReadPartitionSessionRequest{}
	b, x := &b0, m0
	_, _ = b, x
	x.PartitionSessionId = b.PartitionSessionId
	x.LastDirectReadId = b.LastDirectReadId
	x.Generation = b.Generation
	return m0
}

// Signal for server that client is ready to receive data for partition.
type StreamDirectReadMessage_StartDirectReadPartitionSessionResponse struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Partition session identifier of partition to start read.
	PartitionSessionId *int64 `protobuf:"varint,1,opt,name=partition_session_id,json=partitionSessionId" json:"partition_session_id,omitempty"`
	// Partition generation.
	Generation    *int64 `protobuf:"varint,2,opt,name=generation" json:"generation,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionResponse) Reset() {
	*x = StreamDirectReadMessage_StartDirectReadPartitionSessionResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[89]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamDirectReadMessage_StartDirectReadPartitionSessionResponse) ProtoMessage() {}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[89]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionResponse) GetPartitionSessionId() int64 {
	if x != nil && x.PartitionSessionId != nil {
		return *x.PartitionSessionId
	}
	return 0
}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionResponse) GetGeneration() int64 {
	if x != nil && x.Generation != nil {
		return *x.Generation
	}
	return 0
}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionResponse) SetPartitionSessionId(v int64) {
	x.PartitionSessionId = &v
}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionResponse) SetGeneration(v int64) {
	x.Generation = &v
}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionResponse) HasPartitionSessionId() bool {
	if x == nil {
		return false
	}
	return x.PartitionSessionId != nil
}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionResponse) HasGeneration() bool {
	if x == nil {
		return false
	}
	return x.Generation != nil
}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionResponse) ClearPartitionSessionId() {
	x.PartitionSessionId = nil
}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionResponse) ClearGeneration() {
	x.Generation = nil
}

type StreamDirectReadMessage_StartDirectReadPartitionSessionResponse_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Partition session identifier of partition to start read.
	PartitionSessionId *int64
	// Partition generation.
	Generation *int64
}

func (b0 StreamDirectReadMessage_StartDirectReadPartitionSessionResponse_builder) Build() *StreamDirectReadMessage_StartDirectReadPartitionSessionResponse {
	m0 := &StreamDirectReadMessage_StartDirectReadPartitionSessionResponse{}
	b, x := &b0, m0
	_, _ = b, x
	x.PartitionSessionId = b.PartitionSessionId
	x.Generation = b.Generation
	return m0
}

// Command from server to stop a direct read partition session.
// Client should not send a response to the command.
type StreamDirectReadMessage_StopDirectReadPartitionSession struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// The reason for the stop.
	Status *Ydb.StatusIds_StatusCode `protobuf:"varint,1,opt,name=status,enum=Ydb.StatusIds_StatusCode" json:"status,omitempty"`
	// Issues if any.
	Issues []*Ydb_Issue.IssueMessage `protobuf:"bytes,2,rep,name=issues" json:"issues,omitempty"`
	// Partition session identifier.
	PartitionSessionId *int64 `protobuf:"varint,3,opt,name=partition_session_id,json=partitionSessionId" json:"partition_session_id,omitempty"`
	// Partition generation.
	Generation    *int64 `protobuf:"varint,4,opt,name=generation" json:"generation,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamDirectReadMessage_StopDirectReadPartitionSession) Reset() {
	*x = StreamDirectReadMessage_StopDirectReadPartitionSession{}
	mi := &file_protos_ydb_topic_proto_msgTypes[90]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamDirectReadMessage_StopDirectReadPartitionSession) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamDirectReadMessage_StopDirectReadPartitionSession) ProtoMessage() {}

func (x *StreamDirectReadMessage_StopDirectReadPartitionSession) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[90]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamDirectReadMessage_StopDirectReadPartitionSession) GetStatus() Ydb.StatusIds_StatusCode {
	if x != nil && x.Status != nil {
		return *x.Status
	}
	return Ydb.StatusIds_StatusCode(0)
}

func (x *StreamDirectReadMessage_StopDirectReadPartitionSession) GetIssues() []*Ydb_Issue.IssueMessage {
	if x != nil {
		return x.Issues
	}
	return nil
}

func (x *StreamDirectReadMessage_StopDirectReadPartitionSession) GetPartitionSessionId() int64 {
	if x != nil && x.PartitionSessionId != nil {
		return *x.PartitionSessionId
	}
	return 0
}

func (x *StreamDirectReadMessage_StopDirectReadPartitionSession) GetGeneration() int64 {
	if x != nil && x.Generation != nil {
		return *x.Generation
	}
	return 0
}

func (x *StreamDirectReadMessage_StopDirectReadPartitionSession) SetStatus(v Ydb.StatusIds_StatusCode) {
	x.Status = &v
}

func (x *StreamDirectReadMessage_StopDirectReadPartitionSession) SetIssues(v []*Ydb_Issue.IssueMessage) {
	x.Issues = v
}

func (x *StreamDirectReadMessage_StopDirectReadPartitionSession) SetPartitionSessionId(v int64) {
	x.PartitionSessionId = &v
}

func (x *StreamDirectReadMessage_StopDirectReadPartitionSession) SetGeneration(v int64) {
	x.Generation = &v
}

func (x *StreamDirectReadMessage_StopDirectReadPartitionSession) HasStatus() bool {
	if x == nil {
		return false
	}
	return x.Status != nil
}

func (x *StreamDirectReadMessage_StopDirectReadPartitionSession) HasPartitionSessionId() bool {
	if x == nil {
		return false
	}
	return x.PartitionSessionId != nil
}

func (x *StreamDirectReadMessage_StopDirectReadPartitionSession) HasGeneration() bool {
	if x == nil {
		return false
	}
	return x.Generation != nil
}

func (x *StreamDirectReadMessage_StopDirectReadPartitionSession) ClearStatus() {
	x.Status = nil
}

func (x *StreamDirectReadMessage_StopDirectReadPartitionSession) ClearPartitionSessionId() {
	x.PartitionSessionId = nil
}

func (x *StreamDirectReadMessage_StopDirectReadPartitionSession) ClearGeneration() {
	x.Generation = nil
}

type StreamDirectReadMessage_StopDirectReadPartitionSession_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// The reason for the stop.
	Status *Ydb.StatusIds_StatusCode
	// Issues if any.
	Issues []*Ydb_Issue.IssueMessage
	// Partition session identifier.
	PartitionSessionId *int64
	// Partition generation.
	Generation *int64
}

func (b0 StreamDirectReadMessage_StopDirectReadPartitionSession_builder) Build() *StreamDirectReadMessage_StopDirectReadPartitionSession {
	m0 := &StreamDirectReadMessage_StopDirectReadPartitionSession{}
	b, x := &b0, m0
	_, _ = b, x
	x.Status = b.Status
	x.Issues = b.Issues
	x.PartitionSessionId = b.PartitionSessionId
	x.Generation = b.Generation
	return m0
}

// Messages that have been read directly from the partition node.
// It's a response to StreamRead.ReadRequest
type StreamDirectReadMessage_DirectReadResponse struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Partition session identifier.
	PartitionSessionId *int64 `protobuf:"varint,1,opt,name=partition_session_id,json=partitionSessionId" json:"partition_session_id,omitempty"`
	// Read request identifier.
	DirectReadId *int64 `protobuf:"varint,2,opt,name=direct_read_id,json=directReadId" json:"direct_read_id,omitempty"`
	// Messages data
	PartitionData *StreamReadMessage_ReadResponse_PartitionData `protobuf:"bytes,3,opt,name=partition_data,json=partitionData" json:"partition_data,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamDirectReadMessage_DirectReadResponse) Reset() {
	*x = StreamDirectReadMessage_DirectReadResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[91]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamDirectReadMessage_DirectReadResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamDirectReadMessage_DirectReadResponse) ProtoMessage() {}

func (x *StreamDirectReadMessage_DirectReadResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[91]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamDirectReadMessage_DirectReadResponse) GetPartitionSessionId() int64 {
	if x != nil && x.PartitionSessionId != nil {
		return *x.PartitionSessionId
	}
	return 0
}

func (x *StreamDirectReadMessage_DirectReadResponse) GetDirectReadId() int64 {
	if x != nil && x.DirectReadId != nil {
		return *x.DirectReadId
	}
	return 0
}

func (x *StreamDirectReadMessage_DirectReadResponse) GetPartitionData() *StreamReadMessage_ReadResponse_PartitionData {
	if x != nil {
		return x.PartitionData
	}
	return nil
}

func (x *StreamDirectReadMessage_DirectReadResponse) SetPartitionSessionId(v int64) {
	x.PartitionSessionId = &v
}

func (x *StreamDirectReadMessage_DirectReadResponse) SetDirectReadId(v int64) {
	x.DirectReadId = &v
}

func (x *StreamDirectReadMessage_DirectReadResponse) SetPartitionData(v *StreamReadMessage_ReadResponse_PartitionData) {
	x.PartitionData = v
}

func (x *StreamDirectReadMessage_DirectReadResponse) HasPartitionSessionId() bool {
	if x == nil {
		return false
	}
	return x.PartitionSessionId != nil
}

func (x *StreamDirectReadMessage_DirectReadResponse) HasDirectReadId() bool {
	if x == nil {
		return false
	}
	return x.DirectReadId != nil
}

func (x *StreamDirectReadMessage_DirectReadResponse) HasPartitionData() bool {
	if x == nil {
		return false
	}
	return x.PartitionData != nil
}

func (x *StreamDirectReadMessage_DirectReadResponse) ClearPartitionSessionId() {
	x.PartitionSessionId = nil
}

func (x *StreamDirectReadMessage_DirectReadResponse) ClearDirectReadId() {
	x.DirectReadId = nil
}

func (x *StreamDirectReadMessage_DirectReadResponse) ClearPartitionData() {
	x.PartitionData = nil
}

type StreamDirectReadMessage_DirectReadResponse_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Partition session identifier.
	PartitionSessionId *int64
	// Read request identifier.
	DirectReadId *int64
	// Messages data
	PartitionData *StreamReadMessage_ReadResponse_PartitionData
}

func (b0 StreamDirectReadMessage_DirectReadResponse_builder) Build() *StreamDirectReadMessage_DirectReadResponse {
	m0 := &StreamDirectReadMessage_DirectReadResponse{}
	b, x := &b0, m0
	_, _ = b, x
	x.PartitionSessionId = b.PartitionSessionId
	x.DirectReadId = b.DirectReadId
	x.PartitionData = b.PartitionData
	return m0
}

type StreamDirectReadMessage_InitRequest_TopicReadSettings struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Topic path.
	Path          *string `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamDirectReadMessage_InitRequest_TopicReadSettings) Reset() {
	*x = StreamDirectReadMessage_InitRequest_TopicReadSettings{}
	mi := &file_protos_ydb_topic_proto_msgTypes[92]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamDirectReadMessage_InitRequest_TopicReadSettings) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamDirectReadMessage_InitRequest_TopicReadSettings) ProtoMessage() {}

func (x *StreamDirectReadMessage_InitRequest_TopicReadSettings) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[92]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StreamDirectReadMessage_InitRequest_TopicReadSettings) GetPath() string {
	if x != nil && x.Path != nil {
		return *x.Path
	}
	return ""
}

func (x *StreamDirectReadMessage_InitRequest_TopicReadSettings) SetPath(v string) {
	x.Path = &v
}

func (x *StreamDirectReadMessage_InitRequest_TopicReadSettings) HasPath() bool {
	if x == nil {
		return false
	}
	return x.Path != nil
}

func (x *StreamDirectReadMessage_InitRequest_TopicReadSettings) ClearPath() {
	x.Path = nil
}

type StreamDirectReadMessage_InitRequest_TopicReadSettings_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Topic path.
	Path *string
}

func (b0 StreamDirectReadMessage_InitRequest_TopicReadSettings_builder) Build() *StreamDirectReadMessage_InitRequest_TopicReadSettings {
	m0 := &StreamDirectReadMessage_InitRequest_TopicReadSettings{}
	b, x := &b0, m0
	_, _ = b, x
	x.Path = b.Path
	return m0
}

type UpdateOffsetsInTransactionRequest_TopicOffsets struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Topic path.
	Path *string `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	// Ranges of offsets by partitions.
	Partitions    []*UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets `protobuf:"bytes,2,rep,name=partitions" json:"partitions,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateOffsetsInTransactionRequest_TopicOffsets) Reset() {
	*x = UpdateOffsetsInTransactionRequest_TopicOffsets{}
	mi := &file_protos_ydb_topic_proto_msgTypes[93]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateOffsetsInTransactionRequest_TopicOffsets) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateOffsetsInTransactionRequest_TopicOffsets) ProtoMessage() {}

func (x *UpdateOffsetsInTransactionRequest_TopicOffsets) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[93]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *UpdateOffsetsInTransactionRequest_TopicOffsets) GetPath() string {
	if x != nil && x.Path != nil {
		return *x.Path
	}
	return ""
}

func (x *UpdateOffsetsInTransactionRequest_TopicOffsets) GetPartitions() []*UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets {
	if x != nil {
		return x.Partitions
	}
	return nil
}

func (x *UpdateOffsetsInTransactionRequest_TopicOffsets) SetPath(v string) {
	x.Path = &v
}

func (x *UpdateOffsetsInTransactionRequest_TopicOffsets) SetPartitions(v []*UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets) {
	x.Partitions = v
}

func (x *UpdateOffsetsInTransactionRequest_TopicOffsets) HasPath() bool {
	if x == nil {
		return false
	}
	return x.Path != nil
}

func (x *UpdateOffsetsInTransactionRequest_TopicOffsets) ClearPath() {
	x.Path = nil
}

type UpdateOffsetsInTransactionRequest_TopicOffsets_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Topic path.
	Path *string
	// Ranges of offsets by partitions.
	Partitions []*UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets
}

func (b0 UpdateOffsetsInTransactionRequest_TopicOffsets_builder) Build() *UpdateOffsetsInTransactionRequest_TopicOffsets {
	m0 := &UpdateOffsetsInTransactionRequest_TopicOffsets{}
	b, x := &b0, m0
	_, _ = b, x
	x.Path = b.Path
	x.Partitions = b.Partitions
	return m0
}

type UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Partition identifier.
	PartitionId *int64 `protobuf:"varint,1,opt,name=partition_id,json=partitionId" json:"partition_id,omitempty"`
	// List of offset ranges.
	PartitionOffsets []*OffsetsRange `protobuf:"bytes,2,rep,name=partition_offsets,json=partitionOffsets" json:"partition_offsets,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets) Reset() {
	*x = UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets{}
	mi := &file_protos_ydb_topic_proto_msgTypes[94]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets) ProtoMessage() {}

func (x *UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[94]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets) GetPartitionId() int64 {
	if x != nil && x.PartitionId != nil {
		return *x.PartitionId
	}
	return 0
}

func (x *UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets) GetPartitionOffsets() []*OffsetsRange {
	if x != nil {
		return x.PartitionOffsets
	}
	return nil
}

func (x *UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets) SetPartitionId(v int64) {
	x.PartitionId = &v
}

func (x *UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets) SetPartitionOffsets(v []*OffsetsRange) {
	x.PartitionOffsets = v
}

func (x *UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets) HasPartitionId() bool {
	if x == nil {
		return false
	}
	return x.PartitionId != nil
}

func (x *UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets) ClearPartitionId() {
	x.PartitionId = nil
}

type UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Partition identifier.
	PartitionId *int64
	// List of offset ranges.
	PartitionOffsets []*OffsetsRange
}

func (b0 UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets_builder) Build() *UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets {
	m0 := &UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets{}
	b, x := &b0, m0
	_, _ = b, x
	x.PartitionId = b.PartitionId
	x.PartitionOffsets = b.PartitionOffsets
	return m0
}

type Consumer_ConsumerStats struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Minimal timestamp of last read from partitions.
	MinPartitionsLastReadTime *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=min_partitions_last_read_time,json=minPartitionsLastReadTime" json:"min_partitions_last_read_time,omitempty"`
	// Maximum of differences between timestamp of read and write timestamp for all messages, read during last minute.
	MaxReadTimeLag *durationpb.Duration `protobuf:"bytes,2,opt,name=max_read_time_lag,json=maxReadTimeLag" json:"max_read_time_lag,omitempty"`
	// Maximum of differences between write timestamp and create timestamp for all messages, read during last minute.
	MaxWriteTimeLag *durationpb.Duration `protobuf:"bytes,3,opt,name=max_write_time_lag,json=maxWriteTimeLag" json:"max_write_time_lag,omitempty"`
	// Bytes read statistics.
	BytesRead     *MultipleWindowsStat `protobuf:"bytes,4,opt,name=bytes_read,json=bytesRead" json:"bytes_read,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Consumer_ConsumerStats) Reset() {
	*x = Consumer_ConsumerStats{}
	mi := &file_protos_ydb_topic_proto_msgTypes[96]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Consumer_ConsumerStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Consumer_ConsumerStats) ProtoMessage() {}

func (x *Consumer_ConsumerStats) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[96]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *Consumer_ConsumerStats) GetMinPartitionsLastReadTime() *timestamppb.Timestamp {
	if x != nil {
		return x.MinPartitionsLastReadTime
	}
	return nil
}

func (x *Consumer_ConsumerStats) GetMaxReadTimeLag() *durationpb.Duration {
	if x != nil {
		return x.MaxReadTimeLag
	}
	return nil
}

func (x *Consumer_ConsumerStats) GetMaxWriteTimeLag() *durationpb.Duration {
	if x != nil {
		return x.MaxWriteTimeLag
	}
	return nil
}

func (x *Consumer_ConsumerStats) GetBytesRead() *MultipleWindowsStat {
	if x != nil {
		return x.BytesRead
	}
	return nil
}

func (x *Consumer_ConsumerStats) SetMinPartitionsLastReadTime(v *timestamppb.Timestamp) {
	x.MinPartitionsLastReadTime = v
}

func (x *Consumer_ConsumerStats) SetMaxReadTimeLag(v *durationpb.Duration) {
	x.MaxReadTimeLag = v
}

func (x *Consumer_ConsumerStats) SetMaxWriteTimeLag(v *durationpb.Duration) {
	x.MaxWriteTimeLag = v
}

func (x *Consumer_ConsumerStats) SetBytesRead(v *MultipleWindowsStat) {
	x.BytesRead = v
}

func (x *Consumer_ConsumerStats) HasMinPartitionsLastReadTime() bool {
	if x == nil {
		return false
	}
	return x.MinPartitionsLastReadTime != nil
}

func (x *Consumer_ConsumerStats) HasMaxReadTimeLag() bool {
	if x == nil {
		return false
	}
	return x.MaxReadTimeLag != nil
}

func (x *Consumer_ConsumerStats) HasMaxWriteTimeLag() bool {
	if x == nil {
		return false
	}
	return x.MaxWriteTimeLag != nil
}

func (x *Consumer_ConsumerStats) HasBytesRead() bool {
	if x == nil {
		return false
	}
	return x.BytesRead != nil
}

func (x *Consumer_ConsumerStats) ClearMinPartitionsLastReadTime() {
	x.MinPartitionsLastReadTime = nil
}

func (x *Consumer_ConsumerStats) ClearMaxReadTimeLag() {
	x.MaxReadTimeLag = nil
}

func (x *Consumer_ConsumerStats) ClearMaxWriteTimeLag() {
	x.MaxWriteTimeLag = nil
}

func (x *Consumer_ConsumerStats) ClearBytesRead() {
	x.BytesRead = nil
}

type Consumer_ConsumerStats_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Minimal timestamp of last read from partitions.
	MinPartitionsLastReadTime *timestamppb.Timestamp
	// Maximum of differences between timestamp of read and write timestamp for all messages, read during last minute.
	MaxReadTimeLag *durationpb.Duration
	// Maximum of differences between write timestamp and create timestamp for all messages, read during last minute.
	MaxWriteTimeLag *durationpb.Duration
	// Bytes read statistics.
	BytesRead *MultipleWindowsStat
}

func (b0 Consumer_ConsumerStats_builder) Build() *Consumer_ConsumerStats {
	m0 := &Consumer_ConsumerStats{}
	b, x := &b0, m0
	_, _ = b, x
	x.MinPartitionsLastReadTime = b.MinPartitionsLastReadTime
	x.MaxReadTimeLag = b.MaxReadTimeLag
	x.MaxWriteTimeLag = b.MaxWriteTimeLag
	x.BytesRead = b.BytesRead
	return m0
}

type DescribeTopicResult_PartitionInfo struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Partition identifier.
	PartitionId *int64 `protobuf:"varint,1,opt,name=partition_id,json=partitionId" json:"partition_id,omitempty"`
	// Is partition open for write.
	Active *bool `protobuf:"varint,2,opt,name=active" json:"active,omitempty"`
	// Ids of partitions which was formed when this partition was split or merged.
	ChildPartitionIds []int64 `protobuf:"varint,3,rep,packed,name=child_partition_ids,json=childPartitionIds" json:"child_partition_ids,omitempty"`
	// Ids of partitions from which this partition was formed by split or merge.
	ParentPartitionIds []int64 `protobuf:"varint,4,rep,packed,name=parent_partition_ids,json=parentPartitionIds" json:"parent_partition_ids,omitempty"`
	// Stats for partition, filled only when include_stats in request is true.
	PartitionStats *PartitionStats `protobuf:"bytes,5,opt,name=partition_stats,json=partitionStats" json:"partition_stats,omitempty"`
	// Partition location, filled only when include_location in request is true.
	PartitionLocation *PartitionLocation `protobuf:"bytes,6,opt,name=partition_location,json=partitionLocation" json:"partition_location,omitempty"`
	KeyRange          *PartitionKeyRange `protobuf:"bytes,7,opt,name=key_range,json=keyRange" json:"key_range,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *DescribeTopicResult_PartitionInfo) Reset() {
	*x = DescribeTopicResult_PartitionInfo{}
	mi := &file_protos_ydb_topic_proto_msgTypes[100]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DescribeTopicResult_PartitionInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DescribeTopicResult_PartitionInfo) ProtoMessage() {}

func (x *DescribeTopicResult_PartitionInfo) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[100]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *DescribeTopicResult_PartitionInfo) GetPartitionId() int64 {
	if x != nil && x.PartitionId != nil {
		return *x.PartitionId
	}
	return 0
}

func (x *DescribeTopicResult_PartitionInfo) GetActive() bool {
	if x != nil && x.Active != nil {
		return *x.Active
	}
	return false
}

func (x *DescribeTopicResult_PartitionInfo) GetChildPartitionIds() []int64 {
	if x != nil {
		return x.ChildPartitionIds
	}
	return nil
}

func (x *DescribeTopicResult_PartitionInfo) GetParentPartitionIds() []int64 {
	if x != nil {
		return x.ParentPartitionIds
	}
	return nil
}

func (x *DescribeTopicResult_PartitionInfo) GetPartitionStats() *PartitionStats {
	if x != nil {
		return x.PartitionStats
	}
	return nil
}

func (x *DescribeTopicResult_PartitionInfo) GetPartitionLocation() *PartitionLocation {
	if x != nil {
		return x.PartitionLocation
	}
	return nil
}

func (x *DescribeTopicResult_PartitionInfo) GetKeyRange() *PartitionKeyRange {
	if x != nil {
		return x.KeyRange
	}
	return nil
}

func (x *DescribeTopicResult_PartitionInfo) SetPartitionId(v int64) {
	x.PartitionId = &v
}

func (x *DescribeTopicResult_PartitionInfo) SetActive(v bool) {
	x.Active = &v
}

func (x *DescribeTopicResult_PartitionInfo) SetChildPartitionIds(v []int64) {
	x.ChildPartitionIds = v
}

func (x *DescribeTopicResult_PartitionInfo) SetParentPartitionIds(v []int64) {
	x.ParentPartitionIds = v
}

func (x *DescribeTopicResult_PartitionInfo) SetPartitionStats(v *PartitionStats) {
	x.PartitionStats = v
}

func (x *DescribeTopicResult_PartitionInfo) SetPartitionLocation(v *PartitionLocation) {
	x.PartitionLocation = v
}

func (x *DescribeTopicResult_PartitionInfo) SetKeyRange(v *PartitionKeyRange) {
	x.KeyRange = v
}

func (x *DescribeTopicResult_PartitionInfo) HasPartitionId() bool {
	if x == nil {
		return false
	}
	return x.PartitionId != nil
}

func (x *DescribeTopicResult_PartitionInfo) HasActive() bool {
	if x == nil {
		return false
	}
	return x.Active != nil
}

func (x *DescribeTopicResult_PartitionInfo) HasPartitionStats() bool {
	if x == nil {
		return false
	}
	return x.PartitionStats != nil
}

func (x *DescribeTopicResult_PartitionInfo) HasPartitionLocation() bool {
	if x == nil {
		return false
	}
	return x.PartitionLocation != nil
}

func (x *DescribeTopicResult_PartitionInfo) HasKeyRange() bool {
	if x == nil {
		return false
	}
	return x.KeyRange != nil
}

func (x *DescribeTopicResult_PartitionInfo) ClearPartitionId() {
	x.PartitionId = nil
}

func (x *DescribeTopicResult_PartitionInfo) ClearActive() {
	x.Active = nil
}

func (x *DescribeTopicResult_PartitionInfo) ClearPartitionStats() {
	x.PartitionStats = nil
}

func (x *DescribeTopicResult_PartitionInfo) ClearPartitionLocation() {
	x.PartitionLocation = nil
}

func (x *DescribeTopicResult_PartitionInfo) ClearKeyRange() {
	x.KeyRange = nil
}

type DescribeTopicResult_PartitionInfo_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Partition identifier.
	PartitionId *int64
	// Is partition open for write.
	Active *bool
	// Ids of partitions which was formed when this partition was split or merged.
	ChildPartitionIds []int64
	// Ids of partitions from which this partition was formed by split or merge.
	ParentPartitionIds []int64
	// Stats for partition, filled only when include_stats in request is true.
	PartitionStats *PartitionStats
	// Partition location, filled only when include_location in request is true.
	PartitionLocation *PartitionLocation
	KeyRange          *PartitionKeyRange
}

func (b0 DescribeTopicResult_PartitionInfo_builder) Build() *DescribeTopicResult_PartitionInfo {
	m0 := &DescribeTopicResult_PartitionInfo{}
	b, x := &b0, m0
	_, _ = b, x
	x.PartitionId = b.PartitionId
	x.Active = b.Active
	x.ChildPartitionIds = b.ChildPartitionIds
	x.ParentPartitionIds = b.ParentPartitionIds
	x.PartitionStats = b.PartitionStats
	x.PartitionLocation = b.PartitionLocation
	x.KeyRange = b.KeyRange
	return m0
}

type DescribeTopicResult_TopicStats struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Approximate size of topic.
	StoreSizeBytes *int64 `protobuf:"varint,1,opt,name=store_size_bytes,json=storeSizeBytes" json:"store_size_bytes,omitempty"`
	// Minimum of timestamps of last write among all partitions.
	MinLastWriteTime *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=min_last_write_time,json=minLastWriteTime" json:"min_last_write_time,omitempty"`
	// Maximum of differences between write timestamp and create timestamp for all messages, written during last minute.
	MaxWriteTimeLag *durationpb.Duration `protobuf:"bytes,3,opt,name=max_write_time_lag,json=maxWriteTimeLag" json:"max_write_time_lag,omitempty"`
	// How much bytes were written statistics.
	BytesWritten  *MultipleWindowsStat `protobuf:"bytes,4,opt,name=bytes_written,json=bytesWritten" json:"bytes_written,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DescribeTopicResult_TopicStats) Reset() {
	*x = DescribeTopicResult_TopicStats{}
	mi := &file_protos_ydb_topic_proto_msgTypes[101]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DescribeTopicResult_TopicStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DescribeTopicResult_TopicStats) ProtoMessage() {}

func (x *DescribeTopicResult_TopicStats) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[101]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *DescribeTopicResult_TopicStats) GetStoreSizeBytes() int64 {
	if x != nil && x.StoreSizeBytes != nil {
		return *x.StoreSizeBytes
	}
	return 0
}

func (x *DescribeTopicResult_TopicStats) GetMinLastWriteTime() *timestamppb.Timestamp {
	if x != nil {
		return x.MinLastWriteTime
	}
	return nil
}

func (x *DescribeTopicResult_TopicStats) GetMaxWriteTimeLag() *durationpb.Duration {
	if x != nil {
		return x.MaxWriteTimeLag
	}
	return nil
}

func (x *DescribeTopicResult_TopicStats) GetBytesWritten() *MultipleWindowsStat {
	if x != nil {
		return x.BytesWritten
	}
	return nil
}

func (x *DescribeTopicResult_TopicStats) SetStoreSizeBytes(v int64) {
	x.StoreSizeBytes = &v
}

func (x *DescribeTopicResult_TopicStats) SetMinLastWriteTime(v *timestamppb.Timestamp) {
	x.MinLastWriteTime = v
}

func (x *DescribeTopicResult_TopicStats) SetMaxWriteTimeLag(v *durationpb.Duration) {
	x.MaxWriteTimeLag = v
}

func (x *DescribeTopicResult_TopicStats) SetBytesWritten(v *MultipleWindowsStat) {
	x.BytesWritten = v
}

func (x *DescribeTopicResult_TopicStats) HasStoreSizeBytes() bool {
	if x == nil {
		return false
	}
	return x.StoreSizeBytes != nil
}

func (x *DescribeTopicResult_TopicStats) HasMinLastWriteTime() bool {
	if x == nil {
		return false
	}
	return x.MinLastWriteTime != nil
}

func (x *DescribeTopicResult_TopicStats) HasMaxWriteTimeLag() bool {
	if x == nil {
		return false
	}
	return x.MaxWriteTimeLag != nil
}

func (x *DescribeTopicResult_TopicStats) HasBytesWritten() bool {
	if x == nil {
		return false
	}
	return x.BytesWritten != nil
}

func (x *DescribeTopicResult_TopicStats) ClearStoreSizeBytes() {
	x.StoreSizeBytes = nil
}

func (x *DescribeTopicResult_TopicStats) ClearMinLastWriteTime() {
	x.MinLastWriteTime = nil
}

func (x *DescribeTopicResult_TopicStats) ClearMaxWriteTimeLag() {
	x.MaxWriteTimeLag = nil
}

func (x *DescribeTopicResult_TopicStats) ClearBytesWritten() {
	x.BytesWritten = nil
}

type DescribeTopicResult_TopicStats_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Approximate size of topic.
	StoreSizeBytes *int64
	// Minimum of timestamps of last write among all partitions.
	MinLastWriteTime *timestamppb.Timestamp
	// Maximum of differences between write timestamp and create timestamp for all messages, written during last minute.
	MaxWriteTimeLag *durationpb.Duration
	// How much bytes were written statistics.
	BytesWritten *MultipleWindowsStat
}

func (b0 DescribeTopicResult_TopicStats_builder) Build() *DescribeTopicResult_TopicStats {
	m0 := &DescribeTopicResult_TopicStats{}
	b, x := &b0, m0
	_, _ = b, x
	x.StoreSizeBytes = b.StoreSizeBytes
	x.MinLastWriteTime = b.MinLastWriteTime
	x.MaxWriteTimeLag = b.MaxWriteTimeLag
	x.BytesWritten = b.BytesWritten
	return m0
}

type DescribeConsumerResult_PartitionInfo struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Partition identifier.
	PartitionId *int64 `protobuf:"varint,1,opt,name=partition_id,json=partitionId" json:"partition_id,omitempty"`
	// Is partition open for write.
	Active *bool `protobuf:"varint,2,opt,name=active" json:"active,omitempty"`
	// Ids of partitions which was formed when this partition was split or merged.
	ChildPartitionIds []int64 `protobuf:"varint,3,rep,packed,name=child_partition_ids,json=childPartitionIds" json:"child_partition_ids,omitempty"`
	// Ids of partitions from which this partition was formed by split or merge.
	ParentPartitionIds []int64 `protobuf:"varint,4,rep,packed,name=parent_partition_ids,json=parentPartitionIds" json:"parent_partition_ids,omitempty"`
	// Stats for partition, filled only when include_stats in request is true.
	PartitionStats *PartitionStats `protobuf:"bytes,5,opt,name=partition_stats,json=partitionStats" json:"partition_stats,omitempty"`
	// Stats for consumer of this partition, filled only when include_stats in request is true.
	PartitionConsumerStats *DescribeConsumerResult_PartitionConsumerStats `protobuf:"bytes,6,opt,name=partition_consumer_stats,json=partitionConsumerStats" json:"partition_consumer_stats,omitempty"`
	// Partition location, filled only when include_location in request is true.
	PartitionLocation *PartitionLocation `protobuf:"bytes,7,opt,name=partition_location,json=partitionLocation" json:"partition_location,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *DescribeConsumerResult_PartitionInfo) Reset() {
	*x = DescribeConsumerResult_PartitionInfo{}
	mi := &file_protos_ydb_topic_proto_msgTypes[102]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DescribeConsumerResult_PartitionInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DescribeConsumerResult_PartitionInfo) ProtoMessage() {}

func (x *DescribeConsumerResult_PartitionInfo) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[102]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *DescribeConsumerResult_PartitionInfo) GetPartitionId() int64 {
	if x != nil && x.PartitionId != nil {
		return *x.PartitionId
	}
	return 0
}

func (x *DescribeConsumerResult_PartitionInfo) GetActive() bool {
	if x != nil && x.Active != nil {
		return *x.Active
	}
	return false
}

func (x *DescribeConsumerResult_PartitionInfo) GetChildPartitionIds() []int64 {
	if x != nil {
		return x.ChildPartitionIds
	}
	return nil
}

func (x *DescribeConsumerResult_PartitionInfo) GetParentPartitionIds() []int64 {
	if x != nil {
		return x.ParentPartitionIds
	}
	return nil
}

func (x *DescribeConsumerResult_PartitionInfo) GetPartitionStats() *PartitionStats {
	if x != nil {
		return x.PartitionStats
	}
	return nil
}

func (x *DescribeConsumerResult_PartitionInfo) GetPartitionConsumerStats() *DescribeConsumerResult_PartitionConsumerStats {
	if x != nil {
		return x.PartitionConsumerStats
	}
	return nil
}

func (x *DescribeConsumerResult_PartitionInfo) GetPartitionLocation() *PartitionLocation {
	if x != nil {
		return x.PartitionLocation
	}
	return nil
}

func (x *DescribeConsumerResult_PartitionInfo) SetPartitionId(v int64) {
	x.PartitionId = &v
}

func (x *DescribeConsumerResult_PartitionInfo) SetActive(v bool) {
	x.Active = &v
}

func (x *DescribeConsumerResult_PartitionInfo) SetChildPartitionIds(v []int64) {
	x.ChildPartitionIds = v
}

func (x *DescribeConsumerResult_PartitionInfo) SetParentPartitionIds(v []int64) {
	x.ParentPartitionIds = v
}

func (x *DescribeConsumerResult_PartitionInfo) SetPartitionStats(v *PartitionStats) {
	x.PartitionStats = v
}

func (x *DescribeConsumerResult_PartitionInfo) SetPartitionConsumerStats(v *DescribeConsumerResult_PartitionConsumerStats) {
	x.PartitionConsumerStats = v
}

func (x *DescribeConsumerResult_PartitionInfo) SetPartitionLocation(v *PartitionLocation) {
	x.PartitionLocation = v
}

func (x *DescribeConsumerResult_PartitionInfo) HasPartitionId() bool {
	if x == nil {
		return false
	}
	return x.PartitionId != nil
}

func (x *DescribeConsumerResult_PartitionInfo) HasActive() bool {
	if x == nil {
		return false
	}
	return x.Active != nil
}

func (x *DescribeConsumerResult_PartitionInfo) HasPartitionStats() bool {
	if x == nil {
		return false
	}
	return x.PartitionStats != nil
}

func (x *DescribeConsumerResult_PartitionInfo) HasPartitionConsumerStats() bool {
	if x == nil {
		return false
	}
	return x.PartitionConsumerStats != nil
}

func (x *DescribeConsumerResult_PartitionInfo) HasPartitionLocation() bool {
	if x == nil {
		return false
	}
	return x.PartitionLocation != nil
}

func (x *DescribeConsumerResult_PartitionInfo) ClearPartitionId() {
	x.PartitionId = nil
}

func (x *DescribeConsumerResult_PartitionInfo) ClearActive() {
	x.Active = nil
}

func (x *DescribeConsumerResult_PartitionInfo) ClearPartitionStats() {
	x.PartitionStats = nil
}

func (x *DescribeConsumerResult_PartitionInfo) ClearPartitionConsumerStats() {
	x.PartitionConsumerStats = nil
}

func (x *DescribeConsumerResult_PartitionInfo) ClearPartitionLocation() {
	x.PartitionLocation = nil
}

type DescribeConsumerResult_PartitionInfo_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Partition identifier.
	PartitionId *int64
	// Is partition open for write.
	Active *bool
	// Ids of partitions which was formed when this partition was split or merged.
	ChildPartitionIds []int64
	// Ids of partitions from which this partition was formed by split or merge.
	ParentPartitionIds []int64
	// Stats for partition, filled only when include_stats in request is true.
	PartitionStats *PartitionStats
	// Stats for consumer of this partition, filled only when include_stats in request is true.
	PartitionConsumerStats *DescribeConsumerResult_PartitionConsumerStats
	// Partition location, filled only when include_location in request is true.
	PartitionLocation *PartitionLocation
}

func (b0 DescribeConsumerResult_PartitionInfo_builder) Build() *DescribeConsumerResult_PartitionInfo {
	m0 := &DescribeConsumerResult_PartitionInfo{}
	b, x := &b0, m0
	_, _ = b, x
	x.PartitionId = b.PartitionId
	x.Active = b.Active
	x.ChildPartitionIds = b.ChildPartitionIds
	x.ParentPartitionIds = b.ParentPartitionIds
	x.PartitionStats = b.PartitionStats
	x.PartitionConsumerStats = b.PartitionConsumerStats
	x.PartitionLocation = b.PartitionLocation
	return m0
}

type DescribeConsumerResult_PartitionConsumerStats struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Last read offset from this partition.
	LastReadOffset *int64 `protobuf:"varint,1,opt,name=last_read_offset,json=lastReadOffset" json:"last_read_offset,omitempty"`
	// Committed offset for this partition.
	CommittedOffset *int64 `protobuf:"varint,2,opt,name=committed_offset,json=committedOffset" json:"committed_offset,omitempty"`
	// Reading this partition read session identifier.
	ReadSessionId *string `protobuf:"bytes,3,opt,name=read_session_id,json=readSessionId" json:"read_session_id,omitempty"`
	// Timestamp of providing this partition to this session by server.
	PartitionReadSessionCreateTime *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=partition_read_session_create_time,json=partitionReadSessionCreateTime" json:"partition_read_session_create_time,omitempty"`
	// Timestamp of last read from this partition.
	LastReadTime *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=last_read_time,json=lastReadTime" json:"last_read_time,omitempty"`
	// Maximum of differences between timestamp of read and write timestamp for all messages, read during last minute.
	MaxReadTimeLag *durationpb.Duration `protobuf:"bytes,6,opt,name=max_read_time_lag,json=maxReadTimeLag" json:"max_read_time_lag,omitempty"`
	// Maximum of differences between write timestamp and create timestamp for all messages, read during last minute.
	MaxWriteTimeLag *durationpb.Duration `protobuf:"bytes,7,opt,name=max_write_time_lag,json=maxWriteTimeLag" json:"max_write_time_lag,omitempty"`
	// How much bytes were read during several windows statistics from this partition.
	BytesRead *MultipleWindowsStat `protobuf:"bytes,8,opt,name=bytes_read,json=bytesRead" json:"bytes_read,omitempty"`
	// Read session name, provided by client.
	ReaderName *string `protobuf:"bytes,11,opt,name=reader_name,json=readerName" json:"reader_name,omitempty"`
	// Host where read session connected.
	ConnectionNodeId *int32 `protobuf:"varint,12,opt,name=connection_node_id,json=connectionNodeId" json:"connection_node_id,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *DescribeConsumerResult_PartitionConsumerStats) Reset() {
	*x = DescribeConsumerResult_PartitionConsumerStats{}
	mi := &file_protos_ydb_topic_proto_msgTypes[103]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DescribeConsumerResult_PartitionConsumerStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DescribeConsumerResult_PartitionConsumerStats) ProtoMessage() {}

func (x *DescribeConsumerResult_PartitionConsumerStats) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[103]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *DescribeConsumerResult_PartitionConsumerStats) GetLastReadOffset() int64 {
	if x != nil && x.LastReadOffset != nil {
		return *x.LastReadOffset
	}
	return 0
}

func (x *DescribeConsumerResult_PartitionConsumerStats) GetCommittedOffset() int64 {
	if x != nil && x.CommittedOffset != nil {
		return *x.CommittedOffset
	}
	return 0
}

func (x *DescribeConsumerResult_PartitionConsumerStats) GetReadSessionId() string {
	if x != nil && x.ReadSessionId != nil {
		return *x.ReadSessionId
	}
	return ""
}

func (x *DescribeConsumerResult_PartitionConsumerStats) GetPartitionReadSessionCreateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.PartitionReadSessionCreateTime
	}
	return nil
}

func (x *DescribeConsumerResult_PartitionConsumerStats) GetLastReadTime() *timestamppb.Timestamp {
	if x != nil {
		return x.LastReadTime
	}
	return nil
}

func (x *DescribeConsumerResult_PartitionConsumerStats) GetMaxReadTimeLag() *durationpb.Duration {
	if x != nil {
		return x.MaxReadTimeLag
	}
	return nil
}

func (x *DescribeConsumerResult_PartitionConsumerStats) GetMaxWriteTimeLag() *durationpb.Duration {
	if x != nil {
		return x.MaxWriteTimeLag
	}
	return nil
}

func (x *DescribeConsumerResult_PartitionConsumerStats) GetBytesRead() *MultipleWindowsStat {
	if x != nil {
		return x.BytesRead
	}
	return nil
}

func (x *DescribeConsumerResult_PartitionConsumerStats) GetReaderName() string {
	if x != nil && x.ReaderName != nil {
		return *x.ReaderName
	}
	return ""
}

func (x *DescribeConsumerResult_PartitionConsumerStats) GetConnectionNodeId() int32 {
	if x != nil && x.ConnectionNodeId != nil {
		return *x.ConnectionNodeId
	}
	return 0
}

func (x *DescribeConsumerResult_PartitionConsumerStats) SetLastReadOffset(v int64) {
	x.LastReadOffset = &v
}

func (x *DescribeConsumerResult_PartitionConsumerStats) SetCommittedOffset(v int64) {
	x.CommittedOffset = &v
}

func (x *DescribeConsumerResult_PartitionConsumerStats) SetReadSessionId(v string) {
	x.ReadSessionId = &v
}

func (x *DescribeConsumerResult_PartitionConsumerStats) SetPartitionReadSessionCreateTime(v *timestamppb.Timestamp) {
	x.PartitionReadSessionCreateTime = v
}

func (x *DescribeConsumerResult_PartitionConsumerStats) SetLastReadTime(v *timestamppb.Timestamp) {
	x.LastReadTime = v
}

func (x *DescribeConsumerResult_PartitionConsumerStats) SetMaxReadTimeLag(v *durationpb.Duration) {
	x.MaxReadTimeLag = v
}

func (x *DescribeConsumerResult_PartitionConsumerStats) SetMaxWriteTimeLag(v *durationpb.Duration) {
	x.MaxWriteTimeLag = v
}

func (x *DescribeConsumerResult_PartitionConsumerStats) SetBytesRead(v *MultipleWindowsStat) {
	x.BytesRead = v
}

func (x *DescribeConsumerResult_PartitionConsumerStats) SetReaderName(v string) {
	x.ReaderName = &v
}

func (x *DescribeConsumerResult_PartitionConsumerStats) SetConnectionNodeId(v int32) {
	x.ConnectionNodeId = &v
}

func (x *DescribeConsumerResult_PartitionConsumerStats) HasLastReadOffset() bool {
	if x == nil {
		return false
	}
	return x.LastReadOffset != nil
}

func (x *DescribeConsumerResult_PartitionConsumerStats) HasCommittedOffset() bool {
	if x == nil {
		return false
	}
	return x.CommittedOffset != nil
}

func (x *DescribeConsumerResult_PartitionConsumerStats) HasReadSessionId() bool {
	if x == nil {
		return false
	}
	return x.ReadSessionId != nil
}

func (x *DescribeConsumerResult_PartitionConsumerStats) HasPartitionReadSessionCreateTime() bool {
	if x == nil {
		return false
	}
	return x.PartitionReadSessionCreateTime != nil
}

func (x *DescribeConsumerResult_PartitionConsumerStats) HasLastReadTime() bool {
	if x == nil {
		return false
	}
	return x.LastReadTime != nil
}

func (x *DescribeConsumerResult_PartitionConsumerStats) HasMaxReadTimeLag() bool {
	if x == nil {
		return false
	}
	return x.MaxReadTimeLag != nil
}

func (x *DescribeConsumerResult_PartitionConsumerStats) HasMaxWriteTimeLag() bool {
	if x == nil {
		return false
	}
	return x.MaxWriteTimeLag != nil
}

func (x *DescribeConsumerResult_PartitionConsumerStats) HasBytesRead() bool {
	if x == nil {
		return false
	}
	return x.BytesRead != nil
}

func (x *DescribeConsumerResult_PartitionConsumerStats) HasReaderName() bool {
	if x == nil {
		return false
	}
	return x.ReaderName != nil
}

func (x *DescribeConsumerResult_PartitionConsumerStats) HasConnectionNodeId() bool {
	if x == nil {
		return false
	}
	return x.ConnectionNodeId != nil
}

func (x *DescribeConsumerResult_PartitionConsumerStats) ClearLastReadOffset() {
	x.LastReadOffset = nil
}

func (x *DescribeConsumerResult_PartitionConsumerStats) ClearCommittedOffset() {
	x.CommittedOffset = nil
}

func (x *DescribeConsumerResult_PartitionConsumerStats) ClearReadSessionId() {
	x.ReadSessionId = nil
}

func (x *DescribeConsumerResult_PartitionConsumerStats) ClearPartitionReadSessionCreateTime() {
	x.PartitionReadSessionCreateTime = nil
}

func (x *DescribeConsumerResult_PartitionConsumerStats) ClearLastReadTime() {
	x.LastReadTime = nil
}

func (x *DescribeConsumerResult_PartitionConsumerStats) ClearMaxReadTimeLag() {
	x.MaxReadTimeLag = nil
}

func (x *DescribeConsumerResult_PartitionConsumerStats) ClearMaxWriteTimeLag() {
	x.MaxWriteTimeLag = nil
}

func (x *DescribeConsumerResult_PartitionConsumerStats) ClearBytesRead() {
	x.BytesRead = nil
}

func (x *DescribeConsumerResult_PartitionConsumerStats) ClearReaderName() {
	x.ReaderName = nil
}

func (x *DescribeConsumerResult_PartitionConsumerStats) ClearConnectionNodeId() {
	x.ConnectionNodeId = nil
}

type DescribeConsumerResult_PartitionConsumerStats_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Last read offset from this partition.
	LastReadOffset *int64
	// Committed offset for this partition.
	CommittedOffset *int64
	// Reading this partition read session identifier.
	ReadSessionId *string
	// Timestamp of providing this partition to this session by server.
	PartitionReadSessionCreateTime *timestamppb.Timestamp
	// Timestamp of last read from this partition.
	LastReadTime *timestamppb.Timestamp
	// Maximum of differences between timestamp of read and write timestamp for all messages, read during last minute.
	MaxReadTimeLag *durationpb.Duration
	// Maximum of differences between write timestamp and create timestamp for all messages, read during last minute.
	MaxWriteTimeLag *durationpb.Duration
	// How much bytes were read during several windows statistics from this partition.
	BytesRead *MultipleWindowsStat
	// Read session name, provided by client.
	ReaderName *string
	// Host where read session connected.
	ConnectionNodeId *int32
}

func (b0 DescribeConsumerResult_PartitionConsumerStats_builder) Build() *DescribeConsumerResult_PartitionConsumerStats {
	m0 := &DescribeConsumerResult_PartitionConsumerStats{}
	b, x := &b0, m0
	_, _ = b, x
	x.LastReadOffset = b.LastReadOffset
	x.CommittedOffset = b.CommittedOffset
	x.ReadSessionId = b.ReadSessionId
	x.PartitionReadSessionCreateTime = b.PartitionReadSessionCreateTime
	x.LastReadTime = b.LastReadTime
	x.MaxReadTimeLag = b.MaxReadTimeLag
	x.MaxWriteTimeLag = b.MaxWriteTimeLag
	x.BytesRead = b.BytesRead
	x.ReaderName = b.ReaderName
	x.ConnectionNodeId = b.ConnectionNodeId
	return m0
}

var File_protos_ydb_topic_proto protoreflect.FileDescriptor

const file_protos_ydb_topic_proto_rawDesc = "" +
	"\n" +
	"\x16protos/ydb_topic.proto\x12\tYdb.Topic\x1a\x1aprotos/ydb_operation.proto\x1a\x17protos/ydb_scheme.proto\x1a\x1dprotos/ydb_status_codes.proto\x1a\x1eprotos/ydb_issue_message.proto\x1a\"protos/annotations/sensitive.proto\x1a#protos/annotations/validation.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a!google/protobuf/go_features.proto\"?\n" +
	"\x0fSupportedCodecs\x12,\n" +
	"\x06codecs\x18\x01 \x03(\x05B\x14\x9a\xe6*\x02\x18d\xb2\xe6*\n" +
	"[1; 19999]R\x06codecs\"6\n" +
	"\fOffsetsRange\x12\x14\n" +
	"\x05start\x18\x01 \x01(\x03R\x05start\x12\x10\n" +
	"\x03end\x18\x02 \x01(\x03R\x03end\"0\n" +
	"\x12UpdateTokenRequest\x12\x1a\n" +
	"\x05token\x18\x01 \x01(\tB\x04\xb8\xe6*\x01R\x05token\"\x15\n" +
	"\x13UpdateTokenResponse\"\\\n" +
	"\x17PartitionWithGeneration\x12!\n" +
	"\fpartition_id\x18\x01 \x01(\x03R\vpartitionId\x12\x1e\n" +
	"\n" +
	"generation\x18\x02 \x01(\x03R\n" +
	"generation\"6\n" +
	"\fMetadataItem\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value\"\xe9\x18\n" +
	"\x12StreamWriteMessage\x1a\x94\x02\n" +
	"\n" +
	"FromClient\x12N\n" +
	"\finit_request\x18\x01 \x01(\v2).Ydb.Topic.StreamWriteMessage.InitRequestH\x00R\vinitRequest\x12Q\n" +
	"\rwrite_request\x18\x02 \x01(\v2*.Ydb.Topic.StreamWriteMessage.WriteRequestH\x00R\fwriteRequest\x12Q\n" +
	"\x14update_token_request\x18\x03 \x01(\v2\x1d.Ydb.Topic.UpdateTokenRequestH\x00R\x12updateTokenRequestB\x10\n" +
	"\x0eclient_message\x1a\x81\x03\n" +
	"\n" +
	"FromServer\x121\n" +
	"\x06status\x18\x01 \x01(\x0e2\x19.Ydb.StatusIds.StatusCodeR\x06status\x12/\n" +
	"\x06issues\x18\x02 \x03(\v2\x17.Ydb.Issue.IssueMessageR\x06issues\x12Q\n" +
	"\rinit_response\x18\x03 \x01(\v2*.Ydb.Topic.StreamWriteMessage.InitResponseH\x00R\finitResponse\x12T\n" +
	"\x0ewrite_response\x18\x04 \x01(\v2+.Ydb.Topic.StreamWriteMessage.WriteResponseH\x00R\rwriteResponse\x12T\n" +
	"\x15update_token_response\x18\x05 \x01(\v2\x1e.Ydb.Topic.UpdateTokenResponseH\x00R\x13updateTokenResponseB\x10\n" +
	"\x0eserver_message\x1a\xf2\x03\n" +
	"\vInitRequest\x12\x12\n" +
	"\x04path\x18\x01 \x01(\tR\x04path\x12(\n" +
	"\vproducer_id\x18\x02 \x01(\tB\a\xa2\xe6*\x03\x18\x80\x10R\n" +
	"producerId\x12m\n" +
	"\x12write_session_meta\x18\x03 \x03(\v2?.Ydb.Topic.StreamWriteMessage.InitRequest.WriteSessionMetaEntryR\x10writeSessionMeta\x123\n" +
	"\x10message_group_id\x18\x04 \x01(\tB\a\xa2\xe6*\x03\x18\x80\x10H\x00R\x0emessageGroupId\x12#\n" +
	"\fpartition_id\x18\x05 \x01(\x03H\x00R\vpartitionId\x12`\n" +
	"\x19partition_with_generation\x18\a \x01(\v2\".Ydb.Topic.PartitionWithGenerationH\x00R\x17partitionWithGeneration\x12%\n" +
	"\x0fget_last_seq_no\x18\x06 \x01(\bR\fgetLastSeqNo\x1aC\n" +
	"\x15WriteSessionMetaEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01B\x0e\n" +
	"\fpartitioning\x1a\xb7\x01\n" +
	"\fInitResponse\x12\x1e\n" +
	"\vlast_seq_no\x18\x01 \x01(\x03R\tlastSeqNo\x12\x1d\n" +
	"\n" +
	"session_id\x18\x02 \x01(\tR\tsessionId\x12!\n" +
	"\fpartition_id\x18\x03 \x01(\x03R\vpartitionId\x12E\n" +
	"\x10supported_codecs\x18\x04 \x01(\v2\x1a.Ydb.Topic.SupportedCodecsR\x0fsupportedCodecs\x1a\xe0\x04\n" +
	"\fWriteRequest\x12R\n" +
	"\bmessages\x18\x01 \x03(\v26.Ydb.Topic.StreamWriteMessage.WriteRequest.MessageDataR\bmessages\x12\x14\n" +
	"\x05codec\x18\x02 \x01(\x05R\x05codec\x12.\n" +
	"\x02tx\x18\x03 \x01(\v2\x1e.Ydb.Topic.TransactionIdentityR\x02tx\x1a\xb5\x03\n" +
	"\vMessageData\x12\x15\n" +
	"\x06seq_no\x18\x01 \x01(\x03R\x05seqNo\x129\n" +
	"\n" +
	"created_at\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\x12\x12\n" +
	"\x04data\x18\x03 \x01(\fR\x04data\x12+\n" +
	"\x11uncompressed_size\x18\x04 \x01(\x03R\x10uncompressedSize\x123\n" +
	"\x10message_group_id\x18\x05 \x01(\tB\a\xa2\xe6*\x03\x18\x80\x10H\x00R\x0emessageGroupId\x12#\n" +
	"\fpartition_id\x18\x06 \x01(\x03H\x00R\vpartitionId\x12`\n" +
	"\x19partition_with_generation\x18\b \x01(\v2\".Ydb.Topic.PartitionWithGenerationH\x00R\x17partitionWithGeneration\x12G\n" +
	"\x0emetadata_items\x18\a \x03(\v2\x17.Ydb.Topic.MetadataItemB\a\x9a\xe6*\x03\x18\xe8\aR\rmetadataItemsB\x0e\n" +
	"\fpartitioning\x1a\xa5\t\n" +
	"\rWriteResponse\x12H\n" +
	"\x04acks\x18\x01 \x03(\v24.Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAckR\x04acks\x12!\n" +
	"\fpartition_id\x18\x02 \x01(\x03R\vpartitionId\x12f\n" +
	"\x10write_statistics\x18\x03 \x01(\v2;.Ydb.Topic.StreamWriteMessage.WriteResponse.WriteStatisticsR\x0fwriteStatistics\x1a\xae\x04\n" +
	"\bWriteAck\x12\x15\n" +
	"\x06seq_no\x18\x01 \x01(\x03R\x05seqNo\x12X\n" +
	"\awritten\x18\x02 \x01(\v2<.Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.WrittenH\x00R\awritten\x12X\n" +
	"\askipped\x18\x03 \x01(\v2<.Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.SkippedH\x00R\askipped\x12f\n" +
	"\rwritten_in_tx\x18\x04 \x01(\v2@.Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.WrittenInTxH\x00R\vwrittenInTx\x1a!\n" +
	"\aWritten\x12\x16\n" +
	"\x06offset\x18\x01 \x01(\x03R\x06offset\x1a\xa4\x01\n" +
	"\aSkipped\x12[\n" +
	"\x06reason\x18\x01 \x01(\x0e2C.Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.Skipped.ReasonR\x06reason\"<\n" +
	"\x06Reason\x12\x16\n" +
	"\x12REASON_UNSPECIFIED\x10\x00\x12\x1a\n" +
	"\x16REASON_ALREADY_WRITTEN\x10\x01\x1a\r\n" +
	"\vWrittenInTxB\x16\n" +
	"\x14message_write_status\x1a\x8d\x03\n" +
	"\x0fWriteStatistics\x12B\n" +
	"\x0fpersisting_time\x18\x01 \x01(\v2\x19.google.protobuf.DurationR\x0epersistingTime\x12H\n" +
	"\x13min_queue_wait_time\x18\x02 \x01(\v2\x19.google.protobuf.DurationR\x10minQueueWaitTime\x12H\n" +
	"\x13max_queue_wait_time\x18\x03 \x01(\v2\x19.google.protobuf.DurationR\x10maxQueueWaitTime\x12T\n" +
	"\x19partition_quota_wait_time\x18\x04 \x01(\v2\x19.google.protobuf.DurationR\x16partitionQuotaWaitTime\x12L\n" +
	"\x15topic_quota_wait_time\x18\x05 \x01(\v2\x19.google.protobuf.DurationR\x12topicQuotaWaitTime\"\xb4-\n" +
	"\x11StreamReadMessage\x1a{\n" +
	"\x10PartitionSession\x120\n" +
	"\x14partition_session_id\x18\x01 \x01(\x03R\x12partitionSessionId\x12\x12\n" +
	"\x04path\x18\x02 \x01(\tR\x04path\x12!\n" +
	"\fpartition_id\x18\x03 \x01(\x03R\vpartitionId\x1a\xe2\x06\n" +
	"\n" +
	"FromClient\x12M\n" +
	"\finit_request\x18\x01 \x01(\v2(.Ydb.Topic.StreamReadMessage.InitRequestH\x00R\vinitRequest\x12M\n" +
	"\fread_request\x18\x02 \x01(\v2(.Ydb.Topic.StreamReadMessage.ReadRequestH\x00R\vreadRequest\x12f\n" +
	"\x15commit_offset_request\x18\x03 \x01(\v20.Ydb.Topic.StreamReadMessage.CommitOffsetRequestH\x00R\x13commitOffsetRequest\x12\x85\x01\n" +
	" partition_session_status_request\x18\x04 \x01(\v2:.Ydb.Topic.StreamReadMessage.PartitionSessionStatusRequestH\x00R\x1dpartitionSessionStatusRequest\x12Q\n" +
	"\x14update_token_request\x18\x05 \x01(\v2\x1d.Ydb.Topic.UpdateTokenRequestH\x00R\x12updateTokenRequest\x12T\n" +
	"\x0fdirect_read_ack\x18\b \x01(\v2*.Ydb.Topic.StreamReadMessage.DirectReadAckH\x00R\rdirectReadAck\x12\x85\x01\n" +
	" start_partition_session_response\x18\x06 \x01(\v2:.Ydb.Topic.StreamReadMessage.StartPartitionSessionResponseH\x00R\x1dstartPartitionSessionResponse\x12\x82\x01\n" +
	"\x1fstop_partition_session_response\x18\a \x01(\v29.Ydb.Topic.StreamReadMessage.StopPartitionSessionResponseH\x00R\x1cstopPartitionSessionResponseB\x10\n" +
	"\x0eclient_message\x1a\xd1\b\n" +
	"\n" +
	"FromServer\x121\n" +
	"\x06status\x18\x01 \x01(\x0e2\x19.Ydb.StatusIds.StatusCodeR\x06status\x12/\n" +
	"\x06issues\x18\x02 \x03(\v2\x17.Ydb.Issue.IssueMessageR\x06issues\x12P\n" +
	"\rinit_response\x18\x03 \x01(\v2).Ydb.Topic.StreamReadMessage.InitResponseH\x00R\finitResponse\x12P\n" +
	"\rread_response\x18\x04 \x01(\v2).Ydb.Topic.StreamReadMessage.ReadResponseH\x00R\freadResponse\x12i\n" +
	"\x16commit_offset_response\x18\x05 \x01(\v21.Ydb.Topic.StreamReadMessage.CommitOffsetResponseH\x00R\x14commitOffsetResponse\x12\x88\x01\n" +
	"!partition_session_status_response\x18\x06 \x01(\v2;.Ydb.Topic.StreamReadMessage.PartitionSessionStatusResponseH\x00R\x1epartitionSessionStatusResponse\x12T\n" +
	"\x15update_token_response\x18\a \x01(\v2\x1e.Ydb.Topic.UpdateTokenResponseH\x00R\x13updateTokenResponse\x12\x82\x01\n" +
	"\x1fstart_partition_session_request\x18\b \x01(\v29.Ydb.Topic.StreamReadMessage.StartPartitionSessionRequestH\x00R\x1cstartPartitionSessionRequest\x12\x7f\n" +
	"\x1estop_partition_session_request\x18\t \x01(\v28.Ydb.Topic.StreamReadMessage.StopPartitionSessionRequestH\x00R\x1bstopPartitionSessionRequest\x12o\n" +
	"\x18update_partition_session\x18\n" +
	" \x01(\v23.Ydb.Topic.StreamReadMessage.UpdatePartitionSessionH\x00R\x16updatePartitionSession\x12f\n" +
	"\x15end_partition_session\x18\v \x01(\v20.Ydb.Topic.StreamReadMessage.EndPartitionSessionH\x00R\x13endPartitionSessionB\x10\n" +
	"\x0eserver_message\x1a\xd1\x03\n" +
	"\vInitRequest\x12l\n" +
	"\x14topics_read_settings\x18\x01 \x03(\v2:.Ydb.Topic.StreamReadMessage.InitRequest.TopicReadSettingsR\x12topicsReadSettings\x12\x1a\n" +
	"\bconsumer\x18\x02 \x01(\tR\bconsumer\x12\x1f\n" +
	"\vreader_name\x18\x03 \x01(\tR\n" +
	"readerName\x12\x1f\n" +
	"\vdirect_read\x18\x04 \x01(\bR\n" +
	"directRead\x12:\n" +
	"\x19auto_partitioning_support\x18\x05 \x01(\bR\x17autoPartitioningSupport\x1a\xb9\x01\n" +
	"\x11TopicReadSettings\x12\x12\n" +
	"\x04path\x18\x01 \x01(\tR\x04path\x12#\n" +
	"\rpartition_ids\x18\x02 \x03(\x03R\fpartitionIds\x122\n" +
	"\amax_lag\x18\x03 \x01(\v2\x19.google.protobuf.DurationR\x06maxLag\x127\n" +
	"\tread_from\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\breadFrom\x1a-\n" +
	"\fInitResponse\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\x1a,\n" +
	"\vReadRequest\x12\x1d\n" +
	"\n" +
	"bytes_size\x18\x01 \x01(\x03R\tbytesSize\x1a\xe3\a\n" +
	"\fReadResponse\x12^\n" +
	"\x0epartition_data\x18\x01 \x03(\v27.Ydb.Topic.StreamReadMessage.ReadResponse.PartitionDataR\rpartitionData\x12\x1d\n" +
	"\n" +
	"bytes_size\x18\x02 \x01(\x03R\tbytesSize\x1a\xab\x02\n" +
	"\vMessageData\x12\x16\n" +
	"\x06offset\x18\x01 \x01(\x03R\x06offset\x12\x15\n" +
	"\x06seq_no\x18\x02 \x01(\x03R\x05seqNo\x129\n" +
	"\n" +
	"created_at\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\x12\x12\n" +
	"\x04data\x18\x05 \x01(\fR\x04data\x12+\n" +
	"\x11uncompressed_size\x18\x06 \x01(\x03R\x10uncompressedSize\x121\n" +
	"\x10message_group_id\x18\a \x01(\tB\a\xa2\xe6*\x03\x18\x80\x10R\x0emessageGroupId\x12>\n" +
	"\x0emetadata_items\x18\b \x03(\v2\x17.Ydb.Topic.MetadataItemR\rmetadataItems\x1a\x96\x03\n" +
	"\x05Batch\x12X\n" +
	"\fmessage_data\x18\x01 \x03(\v25.Ydb.Topic.StreamReadMessage.ReadResponse.MessageDataR\vmessageData\x12(\n" +
	"\vproducer_id\x18\x02 \x01(\tB\a\xa2\xe6*\x03\x18\x80\x10R\n" +
	"producerId\x12s\n" +
	"\x12write_session_meta\x18\x03 \x03(\v2E.Ydb.Topic.StreamReadMessage.ReadResponse.Batch.WriteSessionMetaEntryR\x10writeSessionMeta\x12\x14\n" +
	"\x05codec\x18\x04 \x01(\x05R\x05codec\x129\n" +
	"\n" +
	"written_at\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\twrittenAt\x1aC\n" +
	"\x15WriteSessionMetaEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1a\x8c\x01\n" +
	"\rPartitionData\x120\n" +
	"\x14partition_session_id\x18\x01 \x01(\x03R\x12partitionSessionId\x12I\n" +
	"\abatches\x18\x02 \x03(\v2/.Ydb.Topic.StreamReadMessage.ReadResponse.BatchR\abatches\x1a\x82\x02\n" +
	"\x13CommitOffsetRequest\x12m\n" +
	"\x0ecommit_offsets\x18\x01 \x03(\v2F.Ydb.Topic.StreamReadMessage.CommitOffsetRequest.PartitionCommitOffsetR\rcommitOffsets\x1a|\n" +
	"\x15PartitionCommitOffset\x120\n" +
	"\x14partition_session_id\x18\x01 \x01(\x03R\x12partitionSessionId\x121\n" +
	"\aoffsets\x18\x02 \x03(\v2\x17.Ydb.Topic.OffsetsRangeR\aoffsets\x1a\x9e\x02\n" +
	"\x14CommitOffsetResponse\x12\x8c\x01\n" +
	"\x1cpartitions_committed_offsets\x18\x01 \x03(\v2J.Ydb.Topic.StreamReadMessage.CommitOffsetResponse.PartitionCommittedOffsetR\x1apartitionsCommittedOffsets\x1aw\n" +
	"\x18PartitionCommittedOffset\x120\n" +
	"\x14partition_session_id\x18\x01 \x01(\x03R\x12partitionSessionId\x12)\n" +
	"\x10committed_offset\x18\x02 \x01(\x03R\x0fcommittedOffset\x1aQ\n" +
	"\x1dPartitionSessionStatusRequest\x120\n" +
	"\x14partition_session_id\x18\x01 \x01(\x03R\x12partitionSessionId\x1a\x9a\x02\n" +
	"\x1ePartitionSessionStatusResponse\x120\n" +
	"\x14partition_session_id\x18\x01 \x01(\x03R\x12partitionSessionId\x12D\n" +
	"\x11partition_offsets\x18\x02 \x01(\v2\x17.Ydb.Topic.OffsetsRangeR\x10partitionOffsets\x12)\n" +
	"\x10committed_offset\x18\x03 \x01(\x03R\x0fcommittedOffset\x12U\n" +
	"\x19write_time_high_watermark\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\x16writeTimeHighWatermark\x1a\xb8\x02\n" +
	"\x1cStartPartitionSessionRequest\x12Z\n" +
	"\x11partition_session\x18\x01 \x01(\v2-.Ydb.Topic.StreamReadMessage.PartitionSessionR\x10partitionSession\x12)\n" +
	"\x10committed_offset\x18\x02 \x01(\x03R\x0fcommittedOffset\x12D\n" +
	"\x11partition_offsets\x18\x03 \x01(\v2\x17.Ydb.Topic.OffsetsRangeR\x10partitionOffsets\x12K\n" +
	"\x12partition_location\x18\x04 \x01(\v2\x1c.Ydb.Topic.PartitionLocationR\x11partitionLocation\x1a\x97\x01\n" +
	"\x1dStartPartitionSessionResponse\x120\n" +
	"\x14partition_session_id\x18\x01 \x01(\x03R\x12partitionSessionId\x12\x1f\n" +
	"\vread_offset\x18\x02 \x01(\x03R\n" +
	"readOffset\x12#\n" +
	"\rcommit_offset\x18\x03 \x01(\x03R\fcommitOffset\x1a\xc5\x01\n" +
	"\x1bStopPartitionSessionRequest\x120\n" +
	"\x14partition_session_id\x18\x01 \x01(\x03R\x12partitionSessionId\x12\x1a\n" +
	"\bgraceful\x18\x02 \x01(\bR\bgraceful\x12)\n" +
	"\x10committed_offset\x18\x03 \x01(\x03R\x0fcommittedOffset\x12-\n" +
	"\x13last_direct_read_id\x18\x04 \x01(\x03R\x10lastDirectReadId\x1al\n" +
	"\x1cStopPartitionSessionResponse\x120\n" +
	"\x14partition_session_id\x18\x01 \x01(\x03R\x12partitionSessionId\x12\x1a\n" +
	"\bgraceful\x18\x02 \x01(\bR\bgraceful\x1a\x97\x01\n" +
	"\x16UpdatePartitionSession\x120\n" +
	"\x14partition_session_id\x18\x01 \x01(\x03R\x12partitionSessionId\x12K\n" +
	"\x12partition_location\x18\x02 \x01(\v2\x1c.Ydb.Topic.PartitionLocationR\x11partitionLocation\x1ag\n" +
	"\rDirectReadAck\x120\n" +
	"\x14partition_session_id\x18\x01 \x01(\x03R\x12partitionSessionId\x12$\n" +
	"\x0edirect_read_id\x18\x02 \x01(\x03R\fdirectReadId\x1a\xad\x01\n" +
	"\x13EndPartitionSession\x120\n" +
	"\x14partition_session_id\x18\x01 \x01(\x03R\x12partitionSessionId\x124\n" +
	"\x16adjacent_partition_ids\x18\x02 \x03(\x03R\x14adjacentPartitionIds\x12.\n" +
	"\x13child_partition_ids\x18\x03 \x03(\x03R\x11childPartitionIds\"\xb4\x10\n" +
	"\x17StreamDirectReadMessage\x1a\xf1\x02\n" +
	"\n" +
	"FromClient\x12S\n" +
	"\finit_request\x18\x01 \x01(\v2..Ydb.Topic.StreamDirectReadMessage.InitRequestH\x00R\vinitRequest\x12\xa8\x01\n" +
	"+start_direct_read_partition_session_request\x18\x02 \x01(\v2I.Ydb.Topic.StreamDirectReadMessage.StartDirectReadPartitionSessionRequestH\x00R&startDirectReadPartitionSessionRequest\x12Q\n" +
	"\x14update_token_request\x18\x03 \x01(\v2\x1d.Ydb.Topic.UpdateTokenRequestH\x00R\x12updateTokenRequestB\x10\n" +
	"\x0eclient_message\x1a\xdb\x05\n" +
	"\n" +
	"FromServer\x121\n" +
	"\x06status\x18\x01 \x01(\x0e2\x19.Ydb.StatusIds.StatusCodeR\x06status\x12/\n" +
	"\x06issues\x18\x02 \x03(\v2\x17.Ydb.Issue.IssueMessageR\x06issues\x12V\n" +
	"\rinit_response\x18\x06 \x01(\v2/.Ydb.Topic.StreamDirectReadMessage.InitResponseH\x00R\finitResponse\x12\xab\x01\n" +
	",start_direct_read_partition_session_response\x18\a \x01(\v2J.Ydb.Topic.StreamDirectReadMessage.StartDirectReadPartitionSessionResponseH\x00R'startDirectReadPartitionSessionResponse\x12\x8f\x01\n" +
	"\"stop_direct_read_partition_session\x18\x03 \x01(\v2A.Ydb.Topic.StreamDirectReadMessage.StopDirectReadPartitionSessionH\x00R\x1estopDirectReadPartitionSession\x12i\n" +
	"\x14direct_read_response\x18\x04 \x01(\v25.Ydb.Topic.StreamDirectReadMessage.DirectReadResponseH\x00R\x12directReadResponse\x12T\n" +
	"\x15update_token_response\x18\x05 \x01(\v2\x1e.Ydb.Topic.UpdateTokenResponseH\x00R\x13updateTokenResponseB\x10\n" +
	"\x0eserver_message\x1a\xe5\x01\n" +
	"\vInitRequest\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\x12r\n" +
	"\x14topics_read_settings\x18\x02 \x03(\v2@.Ydb.Topic.StreamDirectReadMessage.InitRequest.TopicReadSettingsR\x12topicsReadSettings\x12\x1a\n" +
	"\bconsumer\x18\x03 \x01(\tR\bconsumer\x1a'\n" +
	"\x11TopicReadSettings\x12\x12\n" +
	"\x04path\x18\x01 \x01(\tR\x04path\x1a\x0e\n" +
	"\fInitResponse\x1a\xa9\x01\n" +
	"&StartDirectReadPartitionSessionRequest\x120\n" +
	"\x14partition_session_id\x18\x01 \x01(\x03R\x12partitionSessionId\x12-\n" +
	"\x13last_direct_read_id\x18\x02 \x01(\x03R\x10lastDirectReadId\x12\x1e\n" +
	"\n" +
	"generation\x18\x03 \x01(\x03R\n" +
	"generation\x1a{\n" +
	"'StartDirectReadPartitionSessionResponse\x120\n" +
	"\x14partition_session_id\x18\x01 \x01(\x03R\x12partitionSessionId\x12\x1e\n" +
	"\n" +
	"generation\x18\x02 \x01(\x03R\n" +
	"generation\x1a\xd6\x01\n" +
	"\x1eStopDirectReadPartitionSession\x121\n" +
	"\x06status\x18\x01 \x01(\x0e2\x19.Ydb.StatusIds.StatusCodeR\x06status\x12/\n" +
	"\x06issues\x18\x02 \x03(\v2\x17.Ydb.Issue.IssueMessageR\x06issues\x120\n" +
	"\x14partition_session_id\x18\x03 \x01(\x03R\x12partitionSessionId\x12\x1e\n" +
	"\n" +
	"generation\x18\x04 \x01(\x03R\n" +
	"generation\x1a\xcc\x01\n" +
	"\x12DirectReadResponse\x120\n" +
	"\x14partition_session_id\x18\x01 \x01(\x03R\x12partitionSessionId\x12$\n" +
	"\x0edirect_read_id\x18\x02 \x01(\x03R\fdirectReadId\x12^\n" +
	"\x0epartition_data\x18\x03 \x01(\v27.Ydb.Topic.StreamReadMessage.ReadResponse.PartitionDataR\rpartitionData\"?\n" +
	"\x13TransactionIdentity\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x18\n" +
	"\asession\x18\x02 \x01(\tR\asession\"\x9c\x04\n" +
	"!UpdateOffsetsInTransactionRequest\x12J\n" +
	"\x10operation_params\x18\x01 \x01(\v2\x1f.Ydb.Operations.OperationParamsR\x0foperationParams\x12.\n" +
	"\x02tx\x18\x02 \x01(\v2\x1e.Ydb.Topic.TransactionIdentityR\x02tx\x12Q\n" +
	"\x06topics\x18\x03 \x03(\v29.Ydb.Topic.UpdateOffsetsInTransactionRequest.TopicOffsetsR\x06topics\x12\x1a\n" +
	"\bconsumer\x18\x04 \x01(\tR\bconsumer\x1a\x8b\x02\n" +
	"\fTopicOffsets\x12\x12\n" +
	"\x04path\x18\x01 \x01(\tR\x04path\x12j\n" +
	"\n" +
	"partitions\x18\x02 \x03(\v2J.Ydb.Topic.UpdateOffsetsInTransactionRequest.TopicOffsets.PartitionOffsetsR\n" +
	"partitions\x1a{\n" +
	"\x10PartitionOffsets\x12!\n" +
	"\fpartition_id\x18\x01 \x01(\x03R\vpartitionId\x12D\n" +
	"\x11partition_offsets\x18\x02 \x03(\v2\x17.Ydb.Topic.OffsetsRangeR\x10partitionOffsets\"]\n" +
	"\"UpdateOffsetsInTransactionResponse\x127\n" +
	"\toperation\x18\x01 \x01(\v2\x19.Ydb.Operations.OperationR\toperation\"\"\n" +
	" UpdateOffsetsInTransactionResult\"\xcc\x01\n" +
	"\x13CommitOffsetRequest\x12J\n" +
	"\x10operation_params\x18\x01 \x01(\v2\x1f.Ydb.Operations.OperationParamsR\x0foperationParams\x12\x12\n" +
	"\x04path\x18\x02 \x01(\tR\x04path\x12!\n" +
	"\fpartition_id\x18\x03 \x01(\x03R\vpartitionId\x12\x1a\n" +
	"\bconsumer\x18\x04 \x01(\tR\bconsumer\x12\x16\n" +
	"\x06offset\x18\x05 \x01(\x03R\x06offset\"O\n" +
	"\x14CommitOffsetResponse\x127\n" +
	"\toperation\x18\x01 \x01(\v2\x19.Ydb.Operations.OperationR\toperation\"\x14\n" +
	"\x12CommitOffsetResult\"h\n" +
	"\x13MultipleWindowsStat\x12\x1d\n" +
	"\n" +
	"per_minute\x18\x01 \x01(\x03R\tperMinute\x12\x19\n" +
	"\bper_hour\x18\x02 \x01(\x03R\aperHour\x12\x17\n" +
	"\aper_day\x18\x03 \x01(\x03R\x06perDay\"\xcd\x05\n" +
	"\bConsumer\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x1c\n" +
	"\timportant\x18\x02 \x01(\bR\timportant\x127\n" +
	"\tread_from\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\breadFrom\x12E\n" +
	"\x10supported_codecs\x18\x05 \x01(\v2\x1a.Ydb.Topic.SupportedCodecsR\x0fsupportedCodecs\x12C\n" +
	"\n" +
	"attributes\x18\x06 \x03(\v2#.Ydb.Topic.Consumer.AttributesEntryR\n" +
	"attributes\x12H\n" +
	"\x0econsumer_stats\x18\a \x01(\v2!.Ydb.Topic.Consumer.ConsumerStatsR\rconsumerStats\x1a=\n" +
	"\x0fAttributesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1a\xba\x02\n" +
	"\rConsumerStats\x12\\\n" +
	"\x1dmin_partitions_last_read_time\x18\x01 \x01(\v2\x1a.google.protobuf.TimestampR\x19minPartitionsLastReadTime\x12D\n" +
	"\x11max_read_time_lag\x18\x02 \x01(\v2\x19.google.protobuf.DurationR\x0emaxReadTimeLag\x12F\n" +
	"\x12max_write_time_lag\x18\x03 \x01(\v2\x19.google.protobuf.DurationR\x0fmaxWriteTimeLag\x12=\n" +
	"\n" +
	"bytes_read\x18\x04 \x01(\v2\x1e.Ydb.Topic.MultipleWindowsStatR\tbytesReadJ\x04\b\x04\x10\x05\"\xfa\x02\n" +
	"\rAlterConsumer\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12#\n" +
	"\rset_important\x18\x02 \x01(\bR\fsetImportant\x12>\n" +
	"\rset_read_from\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\vsetReadFrom\x12L\n" +
	"\x14set_supported_codecs\x18\x05 \x01(\v2\x1a.Ydb.Topic.SupportedCodecsR\x12setSupportedCodecs\x12X\n" +
	"\x10alter_attributes\x18\x06 \x03(\v2-.Ydb.Topic.AlterConsumer.AlterAttributesEntryR\x0falterAttributes\x1aB\n" +
	"\x14AlterAttributesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01J\x04\b\x04\x10\x05\"\xb5\x02\n" +
	"\x14PartitioningSettings\x12<\n" +
	"\x15min_active_partitions\x18\x01 \x01(\x03B\b\xb2\xe6*\x04>= 0R\x13minActivePartitions\x12<\n" +
	"\x15max_active_partitions\x18\x03 \x01(\x03B\b\xb2\xe6*\x04>= 0R\x13maxActivePartitions\x12>\n" +
	"\x15partition_count_limit\x18\x02 \x01(\x03B\n" +
	"\xb2\xe6*\x04>= 0\x18\x01R\x13partitionCountLimit\x12a\n" +
	"\x1aauto_partitioning_settings\x18\x04 \x01(\v2#.Ydb.Topic.AutoPartitioningSettingsR\x18autoPartitioningSettings\"\xbe\x01\n" +
	"\x18AutoPartitioningSettings\x12?\n" +
	"\bstrategy\x18\x01 \x01(\x0e2#.Ydb.Topic.AutoPartitioningStrategyR\bstrategy\x12a\n" +
	"\x15partition_write_speed\x18\x02 \x01(\v2-.Ydb.Topic.AutoPartitioningWriteSpeedStrategyR\x13partitionWriteSpeed\"\xf6\x01\n" +
	"\"AutoPartitioningWriteSpeedStrategy\x12L\n" +
	"\x14stabilization_window\x18\x01 \x01(\v2\x19.google.protobuf.DurationR\x13stabilizationWindow\x12>\n" +
	"\x16up_utilization_percent\x18\x02 \x01(\x05B\b\xb2\xe6*\x04>= 0R\x14upUtilizationPercent\x12B\n" +
	"\x18down_utilization_percent\x18\x03 \x01(\x05B\b\xb2\xe6*\x04>= 0R\x16downUtilizationPercent\"\xdf\x02\n" +
	"\x19AlterPartitioningSettings\x12C\n" +
	"\x19set_min_active_partitions\x18\x01 \x01(\x03B\b\xb2\xe6*\x04>= 0R\x16setMinActivePartitions\x12C\n" +
	"\x19set_max_active_partitions\x18\x03 \x01(\x03B\b\xb2\xe6*\x04>= 0R\x16setMaxActivePartitions\x12E\n" +
	"\x19set_partition_count_limit\x18\x02 \x01(\x03B\n" +
	"\xb2\xe6*\x04>= 0\x18\x01R\x16setPartitionCountLimit\x12q\n" +
	" alter_auto_partitioning_settings\x18\x04 \x01(\v2(.Ydb.Topic.AlterAutoPartitioningSettingsR\x1dalterAutoPartitioningSettings\"\xd6\x01\n" +
	"\x1dAlterAutoPartitioningSettings\x12F\n" +
	"\fset_strategy\x18\x01 \x01(\x0e2#.Ydb.Topic.AutoPartitioningStrategyR\vsetStrategy\x12m\n" +
	"\x19set_partition_write_speed\x18\x02 \x01(\v22.Ydb.Topic.AlterAutoPartitioningWriteSpeedStrategyR\x16setPartitionWriteSpeed\"\x90\x02\n" +
	"'AlterAutoPartitioningWriteSpeedStrategy\x12S\n" +
	"\x18set_stabilization_window\x18\x01 \x01(\v2\x19.google.protobuf.DurationR\x16setStabilizationWindow\x12E\n" +
	"\x1aset_up_utilization_percent\x18\x02 \x01(\x05B\b\xb2\xe6*\x04>= 0R\x17setUpUtilizationPercent\x12I\n" +
	"\x1cset_down_utilization_percent\x18\x03 \x01(\x05B\b\xb2\xe6*\x04>= 0R\x19setDownUtilizationPercent\"\xc7\x06\n" +
	"\x12CreateTopicRequest\x12J\n" +
	"\x10operation_params\x18\x01 \x01(\v2\x1f.Ydb.Operations.OperationParamsR\x0foperationParams\x12\x12\n" +
	"\x04path\x18\x02 \x01(\tR\x04path\x12T\n" +
	"\x15partitioning_settings\x18\x03 \x01(\v2\x1f.Ydb.Topic.PartitioningSettingsR\x14partitioningSettings\x12D\n" +
	"\x10retention_period\x18\x04 \x01(\v2\x19.google.protobuf.DurationR\x0fretentionPeriod\x12:\n" +
	"\x14retention_storage_mb\x18\x05 \x01(\x03B\b\xb2\xe6*\x04>= 0R\x12retentionStorageMb\x12E\n" +
	"\x10supported_codecs\x18\a \x01(\v2\x1a.Ydb.Topic.SupportedCodecsR\x0fsupportedCodecs\x12[\n" +
	"&partition_write_speed_bytes_per_second\x18\b \x01(\x03B\b\xb2\xe6*\x04>= 0R!partitionWriteSpeedBytesPerSecond\x12G\n" +
	"\x1bpartition_write_burst_bytes\x18\t \x01(\x03B\b\xb2\xe6*\x04>= 0R\x18partitionWriteBurstBytes\x12M\n" +
	"\n" +
	"attributes\x18\n" +
	" \x03(\v2-.Ydb.Topic.CreateTopicRequest.AttributesEntryR\n" +
	"attributes\x12:\n" +
	"\tconsumers\x18\v \x03(\v2\x13.Ydb.Topic.ConsumerB\a\x9a\xe6*\x03\x18\xb8\x17R\tconsumers\x12<\n" +
	"\rmetering_mode\x18\f \x01(\x0e2\x17.Ydb.Topic.MeteringModeR\fmeteringMode\x1a=\n" +
	"\x0fAttributesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01J\x04\b\x06\x10\a\"N\n" +
	"\x13CreateTopicResponse\x127\n" +
	"\toperation\x18\x01 \x01(\v2\x19.Ydb.Operations.OperationR\toperation\"\x13\n" +
	"\x11CreateTopicResult\"L\n" +
	"\x11PartitionLocation\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\x05R\x06nodeId\x12\x1e\n" +
	"\n" +
	"generation\x18\x02 \x01(\x03R\n" +
	"generation\"\xc6\x01\n" +
	"\x14DescribeTopicRequest\x12J\n" +
	"\x10operation_params\x18\x01 \x01(\v2\x1f.Ydb.Operations.OperationParamsR\x0foperationParams\x12\x12\n" +
	"\x04path\x18\x02 \x01(\tR\x04path\x12#\n" +
	"\rinclude_stats\x18\x03 \x01(\bR\fincludeStats\x12)\n" +
	"\x10include_location\x18\x04 \x01(\bR\x0fincludeLocation\"P\n" +
	"\x15DescribeTopicResponse\x127\n" +
	"\toperation\x18\x01 \x01(\v2\x19.Ydb.Operations.OperationR\toperation\"M\n" +
	"\x11PartitionKeyRange\x12\x1d\n" +
	"\n" +
	"from_bound\x18\x01 \x01(\fR\tfromBound\x12\x19\n" +
	"\bto_bound\x18\x02 \x01(\fR\atoBound\"\xcd\r\n" +
	"\x13DescribeTopicResult\x12%\n" +
	"\x04self\x18\x01 \x01(\v2\x11.Ydb.Scheme.EntryR\x04self\x12T\n" +
	"\x15partitioning_settings\x18\x02 \x01(\v2\x1f.Ydb.Topic.PartitioningSettingsR\x14partitioningSettings\x12L\n" +
	"\n" +
	"partitions\x18\x03 \x03(\v2,.Ydb.Topic.DescribeTopicResult.PartitionInfoR\n" +
	"partitions\x12D\n" +
	"\x10retention_period\x18\x04 \x01(\v2\x19.google.protobuf.DurationR\x0fretentionPeriod\x120\n" +
	"\x14retention_storage_mb\x18\x05 \x01(\x03R\x12retentionStorageMb\x12E\n" +
	"\x10supported_codecs\x18\a \x01(\v2\x1a.Ydb.Topic.SupportedCodecsR\x0fsupportedCodecs\x12Q\n" +
	"&partition_write_speed_bytes_per_second\x18\b \x01(\x03R!partitionWriteSpeedBytesPerSecond\x12Z\n" +
	"+partition_total_read_speed_bytes_per_second\x18\x0e \x01(\x03R%partitionTotalReadSpeedBytesPerSecond\x12`\n" +
	".partition_consumer_read_speed_bytes_per_second\x18\x0f \x01(\x03R(partitionConsumerReadSpeedBytesPerSecond\x12=\n" +
	"\x1bpartition_write_burst_bytes\x18\t \x01(\x03R\x18partitionWriteBurstBytes\x12N\n" +
	"\n" +
	"attributes\x18\n" +
	" \x03(\v2..Ydb.Topic.DescribeTopicResult.AttributesEntryR\n" +
	"attributes\x121\n" +
	"\tconsumers\x18\v \x03(\v2\x13.Ydb.Topic.ConsumerR\tconsumers\x12<\n" +
	"\rmetering_mode\x18\f \x01(\x0e2\x17.Ydb.Topic.MeteringModeR\fmeteringMode\x12J\n" +
	"\vtopic_stats\x18\r \x01(\v2).Ydb.Topic.DescribeTopicResult.TopicStatsR\n" +
	"topicStats\x1a=\n" +
	"\x0fAttributesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1a\xf8\x02\n" +
	"\rPartitionInfo\x12!\n" +
	"\fpartition_id\x18\x01 \x01(\x03R\vpartitionId\x12\x16\n" +
	"\x06active\x18\x02 \x01(\bR\x06active\x12.\n" +
	"\x13child_partition_ids\x18\x03 \x03(\x03R\x11childPartitionIds\x120\n" +
	"\x14parent_partition_ids\x18\x04 \x03(\x03R\x12parentPartitionIds\x12B\n" +
	"\x0fpartition_stats\x18\x05 \x01(\v2\x19.Ydb.Topic.PartitionStatsR\x0epartitionStats\x12K\n" +
	"\x12partition_location\x18\x06 \x01(\v2\x1c.Ydb.Topic.PartitionLocationR\x11partitionLocation\x129\n" +
	"\tkey_range\x18\a \x01(\v2\x1c.Ydb.Topic.PartitionKeyRangeR\bkeyRange\x1a\x8e\x02\n" +
	"\n" +
	"TopicStats\x12(\n" +
	"\x10store_size_bytes\x18\x01 \x01(\x03R\x0estoreSizeBytes\x12I\n" +
	"\x13min_last_write_time\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\x10minLastWriteTime\x12F\n" +
	"\x12max_write_time_lag\x18\x03 \x01(\v2\x19.google.protobuf.DurationR\x0fmaxWriteTimeLag\x12C\n" +
	"\rbytes_written\x18\x04 \x01(\v2\x1e.Ydb.Topic.MultipleWindowsStatR\fbytesWrittenJ\x04\b\x06\x10\a\"\xed\x01\n" +
	"\x18DescribePartitionRequest\x12J\n" +
	"\x10operation_params\x18\x01 \x01(\v2\x1f.Ydb.Operations.OperationParamsR\x0foperationParams\x12\x12\n" +
	"\x04path\x18\x02 \x01(\tR\x04path\x12!\n" +
	"\fpartition_id\x18\x03 \x01(\x03R\vpartitionId\x12#\n" +
	"\rinclude_stats\x18\x04 \x01(\bR\fincludeStats\x12)\n" +
	"\x10include_location\x18\x05 \x01(\bR\x0fincludeLocation\"T\n" +
	"\x19DescribePartitionResponse\x127\n" +
	"\toperation\x18\x01 \x01(\v2\x19.Ydb.Operations.OperationR\toperation\"e\n" +
	"\x17DescribePartitionResult\x12J\n" +
	"\tpartition\x18\x01 \x01(\v2,.Ydb.Topic.DescribeTopicResult.PartitionInfoR\tpartition\"\xe5\x01\n" +
	"\x17DescribeConsumerRequest\x12J\n" +
	"\x10operation_params\x18\x01 \x01(\v2\x1f.Ydb.Operations.OperationParamsR\x0foperationParams\x12\x12\n" +
	"\x04path\x18\x02 \x01(\tR\x04path\x12\x1a\n" +
	"\bconsumer\x18\x03 \x01(\tR\bconsumer\x12#\n" +
	"\rinclude_stats\x18\x04 \x01(\bR\fincludeStats\x12)\n" +
	"\x10include_location\x18\x05 \x01(\bR\x0fincludeLocation\"S\n" +
	"\x18DescribeConsumerResponse\x127\n" +
	"\toperation\x18\x01 \x01(\v2\x19.Ydb.Operations.OperationR\toperation\"\xd3\t\n" +
	"\x16DescribeConsumerResult\x12%\n" +
	"\x04self\x18\x01 \x01(\v2\x11.Ydb.Scheme.EntryR\x04self\x12/\n" +
	"\bconsumer\x18\x02 \x01(\v2\x13.Ydb.Topic.ConsumerR\bconsumer\x12O\n" +
	"\n" +
	"partitions\x18\x03 \x03(\v2/.Ydb.Topic.DescribeConsumerResult.PartitionInfoR\n" +
	"partitions\x1a\xb1\x03\n" +
	"\rPartitionInfo\x12!\n" +
	"\fpartition_id\x18\x01 \x01(\x03R\vpartitionId\x12\x16\n" +
	"\x06active\x18\x02 \x01(\bR\x06active\x12.\n" +
	"\x13child_partition_ids\x18\x03 \x03(\x03R\x11childPartitionIds\x120\n" +
	"\x14parent_partition_ids\x18\x04 \x03(\x03R\x12parentPartitionIds\x12B\n" +
	"\x0fpartition_stats\x18\x05 \x01(\v2\x19.Ydb.Topic.PartitionStatsR\x0epartitionStats\x12r\n" +
	"\x18partition_consumer_stats\x18\x06 \x01(\v28.Ydb.Topic.DescribeConsumerResult.PartitionConsumerStatsR\x16partitionConsumerStats\x12K\n" +
	"\x12partition_location\x18\a \x01(\v2\x1c.Ydb.Topic.PartitionLocationR\x11partitionLocation\x1a\xdb\x04\n" +
	"\x16PartitionConsumerStats\x12(\n" +
	"\x10last_read_offset\x18\x01 \x01(\x03R\x0elastReadOffset\x12)\n" +
	"\x10committed_offset\x18\x02 \x01(\x03R\x0fcommittedOffset\x12&\n" +
	"\x0fread_session_id\x18\x03 \x01(\tR\rreadSessionId\x12f\n" +
	"\"partition_read_session_create_time\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\x1epartitionReadSessionCreateTime\x12@\n" +
	"\x0elast_read_time\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\flastReadTime\x12D\n" +
	"\x11max_read_time_lag\x18\x06 \x01(\v2\x19.google.protobuf.DurationR\x0emaxReadTimeLag\x12F\n" +
	"\x12max_write_time_lag\x18\a \x01(\v2\x19.google.protobuf.DurationR\x0fmaxWriteTimeLag\x12=\n" +
	"\n" +
	"bytes_read\x18\b \x01(\v2\x1e.Ydb.Topic.MultipleWindowsStatR\tbytesRead\x12\x1f\n" +
	"\vreader_name\x18\v \x01(\tR\n" +
	"readerName\x12,\n" +
	"\x12connection_node_id\x18\f \x01(\x05R\x10connectionNodeId\"\x81\x03\n" +
	"\x0ePartitionStats\x12D\n" +
	"\x11partition_offsets\x18\x01 \x01(\v2\x17.Ydb.Topic.OffsetsRangeR\x10partitionOffsets\x12(\n" +
	"\x10store_size_bytes\x18\x02 \x01(\x03R\x0estoreSizeBytes\x12B\n" +
	"\x0flast_write_time\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\rlastWriteTime\x12F\n" +
	"\x12max_write_time_lag\x18\x04 \x01(\v2\x19.google.protobuf.DurationR\x0fmaxWriteTimeLag\x12C\n" +
	"\rbytes_written\x18\x05 \x01(\v2\x1e.Ydb.Topic.MultipleWindowsStatR\fbytesWritten\x12.\n" +
	"\x11partition_node_id\x18\b \x01(\x05B\x02\x18\x01R\x0fpartitionNodeId\"\x97\b\n" +
	"\x11AlterTopicRequest\x12J\n" +
	"\x10operation_params\x18\x01 \x01(\v2\x1f.Ydb.Operations.OperationParamsR\x0foperationParams\x12\x12\n" +
	"\x04path\x18\x02 \x01(\tR\x04path\x12d\n" +
	"\x1balter_partitioning_settings\x18\x03 \x01(\v2$.Ydb.Topic.AlterPartitioningSettingsR\x19alterPartitioningSettings\x12K\n" +
	"\x14set_retention_period\x18\x04 \x01(\v2\x19.google.protobuf.DurationR\x12setRetentionPeriod\x12A\n" +
	"\x18set_retention_storage_mb\x18\x05 \x01(\x03B\b\xb2\xe6*\x04>= 0R\x15setRetentionStorageMb\x12L\n" +
	"\x14set_supported_codecs\x18\a \x01(\v2\x1a.Ydb.Topic.SupportedCodecsR\x12setSupportedCodecs\x12b\n" +
	"*set_partition_write_speed_bytes_per_second\x18\b \x01(\x03B\b\xb2\xe6*\x04>= 0R$setPartitionWriteSpeedBytesPerSecond\x12N\n" +
	"\x1fset_partition_write_burst_bytes\x18\t \x01(\x03B\b\xb2\xe6*\x04>= 0R\x1bsetPartitionWriteBurstBytes\x12\\\n" +
	"\x10alter_attributes\x18\n" +
	" \x03(\v21.Ydb.Topic.AlterTopicRequest.AlterAttributesEntryR\x0falterAttributes\x12A\n" +
	"\radd_consumers\x18\v \x03(\v2\x13.Ydb.Topic.ConsumerB\a\x9a\xe6*\x03\x18\xb8\x17R\faddConsumers\x12.\n" +
	"\x0edrop_consumers\x18\f \x03(\tB\a\x9a\xe6*\x03\x18\xb8\x17R\rdropConsumers\x12J\n" +
	"\x0falter_consumers\x18\r \x03(\v2\x18.Ydb.Topic.AlterConsumerB\a\x9a\xe6*\x03\x18\xb8\x17R\x0ealterConsumers\x12C\n" +
	"\x11set_metering_mode\x18\x0e \x01(\x0e2\x17.Ydb.Topic.MeteringModeR\x0fsetMeteringMode\x1aB\n" +
	"\x14AlterAttributesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01J\x04\b\x06\x10\a\"M\n" +
	"\x12AlterTopicResponse\x127\n" +
	"\toperation\x18\x01 \x01(\v2\x19.Ydb.Operations.OperationR\toperation\"\x12\n" +
	"\x10AlterTopicResult\"r\n" +
	"\x10DropTopicRequest\x12J\n" +
	"\x10operation_params\x18\x01 \x01(\v2\x1f.Ydb.Operations.OperationParamsR\x0foperationParams\x12\x12\n" +
	"\x04path\x18\x02 \x01(\tR\x04path\"L\n" +
	"\x11DropTopicResponse\x127\n" +
	"\toperation\x18\x01 \x01(\v2\x19.Ydb.Operations.OperationR\toperation\"\x11\n" +
	"\x0fDropTopicResult*\x83\x01\n" +
	"\x05Codec\x12\x15\n" +
	"\x11CODEC_UNSPECIFIED\x10\x00\x12\r\n" +
	"\tCODEC_RAW\x10\x01\x12\x0e\n" +
	"\n" +
	"CODEC_GZIP\x10\x02\x12\x0e\n" +
	"\n" +
	"CODEC_LZOP\x10\x03\x12\x0e\n" +
	"\n" +
	"CODEC_ZSTD\x10\x04\x12\x11\n" +
	"\fCODEC_CUSTOM\x10\x90N\"\x05\b\x05\x10\x8fN\"\n" +
	"\b\xa0\x9c\x01\x10\xff\xff\xff\xff\a*\xf1\x01\n" +
	"\x18AutoPartitioningStrategy\x12*\n" +
	"&AUTO_PARTITIONING_STRATEGY_UNSPECIFIED\x10\x00\x12'\n" +
	"#AUTO_PARTITIONING_STRATEGY_DISABLED\x10\x01\x12'\n" +
	"#AUTO_PARTITIONING_STRATEGY_SCALE_UP\x10\x02\x120\n" +
	",AUTO_PARTITIONING_STRATEGY_SCALE_UP_AND_DOWN\x10\x03\x12%\n" +
	"!AUTO_PARTITIONING_STRATEGY_PAUSED\x10\x04*s\n" +
	"\fMeteringMode\x12\x1d\n" +
	"\x19METERING_MODE_UNSPECIFIED\x10\x00\x12#\n" +
	"\x1fMETERING_MODE_RESERVED_CAPACITY\x10\x01\x12\x1f\n" +
	"\x1bMETERING_MODE_REQUEST_UNITS\x10\x02B[\n" +
	"\x14tech.ydb.proto.topicZ8github.com/ydb-platform/ydb-go-genproto/protos/Ydb_Topic\xf8\x01\x01\x92\x03\x05\xd2>\x02\x10\x02b\beditionsp\xe8\a"

var file_protos_ydb_topic_proto_enumTypes = make([]protoimpl.EnumInfo, 4)
var file_protos_ydb_topic_proto_msgTypes = make([]protoimpl.MessageInfo, 105)
var file_protos_ydb_topic_proto_goTypes = []any{
	(Codec)(0),                    // 0: Ydb.Topic.Codec
	(AutoPartitioningStrategy)(0), // 1: Ydb.Topic.AutoPartitioningStrategy
	(MeteringMode)(0),             // 2: Ydb.Topic.MeteringMode
	(StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason)(0), // 3: Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.Skipped.Reason
	(*SupportedCodecs)(nil),                                       // 4: Ydb.Topic.SupportedCodecs
	(*OffsetsRange)(nil),                                          // 5: Ydb.Topic.OffsetsRange
	(*UpdateTokenRequest)(nil),                                    // 6: Ydb.Topic.UpdateTokenRequest
	(*UpdateTokenResponse)(nil),                                   // 7: Ydb.Topic.UpdateTokenResponse
	(*PartitionWithGeneration)(nil),                               // 8: Ydb.Topic.PartitionWithGeneration
	(*MetadataItem)(nil),                                          // 9: Ydb.Topic.MetadataItem
	(*StreamWriteMessage)(nil),                                    // 10: Ydb.Topic.StreamWriteMessage
	(*StreamReadMessage)(nil),                                     // 11: Ydb.Topic.StreamReadMessage
	(*StreamDirectReadMessage)(nil),                               // 12: Ydb.Topic.StreamDirectReadMessage
	(*TransactionIdentity)(nil),                                   // 13: Ydb.Topic.TransactionIdentity
	(*UpdateOffsetsInTransactionRequest)(nil),                     // 14: Ydb.Topic.UpdateOffsetsInTransactionRequest
	(*UpdateOffsetsInTransactionResponse)(nil),                    // 15: Ydb.Topic.UpdateOffsetsInTransactionResponse
	(*UpdateOffsetsInTransactionResult)(nil),                      // 16: Ydb.Topic.UpdateOffsetsInTransactionResult
	(*CommitOffsetRequest)(nil),                                   // 17: Ydb.Topic.CommitOffsetRequest
	(*CommitOffsetResponse)(nil),                                  // 18: Ydb.Topic.CommitOffsetResponse
	(*CommitOffsetResult)(nil),                                    // 19: Ydb.Topic.CommitOffsetResult
	(*MultipleWindowsStat)(nil),                                   // 20: Ydb.Topic.MultipleWindowsStat
	(*Consumer)(nil),                                              // 21: Ydb.Topic.Consumer
	(*AlterConsumer)(nil),                                         // 22: Ydb.Topic.AlterConsumer
	(*PartitioningSettings)(nil),                                  // 23: Ydb.Topic.PartitioningSettings
	(*AutoPartitioningSettings)(nil),                              // 24: Ydb.Topic.AutoPartitioningSettings
	(*AutoPartitioningWriteSpeedStrategy)(nil),                    // 25: Ydb.Topic.AutoPartitioningWriteSpeedStrategy
	(*AlterPartitioningSettings)(nil),                             // 26: Ydb.Topic.AlterPartitioningSettings
	(*AlterAutoPartitioningSettings)(nil),                         // 27: Ydb.Topic.AlterAutoPartitioningSettings
	(*AlterAutoPartitioningWriteSpeedStrategy)(nil),               // 28: Ydb.Topic.AlterAutoPartitioningWriteSpeedStrategy
	(*CreateTopicRequest)(nil),                                    // 29: Ydb.Topic.CreateTopicRequest
	(*CreateTopicResponse)(nil),                                   // 30: Ydb.Topic.CreateTopicResponse
	(*CreateTopicResult)(nil),                                     // 31: Ydb.Topic.CreateTopicResult
	(*PartitionLocation)(nil),                                     // 32: Ydb.Topic.PartitionLocation
	(*DescribeTopicRequest)(nil),                                  // 33: Ydb.Topic.DescribeTopicRequest
	(*DescribeTopicResponse)(nil),                                 // 34: Ydb.Topic.DescribeTopicResponse
	(*PartitionKeyRange)(nil),                                     // 35: Ydb.Topic.PartitionKeyRange
	(*DescribeTopicResult)(nil),                                   // 36: Ydb.Topic.DescribeTopicResult
	(*DescribePartitionRequest)(nil),                              // 37: Ydb.Topic.DescribePartitionRequest
	(*DescribePartitionResponse)(nil),                             // 38: Ydb.Topic.DescribePartitionResponse
	(*DescribePartitionResult)(nil),                               // 39: Ydb.Topic.DescribePartitionResult
	(*DescribeConsumerRequest)(nil),                               // 40: Ydb.Topic.DescribeConsumerRequest
	(*DescribeConsumerResponse)(nil),                              // 41: Ydb.Topic.DescribeConsumerResponse
	(*DescribeConsumerResult)(nil),                                // 42: Ydb.Topic.DescribeConsumerResult
	(*PartitionStats)(nil),                                        // 43: Ydb.Topic.PartitionStats
	(*AlterTopicRequest)(nil),                                     // 44: Ydb.Topic.AlterTopicRequest
	(*AlterTopicResponse)(nil),                                    // 45: Ydb.Topic.AlterTopicResponse
	(*AlterTopicResult)(nil),                                      // 46: Ydb.Topic.AlterTopicResult
	(*DropTopicRequest)(nil),                                      // 47: Ydb.Topic.DropTopicRequest
	(*DropTopicResponse)(nil),                                     // 48: Ydb.Topic.DropTopicResponse
	(*DropTopicResult)(nil),                                       // 49: Ydb.Topic.DropTopicResult
	(*StreamWriteMessage_FromClient)(nil),                         // 50: Ydb.Topic.StreamWriteMessage.FromClient
	(*StreamWriteMessage_FromServer)(nil),                         // 51: Ydb.Topic.StreamWriteMessage.FromServer
	(*StreamWriteMessage_InitRequest)(nil),                        // 52: Ydb.Topic.StreamWriteMessage.InitRequest
	(*StreamWriteMessage_InitResponse)(nil),                       // 53: Ydb.Topic.StreamWriteMessage.InitResponse
	(*StreamWriteMessage_WriteRequest)(nil),                       // 54: Ydb.Topic.StreamWriteMessage.WriteRequest
	(*StreamWriteMessage_WriteResponse)(nil),                      // 55: Ydb.Topic.StreamWriteMessage.WriteResponse
	nil,                                                           // 56: Ydb.Topic.StreamWriteMessage.InitRequest.WriteSessionMetaEntry
	(*StreamWriteMessage_WriteRequest_MessageData)(nil),           // 57: Ydb.Topic.StreamWriteMessage.WriteRequest.MessageData
	(*StreamWriteMessage_WriteResponse_WriteAck)(nil),             // 58: Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck
	(*StreamWriteMessage_WriteResponse_WriteStatistics)(nil),      // 59: Ydb.Topic.StreamWriteMessage.WriteResponse.WriteStatistics
	(*StreamWriteMessage_WriteResponse_WriteAck_Written)(nil),     // 60: Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.Written
	(*StreamWriteMessage_WriteResponse_WriteAck_Skipped)(nil),     // 61: Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.Skipped
	(*StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx)(nil), // 62: Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.WrittenInTx
	(*StreamReadMessage_PartitionSession)(nil),                    // 63: Ydb.Topic.StreamReadMessage.PartitionSession
	(*StreamReadMessage_FromClient)(nil),                          // 64: Ydb.Topic.StreamReadMessage.FromClient
	(*StreamReadMessage_FromServer)(nil),                          // 65: Ydb.Topic.StreamReadMessage.FromServer
	(*StreamReadMessage_InitRequest)(nil),                         // 66: Ydb.Topic.StreamReadMessage.InitRequest
	(*StreamReadMessage_InitResponse)(nil),                        // 67: Ydb.Topic.StreamReadMessage.InitResponse
	(*StreamReadMessage_ReadRequest)(nil),                         // 68: Ydb.Topic.StreamReadMessage.ReadRequest
	(*StreamReadMessage_ReadResponse)(nil),                        // 69: Ydb.Topic.StreamReadMessage.ReadResponse
	(*StreamReadMessage_CommitOffsetRequest)(nil),                 // 70: Ydb.Topic.StreamReadMessage.CommitOffsetRequest
	(*StreamReadMessage_CommitOffsetResponse)(nil),                // 71: Ydb.Topic.StreamReadMessage.CommitOffsetResponse
	(*StreamReadMessage_PartitionSessionStatusRequest)(nil),       // 72: Ydb.Topic.StreamReadMessage.PartitionSessionStatusRequest
	(*StreamReadMessage_PartitionSessionStatusResponse)(nil),      // 73: Ydb.Topic.StreamReadMessage.PartitionSessionStatusResponse
	(*StreamReadMessage_StartPartitionSessionRequest)(nil),        // 74: Ydb.Topic.StreamReadMessage.StartPartitionSessionRequest
	(*StreamReadMessage_StartPartitionSessionResponse)(nil),       // 75: Ydb.Topic.StreamReadMessage.StartPartitionSessionResponse
	(*StreamReadMessage_StopPartitionSessionRequest)(nil),         // 76: Ydb.Topic.StreamReadMessage.StopPartitionSessionRequest
	(*StreamReadMessage_StopPartitionSessionResponse)(nil),        // 77: Ydb.Topic.StreamReadMessage.StopPartitionSessionResponse
	(*StreamReadMessage_UpdatePartitionSession)(nil),              // 78: Ydb.Topic.StreamReadMessage.UpdatePartitionSession
	(*StreamReadMessage_DirectReadAck)(nil),                       // 79: Ydb.Topic.StreamReadMessage.DirectReadAck
	(*StreamReadMessage_EndPartitionSession)(nil),                 // 80: Ydb.Topic.StreamReadMessage.EndPartitionSession
	(*StreamReadMessage_InitRequest_TopicReadSettings)(nil),       // 81: Ydb.Topic.StreamReadMessage.InitRequest.TopicReadSettings
	(*StreamReadMessage_ReadResponse_MessageData)(nil),            // 82: Ydb.Topic.StreamReadMessage.ReadResponse.MessageData
	(*StreamReadMessage_ReadResponse_Batch)(nil),                  // 83: Ydb.Topic.StreamReadMessage.ReadResponse.Batch
	(*StreamReadMessage_ReadResponse_PartitionData)(nil),          // 84: Ydb.Topic.StreamReadMessage.ReadResponse.PartitionData
	nil, // 85: Ydb.Topic.StreamReadMessage.ReadResponse.Batch.WriteSessionMetaEntry
	(*StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset)(nil),     // 86: Ydb.Topic.StreamReadMessage.CommitOffsetRequest.PartitionCommitOffset
	(*StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset)(nil), // 87: Ydb.Topic.StreamReadMessage.CommitOffsetResponse.PartitionCommittedOffset
	(*StreamDirectReadMessage_FromClient)(nil),                              // 88: Ydb.Topic.StreamDirectReadMessage.FromClient
	(*StreamDirectReadMessage_FromServer)(nil),                              // 89: Ydb.Topic.StreamDirectReadMessage.FromServer
	(*StreamDirectReadMessage_InitRequest)(nil),                             // 90: Ydb.Topic.StreamDirectReadMessage.InitRequest
	(*StreamDirectReadMessage_InitResponse)(nil),                            // 91: Ydb.Topic.StreamDirectReadMessage.InitResponse
	(*StreamDirectReadMessage_StartDirectReadPartitionSessionRequest)(nil),  // 92: Ydb.Topic.StreamDirectReadMessage.StartDirectReadPartitionSessionRequest
	(*StreamDirectReadMessage_StartDirectReadPartitionSessionResponse)(nil), // 93: Ydb.Topic.StreamDirectReadMessage.StartDirectReadPartitionSessionResponse
	(*StreamDirectReadMessage_StopDirectReadPartitionSession)(nil),          // 94: Ydb.Topic.StreamDirectReadMessage.StopDirectReadPartitionSession
	(*StreamDirectReadMessage_DirectReadResponse)(nil),                      // 95: Ydb.Topic.StreamDirectReadMessage.DirectReadResponse
	(*StreamDirectReadMessage_InitRequest_TopicReadSettings)(nil),           // 96: Ydb.Topic.StreamDirectReadMessage.InitRequest.TopicReadSettings
	(*UpdateOffsetsInTransactionRequest_TopicOffsets)(nil),                  // 97: Ydb.Topic.UpdateOffsetsInTransactionRequest.TopicOffsets
	(*UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets)(nil), // 98: Ydb.Topic.UpdateOffsetsInTransactionRequest.TopicOffsets.PartitionOffsets
	nil,                            // 99: Ydb.Topic.Consumer.AttributesEntry
	(*Consumer_ConsumerStats)(nil), // 100: Ydb.Topic.Consumer.ConsumerStats
	nil,                            // 101: Ydb.Topic.AlterConsumer.AlterAttributesEntry
	nil,                            // 102: Ydb.Topic.CreateTopicRequest.AttributesEntry
	nil,                            // 103: Ydb.Topic.DescribeTopicResult.AttributesEntry
	(*DescribeTopicResult_PartitionInfo)(nil),             // 104: Ydb.Topic.DescribeTopicResult.PartitionInfo
	(*DescribeTopicResult_TopicStats)(nil),                // 105: Ydb.Topic.DescribeTopicResult.TopicStats
	(*DescribeConsumerResult_PartitionInfo)(nil),          // 106: Ydb.Topic.DescribeConsumerResult.PartitionInfo
	(*DescribeConsumerResult_PartitionConsumerStats)(nil), // 107: Ydb.Topic.DescribeConsumerResult.PartitionConsumerStats
	nil,                                    // 108: Ydb.Topic.AlterTopicRequest.AlterAttributesEntry
	(*Ydb_Operations.OperationParams)(nil), // 109: Ydb.Operations.OperationParams
	(*Ydb_Operations.Operation)(nil),       // 110: Ydb.Operations.Operation
	(*timestamppb.Timestamp)(nil),          // 111: google.protobuf.Timestamp
	(*durationpb.Duration)(nil),            // 112: google.protobuf.Duration
	(*Ydb_Scheme.Entry)(nil),               // 113: Ydb.Scheme.Entry
	(Ydb.StatusIds_StatusCode)(0),          // 114: Ydb.StatusIds.StatusCode
	(*Ydb_Issue.IssueMessage)(nil),         // 115: Ydb.Issue.IssueMessage
}
var file_protos_ydb_topic_proto_depIdxs = []int32{
	109, // 0: Ydb.Topic.UpdateOffsetsInTransactionRequest.operation_params:type_name -> Ydb.Operations.OperationParams
	13,  // 1: Ydb.Topic.UpdateOffsetsInTransactionRequest.tx:type_name -> Ydb.Topic.TransactionIdentity
	97,  // 2: Ydb.Topic.UpdateOffsetsInTransactionRequest.topics:type_name -> Ydb.Topic.UpdateOffsetsInTransactionRequest.TopicOffsets
	110, // 3: Ydb.Topic.UpdateOffsetsInTransactionResponse.operation:type_name -> Ydb.Operations.Operation
	109, // 4: Ydb.Topic.CommitOffsetRequest.operation_params:type_name -> Ydb.Operations.OperationParams
	110, // 5: Ydb.Topic.CommitOffsetResponse.operation:type_name -> Ydb.Operations.Operation
	111, // 6: Ydb.Topic.Consumer.read_from:type_name -> google.protobuf.Timestamp
	4,   // 7: Ydb.Topic.Consumer.supported_codecs:type_name -> Ydb.Topic.SupportedCodecs
	99,  // 8: Ydb.Topic.Consumer.attributes:type_name -> Ydb.Topic.Consumer.AttributesEntry
	100, // 9: Ydb.Topic.Consumer.consumer_stats:type_name -> Ydb.Topic.Consumer.ConsumerStats
	111, // 10: Ydb.Topic.AlterConsumer.set_read_from:type_name -> google.protobuf.Timestamp
	4,   // 11: Ydb.Topic.AlterConsumer.set_supported_codecs:type_name -> Ydb.Topic.SupportedCodecs
	101, // 12: Ydb.Topic.AlterConsumer.alter_attributes:type_name -> Ydb.Topic.AlterConsumer.AlterAttributesEntry
	24,  // 13: Ydb.Topic.PartitioningSettings.auto_partitioning_settings:type_name -> Ydb.Topic.AutoPartitioningSettings
	1,   // 14: Ydb.Topic.AutoPartitioningSettings.strategy:type_name -> Ydb.Topic.AutoPartitioningStrategy
	25,  // 15: Ydb.Topic.AutoPartitioningSettings.partition_write_speed:type_name -> Ydb.Topic.AutoPartitioningWriteSpeedStrategy
	112, // 16: Ydb.Topic.AutoPartitioningWriteSpeedStrategy.stabilization_window:type_name -> google.protobuf.Duration
	27,  // 17: Ydb.Topic.AlterPartitioningSettings.alter_auto_partitioning_settings:type_name -> Ydb.Topic.AlterAutoPartitioningSettings
	1,   // 18: Ydb.Topic.AlterAutoPartitioningSettings.set_strategy:type_name -> Ydb.Topic.AutoPartitioningStrategy
	28,  // 19: Ydb.Topic.AlterAutoPartitioningSettings.set_partition_write_speed:type_name -> Ydb.Topic.AlterAutoPartitioningWriteSpeedStrategy
	112, // 20: Ydb.Topic.AlterAutoPartitioningWriteSpeedStrategy.set_stabilization_window:type_name -> google.protobuf.Duration
	109, // 21: Ydb.Topic.CreateTopicRequest.operation_params:type_name -> Ydb.Operations.OperationParams
	23,  // 22: Ydb.Topic.CreateTopicRequest.partitioning_settings:type_name -> Ydb.Topic.PartitioningSettings
	112, // 23: Ydb.Topic.CreateTopicRequest.retention_period:type_name -> google.protobuf.Duration
	4,   // 24: Ydb.Topic.CreateTopicRequest.supported_codecs:type_name -> Ydb.Topic.SupportedCodecs
	102, // 25: Ydb.Topic.CreateTopicRequest.attributes:type_name -> Ydb.Topic.CreateTopicRequest.AttributesEntry
	21,  // 26: Ydb.Topic.CreateTopicRequest.consumers:type_name -> Ydb.Topic.Consumer
	2,   // 27: Ydb.Topic.CreateTopicRequest.metering_mode:type_name -> Ydb.Topic.MeteringMode
	110, // 28: Ydb.Topic.CreateTopicResponse.operation:type_name -> Ydb.Operations.Operation
	109, // 29: Ydb.Topic.DescribeTopicRequest.operation_params:type_name -> Ydb.Operations.OperationParams
	110, // 30: Ydb.Topic.DescribeTopicResponse.operation:type_name -> Ydb.Operations.Operation
	113, // 31: Ydb.Topic.DescribeTopicResult.self:type_name -> Ydb.Scheme.Entry
	23,  // 32: Ydb.Topic.DescribeTopicResult.partitioning_settings:type_name -> Ydb.Topic.PartitioningSettings
	104, // 33: Ydb.Topic.DescribeTopicResult.partitions:type_name -> Ydb.Topic.DescribeTopicResult.PartitionInfo
	112, // 34: Ydb.Topic.DescribeTopicResult.retention_period:type_name -> google.protobuf.Duration
	4,   // 35: Ydb.Topic.DescribeTopicResult.supported_codecs:type_name -> Ydb.Topic.SupportedCodecs
	103, // 36: Ydb.Topic.DescribeTopicResult.attributes:type_name -> Ydb.Topic.DescribeTopicResult.AttributesEntry
	21,  // 37: Ydb.Topic.DescribeTopicResult.consumers:type_name -> Ydb.Topic.Consumer
	2,   // 38: Ydb.Topic.DescribeTopicResult.metering_mode:type_name -> Ydb.Topic.MeteringMode
	105, // 39: Ydb.Topic.DescribeTopicResult.topic_stats:type_name -> Ydb.Topic.DescribeTopicResult.TopicStats
	109, // 40: Ydb.Topic.DescribePartitionRequest.operation_params:type_name -> Ydb.Operations.OperationParams
	110, // 41: Ydb.Topic.DescribePartitionResponse.operation:type_name -> Ydb.Operations.Operation
	104, // 42: Ydb.Topic.DescribePartitionResult.partition:type_name -> Ydb.Topic.DescribeTopicResult.PartitionInfo
	109, // 43: Ydb.Topic.DescribeConsumerRequest.operation_params:type_name -> Ydb.Operations.OperationParams
	110, // 44: Ydb.Topic.DescribeConsumerResponse.operation:type_name -> Ydb.Operations.Operation
	113, // 45: Ydb.Topic.DescribeConsumerResult.self:type_name -> Ydb.Scheme.Entry
	21,  // 46: Ydb.Topic.DescribeConsumerResult.consumer:type_name -> Ydb.Topic.Consumer
	106, // 47: Ydb.Topic.DescribeConsumerResult.partitions:type_name -> Ydb.Topic.DescribeConsumerResult.PartitionInfo
	5,   // 48: Ydb.Topic.PartitionStats.partition_offsets:type_name -> Ydb.Topic.OffsetsRange
	111, // 49: Ydb.Topic.PartitionStats.last_write_time:type_name -> google.protobuf.Timestamp
	112, // 50: Ydb.Topic.PartitionStats.max_write_time_lag:type_name -> google.protobuf.Duration
	20,  // 51: Ydb.Topic.PartitionStats.bytes_written:type_name -> Ydb.Topic.MultipleWindowsStat
	109, // 52: Ydb.Topic.AlterTopicRequest.operation_params:type_name -> Ydb.Operations.OperationParams
	26,  // 53: Ydb.Topic.AlterTopicRequest.alter_partitioning_settings:type_name -> Ydb.Topic.AlterPartitioningSettings
	112, // 54: Ydb.Topic.AlterTopicRequest.set_retention_period:type_name -> google.protobuf.Duration
	4,   // 55: Ydb.Topic.AlterTopicRequest.set_supported_codecs:type_name -> Ydb.Topic.SupportedCodecs
	108, // 56: Ydb.Topic.AlterTopicRequest.alter_attributes:type_name -> Ydb.Topic.AlterTopicRequest.AlterAttributesEntry
	21,  // 57: Ydb.Topic.AlterTopicRequest.add_consumers:type_name -> Ydb.Topic.Consumer
	22,  // 58: Ydb.Topic.AlterTopicRequest.alter_consumers:type_name -> Ydb.Topic.AlterConsumer
	2,   // 59: Ydb.Topic.AlterTopicRequest.set_metering_mode:type_name -> Ydb.Topic.MeteringMode
	110, // 60: Ydb.Topic.AlterTopicResponse.operation:type_name -> Ydb.Operations.Operation
	109, // 61: Ydb.Topic.DropTopicRequest.operation_params:type_name -> Ydb.Operations.OperationParams
	110, // 62: Ydb.Topic.DropTopicResponse.operation:type_name -> Ydb.Operations.Operation
	52,  // 63: Ydb.Topic.StreamWriteMessage.FromClient.init_request:type_name -> Ydb.Topic.StreamWriteMessage.InitRequest
	54,  // 64: Ydb.Topic.StreamWriteMessage.FromClient.write_request:type_name -> Ydb.Topic.StreamWriteMessage.WriteRequest
	6,   // 65: Ydb.Topic.StreamWriteMessage.FromClient.update_token_request:type_name -> Ydb.Topic.UpdateTokenRequest
	114, // 66: Ydb.Topic.StreamWriteMessage.FromServer.status:type_name -> Ydb.StatusIds.StatusCode
	115, // 67: Ydb.Topic.StreamWriteMessage.FromServer.issues:type_name -> Ydb.Issue.IssueMessage
	53,  // 68: Ydb.Topic.StreamWriteMessage.FromServer.init_response:type_name -> Ydb.Topic.StreamWriteMessage.InitResponse
	55,  // 69: Ydb.Topic.StreamWriteMessage.FromServer.write_response:type_name -> Ydb.Topic.StreamWriteMessage.WriteResponse
	7,   // 70: Ydb.Topic.StreamWriteMessage.FromServer.update_token_response:type_name -> Ydb.Topic.UpdateTokenResponse
	56,  // 71: Ydb.Topic.StreamWriteMessage.InitRequest.write_session_meta:type_name -> Ydb.Topic.StreamWriteMessage.InitRequest.WriteSessionMetaEntry
	8,   // 72: Ydb.Topic.StreamWriteMessage.InitRequest.partition_with_generation:type_name -> Ydb.Topic.PartitionWithGeneration
	4,   // 73: Ydb.Topic.StreamWriteMessage.InitResponse.supported_codecs:type_name -> Ydb.Topic.SupportedCodecs
	57,  // 74: Ydb.Topic.StreamWriteMessage.WriteRequest.messages:type_name -> Ydb.Topic.StreamWriteMessage.WriteRequest.MessageData
	13,  // 75: Ydb.Topic.StreamWriteMessage.WriteRequest.tx:type_name -> Ydb.Topic.TransactionIdentity
	58,  // 76: Ydb.Topic.StreamWriteMessage.WriteResponse.acks:type_name -> Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck
	59,  // 77: Ydb.Topic.StreamWriteMessage.WriteResponse.write_statistics:type_name -> Ydb.Topic.StreamWriteMessage.WriteResponse.WriteStatistics
	111, // 78: Ydb.Topic.StreamWriteMessage.WriteRequest.MessageData.created_at:type_name -> google.protobuf.Timestamp
	8,   // 79: Ydb.Topic.StreamWriteMessage.WriteRequest.MessageData.partition_with_generation:type_name -> Ydb.Topic.PartitionWithGeneration
	9,   // 80: Ydb.Topic.StreamWriteMessage.WriteRequest.MessageData.metadata_items:type_name -> Ydb.Topic.MetadataItem
	60,  // 81: Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.written:type_name -> Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.Written
	61,  // 82: Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.skipped:type_name -> Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.Skipped
	62,  // 83: Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.written_in_tx:type_name -> Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.WrittenInTx
	112, // 84: Ydb.Topic.StreamWriteMessage.WriteResponse.WriteStatistics.persisting_time:type_name -> google.protobuf.Duration
	112, // 85: Ydb.Topic.StreamWriteMessage.WriteResponse.WriteStatistics.min_queue_wait_time:type_name -> google.protobuf.Duration
	112, // 86: Ydb.Topic.StreamWriteMessage.WriteResponse.WriteStatistics.max_queue_wait_time:type_name -> google.protobuf.Duration
	112, // 87: Ydb.Topic.StreamWriteMessage.WriteResponse.WriteStatistics.partition_quota_wait_time:type_name -> google.protobuf.Duration
	112, // 88: Ydb.Topic.StreamWriteMessage.WriteResponse.WriteStatistics.topic_quota_wait_time:type_name -> google.protobuf.Duration
	3,   // 89: Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.Skipped.reason:type_name -> Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.Skipped.Reason
	66,  // 90: Ydb.Topic.StreamReadMessage.FromClient.init_request:type_name -> Ydb.Topic.StreamReadMessage.InitRequest
	68,  // 91: Ydb.Topic.StreamReadMessage.FromClient.read_request:type_name -> Ydb.Topic.StreamReadMessage.ReadRequest
	70,  // 92: Ydb.Topic.StreamReadMessage.FromClient.commit_offset_request:type_name -> Ydb.Topic.StreamReadMessage.CommitOffsetRequest
	72,  // 93: Ydb.Topic.StreamReadMessage.FromClient.partition_session_status_request:type_name -> Ydb.Topic.StreamReadMessage.PartitionSessionStatusRequest
	6,   // 94: Ydb.Topic.StreamReadMessage.FromClient.update_token_request:type_name -> Ydb.Topic.UpdateTokenRequest
	79,  // 95: Ydb.Topic.StreamReadMessage.FromClient.direct_read_ack:type_name -> Ydb.Topic.StreamReadMessage.DirectReadAck
	75,  // 96: Ydb.Topic.StreamReadMessage.FromClient.start_partition_session_response:type_name -> Ydb.Topic.StreamReadMessage.StartPartitionSessionResponse
	77,  // 97: Ydb.Topic.StreamReadMessage.FromClient.stop_partition_session_response:type_name -> Ydb.Topic.StreamReadMessage.StopPartitionSessionResponse
	114, // 98: Ydb.Topic.StreamReadMessage.FromServer.status:type_name -> Ydb.StatusIds.StatusCode
	115, // 99: Ydb.Topic.StreamReadMessage.FromServer.issues:type_name -> Ydb.Issue.IssueMessage
	67,  // 100: Ydb.Topic.StreamReadMessage.FromServer.init_response:type_name -> Ydb.Topic.StreamReadMessage.InitResponse
	69,  // 101: Ydb.Topic.StreamReadMessage.FromServer.read_response:type_name -> Ydb.Topic.StreamReadMessage.ReadResponse
	71,  // 102: Ydb.Topic.StreamReadMessage.FromServer.commit_offset_response:type_name -> Ydb.Topic.StreamReadMessage.CommitOffsetResponse
	73,  // 103: Ydb.Topic.StreamReadMessage.FromServer.partition_session_status_response:type_name -> Ydb.Topic.StreamReadMessage.PartitionSessionStatusResponse
	7,   // 104: Ydb.Topic.StreamReadMessage.FromServer.update_token_response:type_name -> Ydb.Topic.UpdateTokenResponse
	74,  // 105: Ydb.Topic.StreamReadMessage.FromServer.start_partition_session_request:type_name -> Ydb.Topic.StreamReadMessage.StartPartitionSessionRequest
	76,  // 106: Ydb.Topic.StreamReadMessage.FromServer.stop_partition_session_request:type_name -> Ydb.Topic.StreamReadMessage.StopPartitionSessionRequest
	78,  // 107: Ydb.Topic.StreamReadMessage.FromServer.update_partition_session:type_name -> Ydb.Topic.StreamReadMessage.UpdatePartitionSession
	80,  // 108: Ydb.Topic.StreamReadMessage.FromServer.end_partition_session:type_name -> Ydb.Topic.StreamReadMessage.EndPartitionSession
	81,  // 109: Ydb.Topic.StreamReadMessage.InitRequest.topics_read_settings:type_name -> Ydb.Topic.StreamReadMessage.InitRequest.TopicReadSettings
	84,  // 110: Ydb.Topic.StreamReadMessage.ReadResponse.partition_data:type_name -> Ydb.Topic.StreamReadMessage.ReadResponse.PartitionData
	86,  // 111: Ydb.Topic.StreamReadMessage.CommitOffsetRequest.commit_offsets:type_name -> Ydb.Topic.StreamReadMessage.CommitOffsetRequest.PartitionCommitOffset
	87,  // 112: Ydb.Topic.StreamReadMessage.CommitOffsetResponse.partitions_committed_offsets:type_name -> Ydb.Topic.StreamReadMessage.CommitOffsetResponse.PartitionCommittedOffset
	5,   // 113: Ydb.Topic.StreamReadMessage.PartitionSessionStatusResponse.partition_offsets:type_name -> Ydb.Topic.OffsetsRange
	111, // 114: Ydb.Topic.StreamReadMessage.PartitionSessionStatusResponse.write_time_high_watermark:type_name -> google.protobuf.Timestamp
	63,  // 115: Ydb.Topic.StreamReadMessage.StartPartitionSessionRequest.partition_session:type_name -> Ydb.Topic.StreamReadMessage.PartitionSession
	5,   // 116: Ydb.Topic.StreamReadMessage.StartPartitionSessionRequest.partition_offsets:type_name -> Ydb.Topic.OffsetsRange
	32,  // 117: Ydb.Topic.StreamReadMessage.StartPartitionSessionRequest.partition_location:type_name -> Ydb.Topic.PartitionLocation
	32,  // 118: Ydb.Topic.StreamReadMessage.UpdatePartitionSession.partition_location:type_name -> Ydb.Topic.PartitionLocation
	112, // 119: Ydb.Topic.StreamReadMessage.InitRequest.TopicReadSettings.max_lag:type_name -> google.protobuf.Duration
	111, // 120: Ydb.Topic.StreamReadMessage.InitRequest.TopicReadSettings.read_from:type_name -> google.protobuf.Timestamp
	111, // 121: Ydb.Topic.StreamReadMessage.ReadResponse.MessageData.created_at:type_name -> google.protobuf.Timestamp
	9,   // 122: Ydb.Topic.StreamReadMessage.ReadResponse.MessageData.metadata_items:type_name -> Ydb.Topic.MetadataItem
	82,  // 123: Ydb.Topic.StreamReadMessage.ReadResponse.Batch.message_data:type_name -> Ydb.Topic.StreamReadMessage.ReadResponse.MessageData
	85,  // 124: Ydb.Topic.StreamReadMessage.ReadResponse.Batch.write_session_meta:type_name -> Ydb.Topic.StreamReadMessage.ReadResponse.Batch.WriteSessionMetaEntry
	111, // 125: Ydb.Topic.StreamReadMessage.ReadResponse.Batch.written_at:type_name -> google.protobuf.Timestamp
	83,  // 126: Ydb.Topic.StreamReadMessage.ReadResponse.PartitionData.batches:type_name -> Ydb.Topic.StreamReadMessage.ReadResponse.Batch
	5,   // 127: Ydb.Topic.StreamReadMessage.CommitOffsetRequest.PartitionCommitOffset.offsets:type_name -> Ydb.Topic.OffsetsRange
	90,  // 128: Ydb.Topic.StreamDirectReadMessage.FromClient.init_request:type_name -> Ydb.Topic.StreamDirectReadMessage.InitRequest
	92,  // 129: Ydb.Topic.StreamDirectReadMessage.FromClient.start_direct_read_partition_session_request:type_name -> Ydb.Topic.StreamDirectReadMessage.StartDirectReadPartitionSessionRequest
	6,   // 130: Ydb.Topic.StreamDirectReadMessage.FromClient.update_token_request:type_name -> Ydb.Topic.UpdateTokenRequest
	114, // 131: Ydb.Topic.StreamDirectReadMessage.FromServer.status:type_name -> Ydb.StatusIds.StatusCode
	115, // 132: Ydb.Topic.StreamDirectReadMessage.FromServer.issues:type_name -> Ydb.Issue.IssueMessage
	91,  // 133: Ydb.Topic.StreamDirectReadMessage.FromServer.init_response:type_name -> Ydb.Topic.StreamDirectReadMessage.InitResponse
	93,  // 134: Ydb.Topic.StreamDirectReadMessage.FromServer.start_direct_read_partition_session_response:type_name -> Ydb.Topic.StreamDirectReadMessage.StartDirectReadPartitionSessionResponse
	94,  // 135: Ydb.Topic.StreamDirectReadMessage.FromServer.stop_direct_read_partition_session:type_name -> Ydb.Topic.StreamDirectReadMessage.StopDirectReadPartitionSession
	95,  // 136: Ydb.Topic.StreamDirectReadMessage.FromServer.direct_read_response:type_name -> Ydb.Topic.StreamDirectReadMessage.DirectReadResponse
	7,   // 137: Ydb.Topic.StreamDirectReadMessage.FromServer.update_token_response:type_name -> Ydb.Topic.UpdateTokenResponse
	96,  // 138: Ydb.Topic.StreamDirectReadMessage.InitRequest.topics_read_settings:type_name -> Ydb.Topic.StreamDirectReadMessage.InitRequest.TopicReadSettings
	114, // 139: Ydb.Topic.StreamDirectReadMessage.StopDirectReadPartitionSession.status:type_name -> Ydb.StatusIds.StatusCode
	115, // 140: Ydb.Topic.StreamDirectReadMessage.StopDirectReadPartitionSession.issues:type_name -> Ydb.Issue.IssueMessage
	84,  // 141: Ydb.Topic.StreamDirectReadMessage.DirectReadResponse.partition_data:type_name -> Ydb.Topic.StreamReadMessage.ReadResponse.PartitionData
	98,  // 142: Ydb.Topic.UpdateOffsetsInTransactionRequest.TopicOffsets.partitions:type_name -> Ydb.Topic.UpdateOffsetsInTransactionRequest.TopicOffsets.PartitionOffsets
	5,   // 143: Ydb.Topic.UpdateOffsetsInTransactionRequest.TopicOffsets.PartitionOffsets.partition_offsets:type_name -> Ydb.Topic.OffsetsRange
	111, // 144: Ydb.Topic.Consumer.ConsumerStats.min_partitions_last_read_time:type_name -> google.protobuf.Timestamp
	112, // 145: Ydb.Topic.Consumer.ConsumerStats.max_read_time_lag:type_name -> google.protobuf.Duration
	112, // 146: Ydb.Topic.Consumer.ConsumerStats.max_write_time_lag:type_name -> google.protobuf.Duration
	20,  // 147: Ydb.Topic.Consumer.ConsumerStats.bytes_read:type_name -> Ydb.Topic.MultipleWindowsStat
	43,  // 148: Ydb.Topic.DescribeTopicResult.PartitionInfo.partition_stats:type_name -> Ydb.Topic.PartitionStats
	32,  // 149: Ydb.Topic.DescribeTopicResult.PartitionInfo.partition_location:type_name -> Ydb.Topic.PartitionLocation
	35,  // 150: Ydb.Topic.DescribeTopicResult.PartitionInfo.key_range:type_name -> Ydb.Topic.PartitionKeyRange
	111, // 151: Ydb.Topic.DescribeTopicResult.TopicStats.min_last_write_time:type_name -> google.protobuf.Timestamp
	112, // 152: Ydb.Topic.DescribeTopicResult.TopicStats.max_write_time_lag:type_name -> google.protobuf.Duration
	20,  // 153: Ydb.Topic.DescribeTopicResult.TopicStats.bytes_written:type_name -> Ydb.Topic.MultipleWindowsStat
	43,  // 154: Ydb.Topic.DescribeConsumerResult.PartitionInfo.partition_stats:type_name -> Ydb.Topic.PartitionStats
	107, // 155: Ydb.Topic.DescribeConsumerResult.PartitionInfo.partition_consumer_stats:type_name -> Ydb.Topic.DescribeConsumerResult.PartitionConsumerStats
	32,  // 156: Ydb.Topic.DescribeConsumerResult.PartitionInfo.partition_location:type_name -> Ydb.Topic.PartitionLocation
	111, // 157: Ydb.Topic.DescribeConsumerResult.PartitionConsumerStats.partition_read_session_create_time:type_name -> google.protobuf.Timestamp
	111, // 158: Ydb.Topic.DescribeConsumerResult.PartitionConsumerStats.last_read_time:type_name -> google.protobuf.Timestamp
	112, // 159: Ydb.Topic.DescribeConsumerResult.PartitionConsumerStats.max_read_time_lag:type_name -> google.protobuf.Duration
	112, // 160: Ydb.Topic.DescribeConsumerResult.PartitionConsumerStats.max_write_time_lag:type_name -> google.protobuf.Duration
	20,  // 161: Ydb.Topic.DescribeConsumerResult.PartitionConsumerStats.bytes_read:type_name -> Ydb.Topic.MultipleWindowsStat
	162, // [162:162] is the sub-list for method output_type
	162, // [162:162] is the sub-list for method input_type
	162, // [162:162] is the sub-list for extension type_name
	162, // [162:162] is the sub-list for extension extendee
	0,   // [0:162] is the sub-list for field type_name
}

func init() { file_protos_ydb_topic_proto_init() }
func file_protos_ydb_topic_proto_init() {
	if File_protos_ydb_topic_proto != nil {
		return
	}
	file_protos_ydb_topic_proto_msgTypes[46].OneofWrappers = []any{
		(*StreamWriteMessage_FromClient_InitRequest)(nil),
		(*StreamWriteMessage_FromClient_WriteRequest)(nil),
		(*StreamWriteMessage_FromClient_UpdateTokenRequest)(nil),
	}
	file_protos_ydb_topic_proto_msgTypes[47].OneofWrappers = []any{
		(*StreamWriteMessage_FromServer_InitResponse)(nil),
		(*StreamWriteMessage_FromServer_WriteResponse)(nil),
		(*StreamWriteMessage_FromServer_UpdateTokenResponse)(nil),
	}
	file_protos_ydb_topic_proto_msgTypes[48].OneofWrappers = []any{
		(*StreamWriteMessage_InitRequest_MessageGroupId)(nil),
		(*StreamWriteMessage_InitRequest_PartitionId)(nil),
		(*StreamWriteMessage_InitRequest_PartitionWithGeneration)(nil),
	}
	file_protos_ydb_topic_proto_msgTypes[53].OneofWrappers = []any{
		(*StreamWriteMessage_WriteRequest_MessageData_MessageGroupId)(nil),
		(*StreamWriteMessage_WriteRequest_MessageData_PartitionId)(nil),
		(*StreamWriteMessage_WriteRequest_MessageData_PartitionWithGeneration)(nil),
	}
	file_protos_ydb_topic_proto_msgTypes[54].OneofWrappers = []any{
		(*StreamWriteMessage_WriteResponse_WriteAck_Written_)(nil),
		(*StreamWriteMessage_WriteResponse_WriteAck_Skipped_)(nil),
		(*StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx_)(nil),
	}
	file_protos_ydb_topic_proto_msgTypes[60].OneofWrappers = []any{
		(*StreamReadMessage_FromClient_InitRequest)(nil),
		(*StreamReadMessage_FromClient_ReadRequest)(nil),
		(*StreamReadMessage_FromClient_CommitOffsetRequest)(nil),
		(*StreamReadMessage_FromClient_PartitionSessionStatusRequest)(nil),
		(*StreamReadMessage_FromClient_UpdateTokenRequest)(nil),
		(*StreamReadMessage_FromClient_DirectReadAck)(nil),
		(*StreamReadMessage_FromClient_StartPartitionSessionResponse)(nil),
		(*StreamReadMessage_FromClient_StopPartitionSessionResponse)(nil),
	}
	file_protos_ydb_topic_proto_msgTypes[61].OneofWrappers = []any{
		(*StreamReadMessage_FromServer_InitResponse)(nil),
		(*StreamReadMessage_FromServer_ReadResponse)(nil),
		(*StreamReadMessage_FromServer_CommitOffsetResponse)(nil),
		(*StreamReadMessage_FromServer_PartitionSessionStatusResponse)(nil),
		(*StreamReadMessage_FromServer_UpdateTokenResponse)(nil),
		(*StreamReadMessage_FromServer_StartPartitionSessionRequest)(nil),
		(*StreamReadMessage_FromServer_StopPartitionSessionRequest)(nil),
		(*StreamReadMessage_FromServer_UpdatePartitionSession)(nil),
		(*StreamReadMessage_FromServer_EndPartitionSession)(nil),
	}
	file_protos_ydb_topic_proto_msgTypes[84].OneofWrappers = []any{
		(*StreamDirectReadMessage_FromClient_InitRequest)(nil),
		(*StreamDirectReadMessage_FromClient_StartDirectReadPartitionSessionRequest)(nil),
		(*StreamDirectReadMessage_FromClient_UpdateTokenRequest)(nil),
	}
	file_protos_ydb_topic_proto_msgTypes[85].OneofWrappers = []any{
		(*StreamDirectReadMessage_FromServer_InitResponse)(nil),
		(*StreamDirectReadMessage_FromServer_StartDirectReadPartitionSessionResponse)(nil),
		(*StreamDirectReadMessage_FromServer_StopDirectReadPartitionSession)(nil),
		(*StreamDirectReadMessage_FromServer_DirectReadResponse)(nil),
		(*StreamDirectReadMessage_FromServer_UpdateTokenResponse)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_protos_ydb_topic_proto_rawDesc), len(file_protos_ydb_topic_proto_rawDesc)),
			NumEnums:      4,
			NumMessages:   105,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_protos_ydb_topic_proto_goTypes,
		DependencyIndexes: file_protos_ydb_topic_proto_depIdxs,
		EnumInfos:         file_protos_ydb_topic_proto_enumTypes,
		MessageInfos:      file_protos_ydb_topic_proto_msgTypes,
	}.Build()
	File_protos_ydb_topic_proto = out.File
	file_protos_ydb_topic_proto_goTypes = nil
	file_protos_ydb_topic_proto_depIdxs = nil
}
