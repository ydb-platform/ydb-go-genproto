// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v4.25.1
// source: protos/ydb_topic.proto

package Ydb_Topic

import (
	Ydb "github.com/ydb-platform/ydb-go-genproto/protos/Ydb"
	Ydb_Issue "github.com/ydb-platform/ydb-go-genproto/protos/Ydb_Issue"
	Ydb_Operations "github.com/ydb-platform/ydb-go-genproto/protos/Ydb_Operations"
	Ydb_Scheme "github.com/ydb-platform/ydb-go-genproto/protos/Ydb_Scheme"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Codec int32

const (
	Codec_CODEC_UNSPECIFIED Codec = 0
	Codec_CODEC_RAW         Codec = 1
	Codec_CODEC_GZIP        Codec = 2
	Codec_CODEC_LZOP        Codec = 3
	Codec_CODEC_ZSTD        Codec = 4
	// User-defined codecs from 10000 to 19999
	Codec_CODEC_CUSTOM Codec = 10000
)

// Enum value maps for Codec.
var (
	Codec_name = map[int32]string{
		0:     "CODEC_UNSPECIFIED",
		1:     "CODEC_RAW",
		2:     "CODEC_GZIP",
		3:     "CODEC_LZOP",
		4:     "CODEC_ZSTD",
		10000: "CODEC_CUSTOM",
	}
	Codec_value = map[string]int32{
		"CODEC_UNSPECIFIED": 0,
		"CODEC_RAW":         1,
		"CODEC_GZIP":        2,
		"CODEC_LZOP":        3,
		"CODEC_ZSTD":        4,
		"CODEC_CUSTOM":      10000,
	}
)

func (x Codec) Enum() *Codec {
	p := new(Codec)
	*p = x
	return p
}

func (x Codec) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Codec) Descriptor() protoreflect.EnumDescriptor {
	return file_protos_ydb_topic_proto_enumTypes[0].Descriptor()
}

func (Codec) Type() protoreflect.EnumType {
	return &file_protos_ydb_topic_proto_enumTypes[0]
}

func (x Codec) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Codec.Descriptor instead.
func (Codec) EnumDescriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{0}
}

type AutoPartitioningStrategy int32

const (
	// The auto partitioning algorithm is not specified. The default value will be used.
	AutoPartitioningStrategy_AUTO_PARTITIONING_STRATEGY_UNSPECIFIED AutoPartitioningStrategy = 0
	// The auto partitioning is disabled.
	AutoPartitioningStrategy_AUTO_PARTITIONING_STRATEGY_DISABLED AutoPartitioningStrategy = 1
	// The auto partitioning algorithm will increase partitions count depending on the load characteristics.
	// The auto partitioning algorithm will never decrease the number of partitions.
	AutoPartitioningStrategy_AUTO_PARTITIONING_STRATEGY_SCALE_UP AutoPartitioningStrategy = 2
	// The auto partitioning algorithm will both increase and decrease partitions count depending on the load characteristics.
	AutoPartitioningStrategy_AUTO_PARTITIONING_STRATEGY_SCALE_UP_AND_DOWN AutoPartitioningStrategy = 3
	// The auto partitioning is paused.
	AutoPartitioningStrategy_AUTO_PARTITIONING_STRATEGY_PAUSED AutoPartitioningStrategy = 4
)

// Enum value maps for AutoPartitioningStrategy.
var (
	AutoPartitioningStrategy_name = map[int32]string{
		0: "AUTO_PARTITIONING_STRATEGY_UNSPECIFIED",
		1: "AUTO_PARTITIONING_STRATEGY_DISABLED",
		2: "AUTO_PARTITIONING_STRATEGY_SCALE_UP",
		3: "AUTO_PARTITIONING_STRATEGY_SCALE_UP_AND_DOWN",
		4: "AUTO_PARTITIONING_STRATEGY_PAUSED",
	}
	AutoPartitioningStrategy_value = map[string]int32{
		"AUTO_PARTITIONING_STRATEGY_UNSPECIFIED":       0,
		"AUTO_PARTITIONING_STRATEGY_DISABLED":          1,
		"AUTO_PARTITIONING_STRATEGY_SCALE_UP":          2,
		"AUTO_PARTITIONING_STRATEGY_SCALE_UP_AND_DOWN": 3,
		"AUTO_PARTITIONING_STRATEGY_PAUSED":            4,
	}
)

func (x AutoPartitioningStrategy) Enum() *AutoPartitioningStrategy {
	p := new(AutoPartitioningStrategy)
	*p = x
	return p
}

func (x AutoPartitioningStrategy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AutoPartitioningStrategy) Descriptor() protoreflect.EnumDescriptor {
	return file_protos_ydb_topic_proto_enumTypes[1].Descriptor()
}

func (AutoPartitioningStrategy) Type() protoreflect.EnumType {
	return &file_protos_ydb_topic_proto_enumTypes[1]
}

func (x AutoPartitioningStrategy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AutoPartitioningStrategy.Descriptor instead.
func (AutoPartitioningStrategy) EnumDescriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{1}
}

// Metering mode specifies the method used to determine consumption of resources by the topic.
// This settings will have an effect only in a serverless database.
type MeteringMode int32

const (
	// Use default
	MeteringMode_METERING_MODE_UNSPECIFIED MeteringMode = 0
	// Metering based on resource reservation
	MeteringMode_METERING_MODE_RESERVED_CAPACITY MeteringMode = 1
	// Metering based on actual consumption. Default.
	MeteringMode_METERING_MODE_REQUEST_UNITS MeteringMode = 2
)

// Enum value maps for MeteringMode.
var (
	MeteringMode_name = map[int32]string{
		0: "METERING_MODE_UNSPECIFIED",
		1: "METERING_MODE_RESERVED_CAPACITY",
		2: "METERING_MODE_REQUEST_UNITS",
	}
	MeteringMode_value = map[string]int32{
		"METERING_MODE_UNSPECIFIED":       0,
		"METERING_MODE_RESERVED_CAPACITY": 1,
		"METERING_MODE_REQUEST_UNITS":     2,
	}
)

func (x MeteringMode) Enum() *MeteringMode {
	p := new(MeteringMode)
	*p = x
	return p
}

func (x MeteringMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MeteringMode) Descriptor() protoreflect.EnumDescriptor {
	return file_protos_ydb_topic_proto_enumTypes[2].Descriptor()
}

func (MeteringMode) Type() protoreflect.EnumType {
	return &file_protos_ydb_topic_proto_enumTypes[2]
}

func (x MeteringMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MeteringMode.Descriptor instead.
func (MeteringMode) EnumDescriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{2}
}

type StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason int32

const (
	StreamWriteMessage_WriteResponse_WriteAck_Skipped_REASON_UNSPECIFIED     StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason = 0
	StreamWriteMessage_WriteResponse_WriteAck_Skipped_REASON_ALREADY_WRITTEN StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason = 1
)

// Enum value maps for StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason.
var (
	StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason_name = map[int32]string{
		0: "REASON_UNSPECIFIED",
		1: "REASON_ALREADY_WRITTEN",
	}
	StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason_value = map[string]int32{
		"REASON_UNSPECIFIED":     0,
		"REASON_ALREADY_WRITTEN": 1,
	}
)

func (x StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason) Enum() *StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason {
	p := new(StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason)
	*p = x
	return p
}

func (x StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason) Descriptor() protoreflect.EnumDescriptor {
	return file_protos_ydb_topic_proto_enumTypes[3].Descriptor()
}

func (StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason) Type() protoreflect.EnumType {
	return &file_protos_ydb_topic_proto_enumTypes[3]
}

func (x StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason.Descriptor instead.
func (StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason) EnumDescriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{6, 5, 0, 1, 0}
}

// Description of supported codecs.
type SupportedCodecs struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of supported codecs.
	// See enum Codec above for values.
	Codecs        []int32 `protobuf:"varint,1,rep,packed,name=codecs,proto3" json:"codecs,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SupportedCodecs) Reset() {
	*x = SupportedCodecs{}
	mi := &file_protos_ydb_topic_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SupportedCodecs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SupportedCodecs) ProtoMessage() {}

func (x *SupportedCodecs) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SupportedCodecs.ProtoReflect.Descriptor instead.
func (*SupportedCodecs) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{0}
}

func (x *SupportedCodecs) GetCodecs() []int32 {
	if x != nil {
		return x.Codecs
	}
	return nil
}

// Represents range [start, end).
// I.e. (end - 1) is the greatest of offsets, included in non-empty range.
type OffsetsRange struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Start         int64                  `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	End           int64                  `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OffsetsRange) Reset() {
	*x = OffsetsRange{}
	mi := &file_protos_ydb_topic_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OffsetsRange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OffsetsRange) ProtoMessage() {}

func (x *OffsetsRange) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OffsetsRange.ProtoReflect.Descriptor instead.
func (*OffsetsRange) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{1}
}

func (x *OffsetsRange) GetStart() int64 {
	if x != nil {
		return x.Start
	}
	return 0
}

func (x *OffsetsRange) GetEnd() int64 {
	if x != nil {
		return x.End
	}
	return 0
}

// In-session reauthentication and reauthorization, lets user increase session lifetime.
// Client should wait for UpdateTokenResponse before sending next UpdateTokenRequest.
type UpdateTokenRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Token         string                 `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateTokenRequest) Reset() {
	*x = UpdateTokenRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateTokenRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateTokenRequest) ProtoMessage() {}

func (x *UpdateTokenRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateTokenRequest.ProtoReflect.Descriptor instead.
func (*UpdateTokenRequest) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{2}
}

func (x *UpdateTokenRequest) GetToken() string {
	if x != nil {
		return x.Token
	}
	return ""
}

type UpdateTokenResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateTokenResponse) Reset() {
	*x = UpdateTokenResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateTokenResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateTokenResponse) ProtoMessage() {}

func (x *UpdateTokenResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateTokenResponse.ProtoReflect.Descriptor instead.
func (*UpdateTokenResponse) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{3}
}

type PartitionWithGeneration struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Partition identifier.
	PartitionId int64 `protobuf:"varint,1,opt,name=partition_id,json=partitionId,proto3" json:"partition_id,omitempty"`
	// Partition generation.
	Generation    int64 `protobuf:"varint,2,opt,name=generation,proto3" json:"generation,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PartitionWithGeneration) Reset() {
	*x = PartitionWithGeneration{}
	mi := &file_protos_ydb_topic_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PartitionWithGeneration) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PartitionWithGeneration) ProtoMessage() {}

func (x *PartitionWithGeneration) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PartitionWithGeneration.ProtoReflect.Descriptor instead.
func (*PartitionWithGeneration) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{4}
}

func (x *PartitionWithGeneration) GetPartitionId() int64 {
	if x != nil {
		return x.PartitionId
	}
	return 0
}

func (x *PartitionWithGeneration) GetGeneration() int64 {
	if x != nil {
		return x.Generation
	}
	return 0
}

type MetadataItem struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Key           string                 `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value         []byte                 `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MetadataItem) Reset() {
	*x = MetadataItem{}
	mi := &file_protos_ydb_topic_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MetadataItem) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MetadataItem) ProtoMessage() {}

func (x *MetadataItem) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MetadataItem.ProtoReflect.Descriptor instead.
func (*MetadataItem) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{5}
}

func (x *MetadataItem) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *MetadataItem) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

// Messages for bidirectional streaming rpc StreamWrite
type StreamWriteMessage struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamWriteMessage) Reset() {
	*x = StreamWriteMessage{}
	mi := &file_protos_ydb_topic_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamWriteMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamWriteMessage) ProtoMessage() {}

func (x *StreamWriteMessage) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamWriteMessage.ProtoReflect.Descriptor instead.
func (*StreamWriteMessage) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{6}
}

// Messages for bidirectional streaming rpc StreamRead
type StreamReadMessage struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamReadMessage) Reset() {
	*x = StreamReadMessage{}
	mi := &file_protos_ydb_topic_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage) ProtoMessage() {}

func (x *StreamReadMessage) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamReadMessage.ProtoReflect.Descriptor instead.
func (*StreamReadMessage) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{7}
}

// Messages for bidirectional streaming rpc StreamDirectRead
type StreamDirectReadMessage struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamDirectReadMessage) Reset() {
	*x = StreamDirectReadMessage{}
	mi := &file_protos_ydb_topic_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamDirectReadMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamDirectReadMessage) ProtoMessage() {}

func (x *StreamDirectReadMessage) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamDirectReadMessage.ProtoReflect.Descriptor instead.
func (*StreamDirectReadMessage) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{8}
}

type TransactionIdentity struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Transaction identifier from TableService.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Session identifier from TableService.
	Session       string `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TransactionIdentity) Reset() {
	*x = TransactionIdentity{}
	mi := &file_protos_ydb_topic_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TransactionIdentity) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TransactionIdentity) ProtoMessage() {}

func (x *TransactionIdentity) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TransactionIdentity.ProtoReflect.Descriptor instead.
func (*TransactionIdentity) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{9}
}

func (x *TransactionIdentity) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *TransactionIdentity) GetSession() string {
	if x != nil {
		return x.Session
	}
	return ""
}

// Add offsets to transaction request sent from client to server.
type UpdateOffsetsInTransactionRequest struct {
	state           protoimpl.MessageState          `protogen:"open.v1"`
	OperationParams *Ydb_Operations.OperationParams `protobuf:"bytes,1,opt,name=operation_params,json=operationParams,proto3" json:"operation_params,omitempty"`
	Tx              *TransactionIdentity            `protobuf:"bytes,2,opt,name=tx,proto3" json:"tx,omitempty"`
	// Ranges of offsets by topics.
	Topics        []*UpdateOffsetsInTransactionRequest_TopicOffsets `protobuf:"bytes,3,rep,name=topics,proto3" json:"topics,omitempty"`
	Consumer      string                                            `protobuf:"bytes,4,opt,name=consumer,proto3" json:"consumer,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateOffsetsInTransactionRequest) Reset() {
	*x = UpdateOffsetsInTransactionRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateOffsetsInTransactionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateOffsetsInTransactionRequest) ProtoMessage() {}

func (x *UpdateOffsetsInTransactionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateOffsetsInTransactionRequest.ProtoReflect.Descriptor instead.
func (*UpdateOffsetsInTransactionRequest) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{10}
}

func (x *UpdateOffsetsInTransactionRequest) GetOperationParams() *Ydb_Operations.OperationParams {
	if x != nil {
		return x.OperationParams
	}
	return nil
}

func (x *UpdateOffsetsInTransactionRequest) GetTx() *TransactionIdentity {
	if x != nil {
		return x.Tx
	}
	return nil
}

func (x *UpdateOffsetsInTransactionRequest) GetTopics() []*UpdateOffsetsInTransactionRequest_TopicOffsets {
	if x != nil {
		return x.Topics
	}
	return nil
}

func (x *UpdateOffsetsInTransactionRequest) GetConsumer() string {
	if x != nil {
		return x.Consumer
	}
	return ""
}

// Add offsets to transaction response sent from server to client.
type UpdateOffsetsInTransactionResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Result of request will be inside operation.
	Operation     *Ydb_Operations.Operation `protobuf:"bytes,1,opt,name=operation,proto3" json:"operation,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateOffsetsInTransactionResponse) Reset() {
	*x = UpdateOffsetsInTransactionResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateOffsetsInTransactionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateOffsetsInTransactionResponse) ProtoMessage() {}

func (x *UpdateOffsetsInTransactionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateOffsetsInTransactionResponse.ProtoReflect.Descriptor instead.
func (*UpdateOffsetsInTransactionResponse) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{11}
}

func (x *UpdateOffsetsInTransactionResponse) GetOperation() *Ydb_Operations.Operation {
	if x != nil {
		return x.Operation
	}
	return nil
}

// Add offsets to transaction result message that will be inside UpdateOffsetsInTransactionResponse.operation.
type UpdateOffsetsInTransactionResult struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateOffsetsInTransactionResult) Reset() {
	*x = UpdateOffsetsInTransactionResult{}
	mi := &file_protos_ydb_topic_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateOffsetsInTransactionResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateOffsetsInTransactionResult) ProtoMessage() {}

func (x *UpdateOffsetsInTransactionResult) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateOffsetsInTransactionResult.ProtoReflect.Descriptor instead.
func (*UpdateOffsetsInTransactionResult) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{12}
}

// Commit offset request sent from client to server.
type CommitOffsetRequest struct {
	state           protoimpl.MessageState          `protogen:"open.v1"`
	OperationParams *Ydb_Operations.OperationParams `protobuf:"bytes,1,opt,name=operation_params,json=operationParams,proto3" json:"operation_params,omitempty"`
	// Topic path of partition.
	Path string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	// Partition identifier.
	PartitionId int64 `protobuf:"varint,3,opt,name=partition_id,json=partitionId,proto3" json:"partition_id,omitempty"`
	// Path of consumer.
	Consumer string `protobuf:"bytes,4,opt,name=consumer,proto3" json:"consumer,omitempty"`
	// Processed offset.
	Offset        int64 `protobuf:"varint,5,opt,name=offset,proto3" json:"offset,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CommitOffsetRequest) Reset() {
	*x = CommitOffsetRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CommitOffsetRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommitOffsetRequest) ProtoMessage() {}

func (x *CommitOffsetRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CommitOffsetRequest.ProtoReflect.Descriptor instead.
func (*CommitOffsetRequest) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{13}
}

func (x *CommitOffsetRequest) GetOperationParams() *Ydb_Operations.OperationParams {
	if x != nil {
		return x.OperationParams
	}
	return nil
}

func (x *CommitOffsetRequest) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *CommitOffsetRequest) GetPartitionId() int64 {
	if x != nil {
		return x.PartitionId
	}
	return 0
}

func (x *CommitOffsetRequest) GetConsumer() string {
	if x != nil {
		return x.Consumer
	}
	return ""
}

func (x *CommitOffsetRequest) GetOffset() int64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

// Commit offset response sent from server to client.
type CommitOffsetResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Result of request will be inside operation.
	Operation     *Ydb_Operations.Operation `protobuf:"bytes,1,opt,name=operation,proto3" json:"operation,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CommitOffsetResponse) Reset() {
	*x = CommitOffsetResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CommitOffsetResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommitOffsetResponse) ProtoMessage() {}

func (x *CommitOffsetResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CommitOffsetResponse.ProtoReflect.Descriptor instead.
func (*CommitOffsetResponse) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{14}
}

func (x *CommitOffsetResponse) GetOperation() *Ydb_Operations.Operation {
	if x != nil {
		return x.Operation
	}
	return nil
}

// Commit offset result message inside CommitOffsetResponse.operation.
type CommitOffsetResult struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CommitOffsetResult) Reset() {
	*x = CommitOffsetResult{}
	mi := &file_protos_ydb_topic_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CommitOffsetResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommitOffsetResult) ProtoMessage() {}

func (x *CommitOffsetResult) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CommitOffsetResult.ProtoReflect.Descriptor instead.
func (*CommitOffsetResult) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{15}
}

// message representing statistics by several windows
type MultipleWindowsStat struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PerMinute     int64                  `protobuf:"varint,1,opt,name=per_minute,json=perMinute,proto3" json:"per_minute,omitempty"`
	PerHour       int64                  `protobuf:"varint,2,opt,name=per_hour,json=perHour,proto3" json:"per_hour,omitempty"`
	PerDay        int64                  `protobuf:"varint,3,opt,name=per_day,json=perDay,proto3" json:"per_day,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MultipleWindowsStat) Reset() {
	*x = MultipleWindowsStat{}
	mi := &file_protos_ydb_topic_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MultipleWindowsStat) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MultipleWindowsStat) ProtoMessage() {}

func (x *MultipleWindowsStat) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MultipleWindowsStat.ProtoReflect.Descriptor instead.
func (*MultipleWindowsStat) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{16}
}

func (x *MultipleWindowsStat) GetPerMinute() int64 {
	if x != nil {
		return x.PerMinute
	}
	return 0
}

func (x *MultipleWindowsStat) GetPerHour() int64 {
	if x != nil {
		return x.PerHour
	}
	return 0
}

func (x *MultipleWindowsStat) GetPerDay() int64 {
	if x != nil {
		return x.PerDay
	}
	return 0
}

// Consumer description.
type Consumer struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Must have valid not empty name as a key.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Consumer may be marked as 'important'. It means messages for this consumer will never expire due to retention.
	// User should take care that such consumer never stalls, to prevent running out of disk space.
	// Flag that this consumer is important.
	Important bool `protobuf:"varint,2,opt,name=important,proto3" json:"important,omitempty"`
	// All messages with smaller server written_at timestamp will be skipped.
	ReadFrom *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=read_from,json=readFrom,proto3" json:"read_from,omitempty"`
	// List of supported codecs by this consumer.
	// supported_codecs on topic must be contained inside this list.
	// If empty, codec compatibility check for the consumer is disabled.
	SupportedCodecs *SupportedCodecs `protobuf:"bytes,5,opt,name=supported_codecs,json=supportedCodecs,proto3" json:"supported_codecs,omitempty"`
	// Attributes of consumer
	Attributes map[string]string `protobuf:"bytes,6,rep,name=attributes,proto3" json:"attributes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Filled only when requested statistics in Describe*Request.
	ConsumerStats *Consumer_ConsumerStats `protobuf:"bytes,7,opt,name=consumer_stats,json=consumerStats,proto3" json:"consumer_stats,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Consumer) Reset() {
	*x = Consumer{}
	mi := &file_protos_ydb_topic_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Consumer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Consumer) ProtoMessage() {}

func (x *Consumer) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Consumer.ProtoReflect.Descriptor instead.
func (*Consumer) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{17}
}

func (x *Consumer) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Consumer) GetImportant() bool {
	if x != nil {
		return x.Important
	}
	return false
}

func (x *Consumer) GetReadFrom() *timestamppb.Timestamp {
	if x != nil {
		return x.ReadFrom
	}
	return nil
}

func (x *Consumer) GetSupportedCodecs() *SupportedCodecs {
	if x != nil {
		return x.SupportedCodecs
	}
	return nil
}

func (x *Consumer) GetAttributes() map[string]string {
	if x != nil {
		return x.Attributes
	}
	return nil
}

func (x *Consumer) GetConsumerStats() *Consumer_ConsumerStats {
	if x != nil {
		return x.ConsumerStats
	}
	return nil
}

// Consumer alter description.
type AlterConsumer struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Must have valid not empty name as a key.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Consumer may be marked as 'important'. It means messages for this consumer will never expire due to retention.
	// User should take care that such consumer never stalls, to prevent running out of disk space.
	// Flag that this consumer is important.
	SetImportant *bool `protobuf:"varint,2,opt,name=set_important,json=setImportant,proto3,oneof" json:"set_important,omitempty"`
	// All messages with smaller server written_at timestamp will be skipped.
	SetReadFrom *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=set_read_from,json=setReadFrom,proto3" json:"set_read_from,omitempty"`
	// List of supported codecs by this consumer.
	// supported_codecs on topic must be contained inside this list.
	// If empty, codec compatibility check for the consumer is disabled.
	SetSupportedCodecs *SupportedCodecs `protobuf:"bytes,5,opt,name=set_supported_codecs,json=setSupportedCodecs,proto3" json:"set_supported_codecs,omitempty"`
	// User and server attributes of consumer. Server attributes starts from "_" and will be validated by server.
	// Leave the value blank to drop an attribute.
	AlterAttributes map[string]string `protobuf:"bytes,6,rep,name=alter_attributes,json=alterAttributes,proto3" json:"alter_attributes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *AlterConsumer) Reset() {
	*x = AlterConsumer{}
	mi := &file_protos_ydb_topic_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AlterConsumer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AlterConsumer) ProtoMessage() {}

func (x *AlterConsumer) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AlterConsumer.ProtoReflect.Descriptor instead.
func (*AlterConsumer) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{18}
}

func (x *AlterConsumer) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *AlterConsumer) GetSetImportant() bool {
	if x != nil && x.SetImportant != nil {
		return *x.SetImportant
	}
	return false
}

func (x *AlterConsumer) GetSetReadFrom() *timestamppb.Timestamp {
	if x != nil {
		return x.SetReadFrom
	}
	return nil
}

func (x *AlterConsumer) GetSetSupportedCodecs() *SupportedCodecs {
	if x != nil {
		return x.SetSupportedCodecs
	}
	return nil
}

func (x *AlterConsumer) GetAlterAttributes() map[string]string {
	if x != nil {
		return x.AlterAttributes
	}
	return nil
}

// Partitioning settings for topic.
type PartitioningSettings struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Auto merge would stop working when the partitions count reaches min_active_partitions
	// Zero value means default - 1.
	MinActivePartitions int64 `protobuf:"varint,1,opt,name=min_active_partitions,json=minActivePartitions,proto3" json:"min_active_partitions,omitempty"`
	// Auto split would stop working when the partitions count reaches max_active_partitions
	// Zero value means default - 1.
	MaxActivePartitions int64 `protobuf:"varint,3,opt,name=max_active_partitions,json=maxActivePartitions,proto3" json:"max_active_partitions,omitempty"`
	// Limit for total partition count, including active (open for write) and read-only partitions.
	// Zero value means default - 100.
	// Use max_active_partitions
	//
	// Deprecated: Marked as deprecated in protos/ydb_topic.proto.
	PartitionCountLimit int64 `protobuf:"varint,2,opt,name=partition_count_limit,json=partitionCountLimit,proto3" json:"partition_count_limit,omitempty"`
	// Settings for the partitions count auto partitioning.
	AutoPartitioningSettings *AutoPartitioningSettings `protobuf:"bytes,4,opt,name=auto_partitioning_settings,json=autoPartitioningSettings,proto3" json:"auto_partitioning_settings,omitempty"`
	unknownFields            protoimpl.UnknownFields
	sizeCache                protoimpl.SizeCache
}

func (x *PartitioningSettings) Reset() {
	*x = PartitioningSettings{}
	mi := &file_protos_ydb_topic_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PartitioningSettings) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PartitioningSettings) ProtoMessage() {}

func (x *PartitioningSettings) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PartitioningSettings.ProtoReflect.Descriptor instead.
func (*PartitioningSettings) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{19}
}

func (x *PartitioningSettings) GetMinActivePartitions() int64 {
	if x != nil {
		return x.MinActivePartitions
	}
	return 0
}

func (x *PartitioningSettings) GetMaxActivePartitions() int64 {
	if x != nil {
		return x.MaxActivePartitions
	}
	return 0
}

// Deprecated: Marked as deprecated in protos/ydb_topic.proto.
func (x *PartitioningSettings) GetPartitionCountLimit() int64 {
	if x != nil {
		return x.PartitionCountLimit
	}
	return 0
}

func (x *PartitioningSettings) GetAutoPartitioningSettings() *AutoPartitioningSettings {
	if x != nil {
		return x.AutoPartitioningSettings
	}
	return nil
}

type AutoPartitioningSettings struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Strategy of auto partitioning.
	Strategy AutoPartitioningStrategy `protobuf:"varint,1,opt,name=strategy,proto3,enum=Ydb.Topic.AutoPartitioningStrategy" json:"strategy,omitempty"`
	// Partition write speed auto partitioning options.
	PartitionWriteSpeed *AutoPartitioningWriteSpeedStrategy `protobuf:"bytes,2,opt,name=partition_write_speed,json=partitionWriteSpeed,proto3" json:"partition_write_speed,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *AutoPartitioningSettings) Reset() {
	*x = AutoPartitioningSettings{}
	mi := &file_protos_ydb_topic_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AutoPartitioningSettings) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AutoPartitioningSettings) ProtoMessage() {}

func (x *AutoPartitioningSettings) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AutoPartitioningSettings.ProtoReflect.Descriptor instead.
func (*AutoPartitioningSettings) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{20}
}

func (x *AutoPartitioningSettings) GetStrategy() AutoPartitioningStrategy {
	if x != nil {
		return x.Strategy
	}
	return AutoPartitioningStrategy_AUTO_PARTITIONING_STRATEGY_UNSPECIFIED
}

func (x *AutoPartitioningSettings) GetPartitionWriteSpeed() *AutoPartitioningWriteSpeedStrategy {
	if x != nil {
		return x.PartitionWriteSpeed
	}
	return nil
}

type AutoPartitioningWriteSpeedStrategy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Zero value means default - 300.
	StabilizationWindow *durationpb.Duration `protobuf:"bytes,1,opt,name=stabilization_window,json=stabilizationWindow,proto3" json:"stabilization_window,omitempty"`
	// Zero value means default - 90.
	UpUtilizationPercent int32 `protobuf:"varint,2,opt,name=up_utilization_percent,json=upUtilizationPercent,proto3" json:"up_utilization_percent,omitempty"`
	// Zero value means default - 30.
	DownUtilizationPercent int32 `protobuf:"varint,3,opt,name=down_utilization_percent,json=downUtilizationPercent,proto3" json:"down_utilization_percent,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *AutoPartitioningWriteSpeedStrategy) Reset() {
	*x = AutoPartitioningWriteSpeedStrategy{}
	mi := &file_protos_ydb_topic_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AutoPartitioningWriteSpeedStrategy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AutoPartitioningWriteSpeedStrategy) ProtoMessage() {}

func (x *AutoPartitioningWriteSpeedStrategy) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AutoPartitioningWriteSpeedStrategy.ProtoReflect.Descriptor instead.
func (*AutoPartitioningWriteSpeedStrategy) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{21}
}

func (x *AutoPartitioningWriteSpeedStrategy) GetStabilizationWindow() *durationpb.Duration {
	if x != nil {
		return x.StabilizationWindow
	}
	return nil
}

func (x *AutoPartitioningWriteSpeedStrategy) GetUpUtilizationPercent() int32 {
	if x != nil {
		return x.UpUtilizationPercent
	}
	return 0
}

func (x *AutoPartitioningWriteSpeedStrategy) GetDownUtilizationPercent() int32 {
	if x != nil {
		return x.DownUtilizationPercent
	}
	return 0
}

// Partitioning settings for topic.
type AlterPartitioningSettings struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Minimum partition count auto merge would stop working at.
	// Zero value means default - 1.
	SetMinActivePartitions *int64 `protobuf:"varint,1,opt,name=set_min_active_partitions,json=setMinActivePartitions,proto3,oneof" json:"set_min_active_partitions,omitempty"`
	// Maximum partition count auto merge would stop working at.
	// Zero value means default - 1.
	SetMaxActivePartitions *int64 `protobuf:"varint,3,opt,name=set_max_active_partitions,json=setMaxActivePartitions,proto3,oneof" json:"set_max_active_partitions,omitempty"`
	// Limit for total partition count, including active (open for write) and read-only partitions.
	// Zero value means default - 100.
	// Use set_max_active_partitions
	//
	// Deprecated: Marked as deprecated in protos/ydb_topic.proto.
	SetPartitionCountLimit *int64 `protobuf:"varint,2,opt,name=set_partition_count_limit,json=setPartitionCountLimit,proto3,oneof" json:"set_partition_count_limit,omitempty"`
	// Settings for auto partitioning the partition number
	AlterAutoPartitioningSettings *AlterAutoPartitioningSettings `protobuf:"bytes,4,opt,name=alter_auto_partitioning_settings,json=alterAutoPartitioningSettings,proto3,oneof" json:"alter_auto_partitioning_settings,omitempty"`
	unknownFields                 protoimpl.UnknownFields
	sizeCache                     protoimpl.SizeCache
}

func (x *AlterPartitioningSettings) Reset() {
	*x = AlterPartitioningSettings{}
	mi := &file_protos_ydb_topic_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AlterPartitioningSettings) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AlterPartitioningSettings) ProtoMessage() {}

func (x *AlterPartitioningSettings) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AlterPartitioningSettings.ProtoReflect.Descriptor instead.
func (*AlterPartitioningSettings) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{22}
}

func (x *AlterPartitioningSettings) GetSetMinActivePartitions() int64 {
	if x != nil && x.SetMinActivePartitions != nil {
		return *x.SetMinActivePartitions
	}
	return 0
}

func (x *AlterPartitioningSettings) GetSetMaxActivePartitions() int64 {
	if x != nil && x.SetMaxActivePartitions != nil {
		return *x.SetMaxActivePartitions
	}
	return 0
}

// Deprecated: Marked as deprecated in protos/ydb_topic.proto.
func (x *AlterPartitioningSettings) GetSetPartitionCountLimit() int64 {
	if x != nil && x.SetPartitionCountLimit != nil {
		return *x.SetPartitionCountLimit
	}
	return 0
}

func (x *AlterPartitioningSettings) GetAlterAutoPartitioningSettings() *AlterAutoPartitioningSettings {
	if x != nil {
		return x.AlterAutoPartitioningSettings
	}
	return nil
}

type AlterAutoPartitioningSettings struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Strategy of auto partitioning
	SetStrategy *AutoPartitioningStrategy `protobuf:"varint,1,opt,name=set_strategy,json=setStrategy,proto3,enum=Ydb.Topic.AutoPartitioningStrategy,oneof" json:"set_strategy,omitempty"`
	// Auto partitioning write speed options.
	SetPartitionWriteSpeed *AlterAutoPartitioningWriteSpeedStrategy `protobuf:"bytes,2,opt,name=set_partition_write_speed,json=setPartitionWriteSpeed,proto3,oneof" json:"set_partition_write_speed,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *AlterAutoPartitioningSettings) Reset() {
	*x = AlterAutoPartitioningSettings{}
	mi := &file_protos_ydb_topic_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AlterAutoPartitioningSettings) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AlterAutoPartitioningSettings) ProtoMessage() {}

func (x *AlterAutoPartitioningSettings) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AlterAutoPartitioningSettings.ProtoReflect.Descriptor instead.
func (*AlterAutoPartitioningSettings) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{23}
}

func (x *AlterAutoPartitioningSettings) GetSetStrategy() AutoPartitioningStrategy {
	if x != nil && x.SetStrategy != nil {
		return *x.SetStrategy
	}
	return AutoPartitioningStrategy_AUTO_PARTITIONING_STRATEGY_UNSPECIFIED
}

func (x *AlterAutoPartitioningSettings) GetSetPartitionWriteSpeed() *AlterAutoPartitioningWriteSpeedStrategy {
	if x != nil {
		return x.SetPartitionWriteSpeed
	}
	return nil
}

type AlterAutoPartitioningWriteSpeedStrategy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The time of exceeding the threshold value, after which the partition will be
	// auto partitioning.
	// Zero value means default - 300.
	SetStabilizationWindow *durationpb.Duration `protobuf:"bytes,1,opt,name=set_stabilization_window,json=setStabilizationWindow,proto3,oneof" json:"set_stabilization_window,omitempty"`
	// The threshold value of the write speed to the partition as a percentage, when exceeded,
	// the partition will be auto split.
	// Zero value means default - 90.
	SetUpUtilizationPercent *int32 `protobuf:"varint,2,opt,name=set_up_utilization_percent,json=setUpUtilizationPercent,proto3,oneof" json:"set_up_utilization_percent,omitempty"`
	// The threshold value of the write speed to the partition as a percentage, if it is not reached,
	// the partition will be auto merged.
	// Zero value means default - 30.
	SetDownUtilizationPercent *int32 `protobuf:"varint,3,opt,name=set_down_utilization_percent,json=setDownUtilizationPercent,proto3,oneof" json:"set_down_utilization_percent,omitempty"`
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *AlterAutoPartitioningWriteSpeedStrategy) Reset() {
	*x = AlterAutoPartitioningWriteSpeedStrategy{}
	mi := &file_protos_ydb_topic_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AlterAutoPartitioningWriteSpeedStrategy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AlterAutoPartitioningWriteSpeedStrategy) ProtoMessage() {}

func (x *AlterAutoPartitioningWriteSpeedStrategy) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AlterAutoPartitioningWriteSpeedStrategy.ProtoReflect.Descriptor instead.
func (*AlterAutoPartitioningWriteSpeedStrategy) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{24}
}

func (x *AlterAutoPartitioningWriteSpeedStrategy) GetSetStabilizationWindow() *durationpb.Duration {
	if x != nil {
		return x.SetStabilizationWindow
	}
	return nil
}

func (x *AlterAutoPartitioningWriteSpeedStrategy) GetSetUpUtilizationPercent() int32 {
	if x != nil && x.SetUpUtilizationPercent != nil {
		return *x.SetUpUtilizationPercent
	}
	return 0
}

func (x *AlterAutoPartitioningWriteSpeedStrategy) GetSetDownUtilizationPercent() int32 {
	if x != nil && x.SetDownUtilizationPercent != nil {
		return *x.SetDownUtilizationPercent
	}
	return 0
}

// Create topic request sent from client to server.
type CreateTopicRequest struct {
	state           protoimpl.MessageState          `protogen:"open.v1"`
	OperationParams *Ydb_Operations.OperationParams `protobuf:"bytes,1,opt,name=operation_params,json=operationParams,proto3" json:"operation_params,omitempty"`
	// Topic path.
	Path string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	// Settings for partitioning
	PartitioningSettings *PartitioningSettings `protobuf:"bytes,3,opt,name=partitioning_settings,json=partitioningSettings,proto3" json:"partitioning_settings,omitempty"`
	// Retention settings.
	// Currently, only one limit may be set, so other should not be set.
	//
	// How long data in partition should be stored. Must be greater than 0 and less than limit for this database.
	// Default limit - 36 hours.
	RetentionPeriod *durationpb.Duration `protobuf:"bytes,4,opt,name=retention_period,json=retentionPeriod,proto3" json:"retention_period,omitempty"`
	// How much data in partition should be stored. Must be greater than 0 and less than limit for this database.
	// Zero value means infinite limit.
	RetentionStorageMb int64 `protobuf:"varint,5,opt,name=retention_storage_mb,json=retentionStorageMb,proto3" json:"retention_storage_mb,omitempty"`
	// List of allowed codecs for writers.
	// Writes with codec not from this list are forbidden.
	// If empty, codec compatibility check for the topic is disabled.
	SupportedCodecs *SupportedCodecs `protobuf:"bytes,7,opt,name=supported_codecs,json=supportedCodecs,proto3" json:"supported_codecs,omitempty"`
	// Partition write speed in bytes per second. Must be less than database limit.
	// Zero value means default limit: 1 MB per second.
	PartitionWriteSpeedBytesPerSecond int64 `protobuf:"varint,8,opt,name=partition_write_speed_bytes_per_second,json=partitionWriteSpeedBytesPerSecond,proto3" json:"partition_write_speed_bytes_per_second,omitempty"`
	// Burst size for write in partition, in bytes. Must be less than database limit.
	// Zero value means default limit: 1 MB.
	PartitionWriteBurstBytes int64 `protobuf:"varint,9,opt,name=partition_write_burst_bytes,json=partitionWriteBurstBytes,proto3" json:"partition_write_burst_bytes,omitempty"`
	// User and server attributes of topic. Server attributes starts from "_" and will be validated by server.
	Attributes map[string]string `protobuf:"bytes,10,rep,name=attributes,proto3" json:"attributes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// List of consumers for this topic.
	Consumers []*Consumer `protobuf:"bytes,11,rep,name=consumers,proto3" json:"consumers,omitempty"`
	// Metering mode for the topic in a serverless database.
	MeteringMode  MeteringMode `protobuf:"varint,12,opt,name=metering_mode,json=meteringMode,proto3,enum=Ydb.Topic.MeteringMode" json:"metering_mode,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateTopicRequest) Reset() {
	*x = CreateTopicRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateTopicRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateTopicRequest) ProtoMessage() {}

func (x *CreateTopicRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateTopicRequest.ProtoReflect.Descriptor instead.
func (*CreateTopicRequest) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{25}
}

func (x *CreateTopicRequest) GetOperationParams() *Ydb_Operations.OperationParams {
	if x != nil {
		return x.OperationParams
	}
	return nil
}

func (x *CreateTopicRequest) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *CreateTopicRequest) GetPartitioningSettings() *PartitioningSettings {
	if x != nil {
		return x.PartitioningSettings
	}
	return nil
}

func (x *CreateTopicRequest) GetRetentionPeriod() *durationpb.Duration {
	if x != nil {
		return x.RetentionPeriod
	}
	return nil
}

func (x *CreateTopicRequest) GetRetentionStorageMb() int64 {
	if x != nil {
		return x.RetentionStorageMb
	}
	return 0
}

func (x *CreateTopicRequest) GetSupportedCodecs() *SupportedCodecs {
	if x != nil {
		return x.SupportedCodecs
	}
	return nil
}

func (x *CreateTopicRequest) GetPartitionWriteSpeedBytesPerSecond() int64 {
	if x != nil {
		return x.PartitionWriteSpeedBytesPerSecond
	}
	return 0
}

func (x *CreateTopicRequest) GetPartitionWriteBurstBytes() int64 {
	if x != nil {
		return x.PartitionWriteBurstBytes
	}
	return 0
}

func (x *CreateTopicRequest) GetAttributes() map[string]string {
	if x != nil {
		return x.Attributes
	}
	return nil
}

func (x *CreateTopicRequest) GetConsumers() []*Consumer {
	if x != nil {
		return x.Consumers
	}
	return nil
}

func (x *CreateTopicRequest) GetMeteringMode() MeteringMode {
	if x != nil {
		return x.MeteringMode
	}
	return MeteringMode_METERING_MODE_UNSPECIFIED
}

// Create topic response sent from server to client.
// If topic is already exists then response status will be "ALREADY_EXISTS".
type CreateTopicResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Result of request will be inside operation.
	Operation     *Ydb_Operations.Operation `protobuf:"bytes,1,opt,name=operation,proto3" json:"operation,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateTopicResponse) Reset() {
	*x = CreateTopicResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateTopicResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateTopicResponse) ProtoMessage() {}

func (x *CreateTopicResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateTopicResponse.ProtoReflect.Descriptor instead.
func (*CreateTopicResponse) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{26}
}

func (x *CreateTopicResponse) GetOperation() *Ydb_Operations.Operation {
	if x != nil {
		return x.Operation
	}
	return nil
}

// Create topic result message that will be inside CreateTopicResponse.operation.
type CreateTopicResult struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateTopicResult) Reset() {
	*x = CreateTopicResult{}
	mi := &file_protos_ydb_topic_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateTopicResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateTopicResult) ProtoMessage() {}

func (x *CreateTopicResult) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateTopicResult.ProtoReflect.Descriptor instead.
func (*CreateTopicResult) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{27}
}

// Topic partition location
type PartitionLocation struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Node identificator.
	NodeId int32 `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// Partition generation.
	Generation    int64 `protobuf:"varint,2,opt,name=generation,proto3" json:"generation,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PartitionLocation) Reset() {
	*x = PartitionLocation{}
	mi := &file_protos_ydb_topic_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PartitionLocation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PartitionLocation) ProtoMessage() {}

func (x *PartitionLocation) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PartitionLocation.ProtoReflect.Descriptor instead.
func (*PartitionLocation) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{28}
}

func (x *PartitionLocation) GetNodeId() int32 {
	if x != nil {
		return x.NodeId
	}
	return 0
}

func (x *PartitionLocation) GetGeneration() int64 {
	if x != nil {
		return x.Generation
	}
	return 0
}

// Describe topic request sent from client to server.
type DescribeTopicRequest struct {
	state           protoimpl.MessageState          `protogen:"open.v1"`
	OperationParams *Ydb_Operations.OperationParams `protobuf:"bytes,1,opt,name=operation_params,json=operationParams,proto3" json:"operation_params,omitempty"`
	// Topic path.
	Path string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	// Include topic statistics.
	IncludeStats bool `protobuf:"varint,3,opt,name=include_stats,json=includeStats,proto3" json:"include_stats,omitempty"`
	// Include partition location.
	IncludeLocation bool `protobuf:"varint,4,opt,name=include_location,json=includeLocation,proto3" json:"include_location,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *DescribeTopicRequest) Reset() {
	*x = DescribeTopicRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DescribeTopicRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DescribeTopicRequest) ProtoMessage() {}

func (x *DescribeTopicRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DescribeTopicRequest.ProtoReflect.Descriptor instead.
func (*DescribeTopicRequest) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{29}
}

func (x *DescribeTopicRequest) GetOperationParams() *Ydb_Operations.OperationParams {
	if x != nil {
		return x.OperationParams
	}
	return nil
}

func (x *DescribeTopicRequest) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *DescribeTopicRequest) GetIncludeStats() bool {
	if x != nil {
		return x.IncludeStats
	}
	return false
}

func (x *DescribeTopicRequest) GetIncludeLocation() bool {
	if x != nil {
		return x.IncludeLocation
	}
	return false
}

// Describe topic response sent from server to client.
// If topic is not existed then response status will be "SCHEME_ERROR".
type DescribeTopicResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Result of request will be inside operation.
	Operation     *Ydb_Operations.Operation `protobuf:"bytes,1,opt,name=operation,proto3" json:"operation,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DescribeTopicResponse) Reset() {
	*x = DescribeTopicResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DescribeTopicResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DescribeTopicResponse) ProtoMessage() {}

func (x *DescribeTopicResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DescribeTopicResponse.ProtoReflect.Descriptor instead.
func (*DescribeTopicResponse) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{30}
}

func (x *DescribeTopicResponse) GetOperation() *Ydb_Operations.Operation {
	if x != nil {
		return x.Operation
	}
	return nil
}

type PartitionKeyRange struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Inclusive left border. Emptiness means -inf.
	FromBound []byte `protobuf:"bytes,1,opt,name=from_bound,json=fromBound,proto3,oneof" json:"from_bound,omitempty"`
	// Exclusive right border. Emptiness means +inf.
	ToBound       []byte `protobuf:"bytes,2,opt,name=to_bound,json=toBound,proto3,oneof" json:"to_bound,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PartitionKeyRange) Reset() {
	*x = PartitionKeyRange{}
	mi := &file_protos_ydb_topic_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PartitionKeyRange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PartitionKeyRange) ProtoMessage() {}

func (x *PartitionKeyRange) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PartitionKeyRange.ProtoReflect.Descriptor instead.
func (*PartitionKeyRange) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{31}
}

func (x *PartitionKeyRange) GetFromBound() []byte {
	if x != nil {
		return x.FromBound
	}
	return nil
}

func (x *PartitionKeyRange) GetToBound() []byte {
	if x != nil {
		return x.ToBound
	}
	return nil
}

// Describe topic result message that will be inside DescribeTopicResponse.operation.
type DescribeTopicResult struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Description of scheme object.
	Self *Ydb_Scheme.Entry `protobuf:"bytes,1,opt,name=self,proto3" json:"self,omitempty"`
	// Settings for partitioning
	PartitioningSettings *PartitioningSettings `protobuf:"bytes,2,opt,name=partitioning_settings,json=partitioningSettings,proto3" json:"partitioning_settings,omitempty"`
	// Partitions description.
	Partitions []*DescribeTopicResult_PartitionInfo `protobuf:"bytes,3,rep,name=partitions,proto3" json:"partitions,omitempty"`
	// Retention settings.
	// Currently, only one limit may be set, so other should not be set.
	//
	// How long data in partition should be stored.
	RetentionPeriod *durationpb.Duration `protobuf:"bytes,4,opt,name=retention_period,json=retentionPeriod,proto3" json:"retention_period,omitempty"`
	// How much data in partition should be stored.
	// Zero value means infinite limit.
	RetentionStorageMb int64 `protobuf:"varint,5,opt,name=retention_storage_mb,json=retentionStorageMb,proto3" json:"retention_storage_mb,omitempty"`
	// List of allowed codecs for writers.
	// Writes with codec not from this list are forbidden.
	// If empty, codec compatibility check for the topic is disabled.
	SupportedCodecs *SupportedCodecs `protobuf:"bytes,7,opt,name=supported_codecs,json=supportedCodecs,proto3" json:"supported_codecs,omitempty"`
	// Partition write speed in bytes per second.
	// Zero value means default limit: 1 MB per second.
	PartitionWriteSpeedBytesPerSecond        int64 `protobuf:"varint,8,opt,name=partition_write_speed_bytes_per_second,json=partitionWriteSpeedBytesPerSecond,proto3" json:"partition_write_speed_bytes_per_second,omitempty"`
	PartitionTotalReadSpeedBytesPerSecond    int64 `protobuf:"varint,14,opt,name=partition_total_read_speed_bytes_per_second,json=partitionTotalReadSpeedBytesPerSecond,proto3" json:"partition_total_read_speed_bytes_per_second,omitempty"`
	PartitionConsumerReadSpeedBytesPerSecond int64 `protobuf:"varint,15,opt,name=partition_consumer_read_speed_bytes_per_second,json=partitionConsumerReadSpeedBytesPerSecond,proto3" json:"partition_consumer_read_speed_bytes_per_second,omitempty"`
	// Burst size for write in partition, in bytes.
	// Zero value means default limit: 1 MB.
	PartitionWriteBurstBytes int64 `protobuf:"varint,9,opt,name=partition_write_burst_bytes,json=partitionWriteBurstBytes,proto3" json:"partition_write_burst_bytes,omitempty"`
	// User and server attributes of topic. Server attributes starts from "_" and will be validated by server.
	Attributes map[string]string `protobuf:"bytes,10,rep,name=attributes,proto3" json:"attributes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// List of consumers for this topic.
	Consumers []*Consumer `protobuf:"bytes,11,rep,name=consumers,proto3" json:"consumers,omitempty"`
	// Metering settings.
	MeteringMode MeteringMode `protobuf:"varint,12,opt,name=metering_mode,json=meteringMode,proto3,enum=Ydb.Topic.MeteringMode" json:"metering_mode,omitempty"`
	// Statistics of topic.
	TopicStats    *DescribeTopicResult_TopicStats `protobuf:"bytes,13,opt,name=topic_stats,json=topicStats,proto3" json:"topic_stats,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DescribeTopicResult) Reset() {
	*x = DescribeTopicResult{}
	mi := &file_protos_ydb_topic_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DescribeTopicResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DescribeTopicResult) ProtoMessage() {}

func (x *DescribeTopicResult) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DescribeTopicResult.ProtoReflect.Descriptor instead.
func (*DescribeTopicResult) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{32}
}

func (x *DescribeTopicResult) GetSelf() *Ydb_Scheme.Entry {
	if x != nil {
		return x.Self
	}
	return nil
}

func (x *DescribeTopicResult) GetPartitioningSettings() *PartitioningSettings {
	if x != nil {
		return x.PartitioningSettings
	}
	return nil
}

func (x *DescribeTopicResult) GetPartitions() []*DescribeTopicResult_PartitionInfo {
	if x != nil {
		return x.Partitions
	}
	return nil
}

func (x *DescribeTopicResult) GetRetentionPeriod() *durationpb.Duration {
	if x != nil {
		return x.RetentionPeriod
	}
	return nil
}

func (x *DescribeTopicResult) GetRetentionStorageMb() int64 {
	if x != nil {
		return x.RetentionStorageMb
	}
	return 0
}

func (x *DescribeTopicResult) GetSupportedCodecs() *SupportedCodecs {
	if x != nil {
		return x.SupportedCodecs
	}
	return nil
}

func (x *DescribeTopicResult) GetPartitionWriteSpeedBytesPerSecond() int64 {
	if x != nil {
		return x.PartitionWriteSpeedBytesPerSecond
	}
	return 0
}

func (x *DescribeTopicResult) GetPartitionTotalReadSpeedBytesPerSecond() int64 {
	if x != nil {
		return x.PartitionTotalReadSpeedBytesPerSecond
	}
	return 0
}

func (x *DescribeTopicResult) GetPartitionConsumerReadSpeedBytesPerSecond() int64 {
	if x != nil {
		return x.PartitionConsumerReadSpeedBytesPerSecond
	}
	return 0
}

func (x *DescribeTopicResult) GetPartitionWriteBurstBytes() int64 {
	if x != nil {
		return x.PartitionWriteBurstBytes
	}
	return 0
}

func (x *DescribeTopicResult) GetAttributes() map[string]string {
	if x != nil {
		return x.Attributes
	}
	return nil
}

func (x *DescribeTopicResult) GetConsumers() []*Consumer {
	if x != nil {
		return x.Consumers
	}
	return nil
}

func (x *DescribeTopicResult) GetMeteringMode() MeteringMode {
	if x != nil {
		return x.MeteringMode
	}
	return MeteringMode_METERING_MODE_UNSPECIFIED
}

func (x *DescribeTopicResult) GetTopicStats() *DescribeTopicResult_TopicStats {
	if x != nil {
		return x.TopicStats
	}
	return nil
}

// Describe partition request sent from client to server.
type DescribePartitionRequest struct {
	state           protoimpl.MessageState          `protogen:"open.v1"`
	OperationParams *Ydb_Operations.OperationParams `protobuf:"bytes,1,opt,name=operation_params,json=operationParams,proto3" json:"operation_params,omitempty"`
	// Topic path.
	Path string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	// Partition identifier.
	PartitionId int64 `protobuf:"varint,3,opt,name=partition_id,json=partitionId,proto3" json:"partition_id,omitempty"`
	// Include partition statistics.
	IncludeStats bool `protobuf:"varint,4,opt,name=include_stats,json=includeStats,proto3" json:"include_stats,omitempty"`
	// Include partition location.
	IncludeLocation bool `protobuf:"varint,5,opt,name=include_location,json=includeLocation,proto3" json:"include_location,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *DescribePartitionRequest) Reset() {
	*x = DescribePartitionRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DescribePartitionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DescribePartitionRequest) ProtoMessage() {}

func (x *DescribePartitionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DescribePartitionRequest.ProtoReflect.Descriptor instead.
func (*DescribePartitionRequest) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{33}
}

func (x *DescribePartitionRequest) GetOperationParams() *Ydb_Operations.OperationParams {
	if x != nil {
		return x.OperationParams
	}
	return nil
}

func (x *DescribePartitionRequest) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *DescribePartitionRequest) GetPartitionId() int64 {
	if x != nil {
		return x.PartitionId
	}
	return 0
}

func (x *DescribePartitionRequest) GetIncludeStats() bool {
	if x != nil {
		return x.IncludeStats
	}
	return false
}

func (x *DescribePartitionRequest) GetIncludeLocation() bool {
	if x != nil {
		return x.IncludeLocation
	}
	return false
}

// Describe partition response sent from server to client.
// If topic is not existed then response status will be "SCHEME_ERROR".
type DescribePartitionResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Result of request will be inside operation.
	Operation     *Ydb_Operations.Operation `protobuf:"bytes,1,opt,name=operation,proto3" json:"operation,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DescribePartitionResponse) Reset() {
	*x = DescribePartitionResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DescribePartitionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DescribePartitionResponse) ProtoMessage() {}

func (x *DescribePartitionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DescribePartitionResponse.ProtoReflect.Descriptor instead.
func (*DescribePartitionResponse) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{34}
}

func (x *DescribePartitionResponse) GetOperation() *Ydb_Operations.Operation {
	if x != nil {
		return x.Operation
	}
	return nil
}

// Describe partition result message that will be inside DescribePartitionResponse.operation.
type DescribePartitionResult struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Partitions description.
	Partition     *DescribeTopicResult_PartitionInfo `protobuf:"bytes,1,opt,name=partition,proto3" json:"partition,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DescribePartitionResult) Reset() {
	*x = DescribePartitionResult{}
	mi := &file_protos_ydb_topic_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DescribePartitionResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DescribePartitionResult) ProtoMessage() {}

func (x *DescribePartitionResult) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DescribePartitionResult.ProtoReflect.Descriptor instead.
func (*DescribePartitionResult) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{35}
}

func (x *DescribePartitionResult) GetPartition() *DescribeTopicResult_PartitionInfo {
	if x != nil {
		return x.Partition
	}
	return nil
}

// Describe topic's consumer request sent from client to server.
type DescribeConsumerRequest struct {
	state           protoimpl.MessageState          `protogen:"open.v1"`
	OperationParams *Ydb_Operations.OperationParams `protobuf:"bytes,1,opt,name=operation_params,json=operationParams,proto3" json:"operation_params,omitempty"`
	// Topic path.
	Path string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	// Consumer name;
	Consumer string `protobuf:"bytes,3,opt,name=consumer,proto3" json:"consumer,omitempty"`
	// Include consumer statistics.
	IncludeStats bool `protobuf:"varint,4,opt,name=include_stats,json=includeStats,proto3" json:"include_stats,omitempty"`
	// Include partition location.
	IncludeLocation bool `protobuf:"varint,5,opt,name=include_location,json=includeLocation,proto3" json:"include_location,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *DescribeConsumerRequest) Reset() {
	*x = DescribeConsumerRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DescribeConsumerRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DescribeConsumerRequest) ProtoMessage() {}

func (x *DescribeConsumerRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DescribeConsumerRequest.ProtoReflect.Descriptor instead.
func (*DescribeConsumerRequest) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{36}
}

func (x *DescribeConsumerRequest) GetOperationParams() *Ydb_Operations.OperationParams {
	if x != nil {
		return x.OperationParams
	}
	return nil
}

func (x *DescribeConsumerRequest) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *DescribeConsumerRequest) GetConsumer() string {
	if x != nil {
		return x.Consumer
	}
	return ""
}

func (x *DescribeConsumerRequest) GetIncludeStats() bool {
	if x != nil {
		return x.IncludeStats
	}
	return false
}

func (x *DescribeConsumerRequest) GetIncludeLocation() bool {
	if x != nil {
		return x.IncludeLocation
	}
	return false
}

// Describe topic's consumer response sent from server to client.
// If topic is not existed then response status will be "SCHEME_ERROR".
type DescribeConsumerResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Result of request will be inside operation.
	Operation     *Ydb_Operations.Operation `protobuf:"bytes,1,opt,name=operation,proto3" json:"operation,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DescribeConsumerResponse) Reset() {
	*x = DescribeConsumerResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DescribeConsumerResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DescribeConsumerResponse) ProtoMessage() {}

func (x *DescribeConsumerResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DescribeConsumerResponse.ProtoReflect.Descriptor instead.
func (*DescribeConsumerResponse) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{37}
}

func (x *DescribeConsumerResponse) GetOperation() *Ydb_Operations.Operation {
	if x != nil {
		return x.Operation
	}
	return nil
}

// Describe topic's consumer result message that will be inside DescribeConsumerResponse.operation.
type DescribeConsumerResult struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Description of scheme object.
	Self          *Ydb_Scheme.Entry                       `protobuf:"bytes,1,opt,name=self,proto3" json:"self,omitempty"`
	Consumer      *Consumer                               `protobuf:"bytes,2,opt,name=consumer,proto3" json:"consumer,omitempty"`
	Partitions    []*DescribeConsumerResult_PartitionInfo `protobuf:"bytes,3,rep,name=partitions,proto3" json:"partitions,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DescribeConsumerResult) Reset() {
	*x = DescribeConsumerResult{}
	mi := &file_protos_ydb_topic_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DescribeConsumerResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DescribeConsumerResult) ProtoMessage() {}

func (x *DescribeConsumerResult) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DescribeConsumerResult.ProtoReflect.Descriptor instead.
func (*DescribeConsumerResult) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{38}
}

func (x *DescribeConsumerResult) GetSelf() *Ydb_Scheme.Entry {
	if x != nil {
		return x.Self
	}
	return nil
}

func (x *DescribeConsumerResult) GetConsumer() *Consumer {
	if x != nil {
		return x.Consumer
	}
	return nil
}

func (x *DescribeConsumerResult) GetPartitions() []*DescribeConsumerResult_PartitionInfo {
	if x != nil {
		return x.Partitions
	}
	return nil
}

type PartitionStats struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Partition contains messages with offsets in range [start, end).
	PartitionOffsets *OffsetsRange `protobuf:"bytes,1,opt,name=partition_offsets,json=partitionOffsets,proto3" json:"partition_offsets,omitempty"`
	// Approximate size of partition.
	StoreSizeBytes int64 `protobuf:"varint,2,opt,name=store_size_bytes,json=storeSizeBytes,proto3" json:"store_size_bytes,omitempty"`
	// Timestamp of last write.
	LastWriteTime *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=last_write_time,json=lastWriteTime,proto3" json:"last_write_time,omitempty"`
	// Maximum of differences between write timestamp and create timestamp for all messages, written during last minute.
	MaxWriteTimeLag *durationpb.Duration `protobuf:"bytes,4,opt,name=max_write_time_lag,json=maxWriteTimeLag,proto3" json:"max_write_time_lag,omitempty"`
	// How much bytes were written during several windows in this partition.
	BytesWritten *MultipleWindowsStat `protobuf:"bytes,5,opt,name=bytes_written,json=bytesWritten,proto3" json:"bytes_written,omitempty"`
	// Partition host. Useful for debugging purposes.
	//
	// Deprecated: Marked as deprecated in protos/ydb_topic.proto.
	PartitionNodeId int32 `protobuf:"varint,8,opt,name=partition_node_id,json=partitionNodeId,proto3" json:"partition_node_id,omitempty"` //Use PartitionLocation
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *PartitionStats) Reset() {
	*x = PartitionStats{}
	mi := &file_protos_ydb_topic_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PartitionStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PartitionStats) ProtoMessage() {}

func (x *PartitionStats) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PartitionStats.ProtoReflect.Descriptor instead.
func (*PartitionStats) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{39}
}

func (x *PartitionStats) GetPartitionOffsets() *OffsetsRange {
	if x != nil {
		return x.PartitionOffsets
	}
	return nil
}

func (x *PartitionStats) GetStoreSizeBytes() int64 {
	if x != nil {
		return x.StoreSizeBytes
	}
	return 0
}

func (x *PartitionStats) GetLastWriteTime() *timestamppb.Timestamp {
	if x != nil {
		return x.LastWriteTime
	}
	return nil
}

func (x *PartitionStats) GetMaxWriteTimeLag() *durationpb.Duration {
	if x != nil {
		return x.MaxWriteTimeLag
	}
	return nil
}

func (x *PartitionStats) GetBytesWritten() *MultipleWindowsStat {
	if x != nil {
		return x.BytesWritten
	}
	return nil
}

// Deprecated: Marked as deprecated in protos/ydb_topic.proto.
func (x *PartitionStats) GetPartitionNodeId() int32 {
	if x != nil {
		return x.PartitionNodeId
	}
	return 0
}

// Update existing topic request sent from client to server.
type AlterTopicRequest struct {
	state           protoimpl.MessageState          `protogen:"open.v1"`
	OperationParams *Ydb_Operations.OperationParams `protobuf:"bytes,1,opt,name=operation_params,json=operationParams,proto3" json:"operation_params,omitempty"`
	// Topic path.
	Path                      string                     `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	AlterPartitioningSettings *AlterPartitioningSettings `protobuf:"bytes,3,opt,name=alter_partitioning_settings,json=alterPartitioningSettings,proto3" json:"alter_partitioning_settings,omitempty"` // partitioning_settings
	// Retention settings.
	// Currently, only one limit may be set, so other should not be set.
	//
	// How long data in partition should be stored. Must be greater than 0 and less than limit for this database.
	// Default limit - 36 hours.
	SetRetentionPeriod *durationpb.Duration `protobuf:"bytes,4,opt,name=set_retention_period,json=setRetentionPeriod,proto3" json:"set_retention_period,omitempty"`
	// How much data in partition should be stored. Must be greater than 0 and less than limit for this database.
	SetRetentionStorageMb *int64 `protobuf:"varint,5,opt,name=set_retention_storage_mb,json=setRetentionStorageMb,proto3,oneof" json:"set_retention_storage_mb,omitempty"`
	// List of allowed codecs for writers.
	// Writes with codec not from this list are forbidden.
	// If empty, codec compatibility check for the topic is disabled.
	SetSupportedCodecs *SupportedCodecs `protobuf:"bytes,7,opt,name=set_supported_codecs,json=setSupportedCodecs,proto3" json:"set_supported_codecs,omitempty"`
	// Partition write speed in bytes per second. Must be less than database limit. Default limit - 1 MB/s.
	SetPartitionWriteSpeedBytesPerSecond *int64 `protobuf:"varint,8,opt,name=set_partition_write_speed_bytes_per_second,json=setPartitionWriteSpeedBytesPerSecond,proto3,oneof" json:"set_partition_write_speed_bytes_per_second,omitempty"`
	// Burst size for write in partition, in bytes. Must be less than database limit. Default limit - 1 MB.
	SetPartitionWriteBurstBytes *int64 `protobuf:"varint,9,opt,name=set_partition_write_burst_bytes,json=setPartitionWriteBurstBytes,proto3,oneof" json:"set_partition_write_burst_bytes,omitempty"`
	// User and server attributes of topic. Server attributes starts from "_" and will be validated by server.
	// Leave the value blank to drop an attribute.
	AlterAttributes map[string]string `protobuf:"bytes,10,rep,name=alter_attributes,json=alterAttributes,proto3" json:"alter_attributes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Add consumers.
	AddConsumers []*Consumer `protobuf:"bytes,11,rep,name=add_consumers,json=addConsumers,proto3" json:"add_consumers,omitempty"`
	// Remove consumers (by their names)
	DropConsumers []string `protobuf:"bytes,12,rep,name=drop_consumers,json=dropConsumers,proto3" json:"drop_consumers,omitempty"`
	// Alter consumers
	AlterConsumers []*AlterConsumer `protobuf:"bytes,13,rep,name=alter_consumers,json=alterConsumers,proto3" json:"alter_consumers,omitempty"`
	// Set metering mode for topic in serverless database.
	SetMeteringMode MeteringMode `protobuf:"varint,14,opt,name=set_metering_mode,json=setMeteringMode,proto3,enum=Ydb.Topic.MeteringMode" json:"set_metering_mode,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *AlterTopicRequest) Reset() {
	*x = AlterTopicRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[40]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AlterTopicRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AlterTopicRequest) ProtoMessage() {}

func (x *AlterTopicRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[40]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AlterTopicRequest.ProtoReflect.Descriptor instead.
func (*AlterTopicRequest) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{40}
}

func (x *AlterTopicRequest) GetOperationParams() *Ydb_Operations.OperationParams {
	if x != nil {
		return x.OperationParams
	}
	return nil
}

func (x *AlterTopicRequest) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *AlterTopicRequest) GetAlterPartitioningSettings() *AlterPartitioningSettings {
	if x != nil {
		return x.AlterPartitioningSettings
	}
	return nil
}

func (x *AlterTopicRequest) GetSetRetentionPeriod() *durationpb.Duration {
	if x != nil {
		return x.SetRetentionPeriod
	}
	return nil
}

func (x *AlterTopicRequest) GetSetRetentionStorageMb() int64 {
	if x != nil && x.SetRetentionStorageMb != nil {
		return *x.SetRetentionStorageMb
	}
	return 0
}

func (x *AlterTopicRequest) GetSetSupportedCodecs() *SupportedCodecs {
	if x != nil {
		return x.SetSupportedCodecs
	}
	return nil
}

func (x *AlterTopicRequest) GetSetPartitionWriteSpeedBytesPerSecond() int64 {
	if x != nil && x.SetPartitionWriteSpeedBytesPerSecond != nil {
		return *x.SetPartitionWriteSpeedBytesPerSecond
	}
	return 0
}

func (x *AlterTopicRequest) GetSetPartitionWriteBurstBytes() int64 {
	if x != nil && x.SetPartitionWriteBurstBytes != nil {
		return *x.SetPartitionWriteBurstBytes
	}
	return 0
}

func (x *AlterTopicRequest) GetAlterAttributes() map[string]string {
	if x != nil {
		return x.AlterAttributes
	}
	return nil
}

func (x *AlterTopicRequest) GetAddConsumers() []*Consumer {
	if x != nil {
		return x.AddConsumers
	}
	return nil
}

func (x *AlterTopicRequest) GetDropConsumers() []string {
	if x != nil {
		return x.DropConsumers
	}
	return nil
}

func (x *AlterTopicRequest) GetAlterConsumers() []*AlterConsumer {
	if x != nil {
		return x.AlterConsumers
	}
	return nil
}

func (x *AlterTopicRequest) GetSetMeteringMode() MeteringMode {
	if x != nil {
		return x.SetMeteringMode
	}
	return MeteringMode_METERING_MODE_UNSPECIFIED
}

// Update topic response sent from server to client.
type AlterTopicResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Result of request will be inside operation.
	Operation     *Ydb_Operations.Operation `protobuf:"bytes,1,opt,name=operation,proto3" json:"operation,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AlterTopicResponse) Reset() {
	*x = AlterTopicResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[41]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AlterTopicResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AlterTopicResponse) ProtoMessage() {}

func (x *AlterTopicResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[41]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AlterTopicResponse.ProtoReflect.Descriptor instead.
func (*AlterTopicResponse) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{41}
}

func (x *AlterTopicResponse) GetOperation() *Ydb_Operations.Operation {
	if x != nil {
		return x.Operation
	}
	return nil
}

// Update topic result message that will be inside UpdateTopicResponse.operation.
type AlterTopicResult struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AlterTopicResult) Reset() {
	*x = AlterTopicResult{}
	mi := &file_protos_ydb_topic_proto_msgTypes[42]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AlterTopicResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AlterTopicResult) ProtoMessage() {}

func (x *AlterTopicResult) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[42]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AlterTopicResult.ProtoReflect.Descriptor instead.
func (*AlterTopicResult) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{42}
}

// Drop topic request sent from client to server.
type DropTopicRequest struct {
	state           protoimpl.MessageState          `protogen:"open.v1"`
	OperationParams *Ydb_Operations.OperationParams `protobuf:"bytes,1,opt,name=operation_params,json=operationParams,proto3" json:"operation_params,omitempty"`
	// Topic path.
	Path          string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DropTopicRequest) Reset() {
	*x = DropTopicRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[43]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DropTopicRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DropTopicRequest) ProtoMessage() {}

func (x *DropTopicRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[43]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DropTopicRequest.ProtoReflect.Descriptor instead.
func (*DropTopicRequest) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{43}
}

func (x *DropTopicRequest) GetOperationParams() *Ydb_Operations.OperationParams {
	if x != nil {
		return x.OperationParams
	}
	return nil
}

func (x *DropTopicRequest) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

// Drop topic response sent from server to client.
// If topic not exists then response status will be "SCHEME_ERROR".
type DropTopicResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Result of request will be inside operation.
	Operation     *Ydb_Operations.Operation `protobuf:"bytes,1,opt,name=operation,proto3" json:"operation,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DropTopicResponse) Reset() {
	*x = DropTopicResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[44]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DropTopicResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DropTopicResponse) ProtoMessage() {}

func (x *DropTopicResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[44]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DropTopicResponse.ProtoReflect.Descriptor instead.
func (*DropTopicResponse) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{44}
}

func (x *DropTopicResponse) GetOperation() *Ydb_Operations.Operation {
	if x != nil {
		return x.Operation
	}
	return nil
}

// Drop topic result message that will be inside DropTopicResponse.operation.
type DropTopicResult struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DropTopicResult) Reset() {
	*x = DropTopicResult{}
	mi := &file_protos_ydb_topic_proto_msgTypes[45]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DropTopicResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DropTopicResult) ProtoMessage() {}

func (x *DropTopicResult) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[45]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DropTopicResult.ProtoReflect.Descriptor instead.
func (*DropTopicResult) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{45}
}

// Client-server message for write session. Contains one of:
//
//	InitRequest - handshake request.
//	WriteRequest - portion of data to be written.
//	UpdateTokenRequest - user credentials if update is needed.
type StreamWriteMessage_FromClient struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to ClientMessage:
	//
	//	*StreamWriteMessage_FromClient_InitRequest
	//	*StreamWriteMessage_FromClient_WriteRequest
	//	*StreamWriteMessage_FromClient_UpdateTokenRequest
	ClientMessage isStreamWriteMessage_FromClient_ClientMessage `protobuf_oneof:"client_message"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamWriteMessage_FromClient) Reset() {
	*x = StreamWriteMessage_FromClient{}
	mi := &file_protos_ydb_topic_proto_msgTypes[46]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamWriteMessage_FromClient) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamWriteMessage_FromClient) ProtoMessage() {}

func (x *StreamWriteMessage_FromClient) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[46]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamWriteMessage_FromClient.ProtoReflect.Descriptor instead.
func (*StreamWriteMessage_FromClient) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{6, 0}
}

func (x *StreamWriteMessage_FromClient) GetClientMessage() isStreamWriteMessage_FromClient_ClientMessage {
	if x != nil {
		return x.ClientMessage
	}
	return nil
}

func (x *StreamWriteMessage_FromClient) GetInitRequest() *StreamWriteMessage_InitRequest {
	if x != nil {
		if x, ok := x.ClientMessage.(*StreamWriteMessage_FromClient_InitRequest); ok {
			return x.InitRequest
		}
	}
	return nil
}

func (x *StreamWriteMessage_FromClient) GetWriteRequest() *StreamWriteMessage_WriteRequest {
	if x != nil {
		if x, ok := x.ClientMessage.(*StreamWriteMessage_FromClient_WriteRequest); ok {
			return x.WriteRequest
		}
	}
	return nil
}

func (x *StreamWriteMessage_FromClient) GetUpdateTokenRequest() *UpdateTokenRequest {
	if x != nil {
		if x, ok := x.ClientMessage.(*StreamWriteMessage_FromClient_UpdateTokenRequest); ok {
			return x.UpdateTokenRequest
		}
	}
	return nil
}

type isStreamWriteMessage_FromClient_ClientMessage interface {
	isStreamWriteMessage_FromClient_ClientMessage()
}

type StreamWriteMessage_FromClient_InitRequest struct {
	InitRequest *StreamWriteMessage_InitRequest `protobuf:"bytes,1,opt,name=init_request,json=initRequest,proto3,oneof"`
}

type StreamWriteMessage_FromClient_WriteRequest struct {
	WriteRequest *StreamWriteMessage_WriteRequest `protobuf:"bytes,2,opt,name=write_request,json=writeRequest,proto3,oneof"`
}

type StreamWriteMessage_FromClient_UpdateTokenRequest struct {
	UpdateTokenRequest *UpdateTokenRequest `protobuf:"bytes,3,opt,name=update_token_request,json=updateTokenRequest,proto3,oneof"`
}

func (*StreamWriteMessage_FromClient_InitRequest) isStreamWriteMessage_FromClient_ClientMessage() {}

func (*StreamWriteMessage_FromClient_WriteRequest) isStreamWriteMessage_FromClient_ClientMessage() {}

func (*StreamWriteMessage_FromClient_UpdateTokenRequest) isStreamWriteMessage_FromClient_ClientMessage() {
}

// Server-client message for write session. Contains either non-success status, or one of:
//
//	InitResponse - correct handshake response.
//	WriteResponse - acknowledgment of storing client messages.
//	UpdateTokenResponse - acknowledgment of reauthentication and reauthorization.
type StreamWriteMessage_FromServer struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Server status of response.
	Status Ydb.StatusIds_StatusCode `protobuf:"varint,1,opt,name=status,proto3,enum=Ydb.StatusIds_StatusCode" json:"status,omitempty"`
	// Issues if any.
	Issues []*Ydb_Issue.IssueMessage `protobuf:"bytes,2,rep,name=issues,proto3" json:"issues,omitempty"`
	// Types that are valid to be assigned to ServerMessage:
	//
	//	*StreamWriteMessage_FromServer_InitResponse
	//	*StreamWriteMessage_FromServer_WriteResponse
	//	*StreamWriteMessage_FromServer_UpdateTokenResponse
	ServerMessage isStreamWriteMessage_FromServer_ServerMessage `protobuf_oneof:"server_message"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamWriteMessage_FromServer) Reset() {
	*x = StreamWriteMessage_FromServer{}
	mi := &file_protos_ydb_topic_proto_msgTypes[47]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamWriteMessage_FromServer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamWriteMessage_FromServer) ProtoMessage() {}

func (x *StreamWriteMessage_FromServer) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[47]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamWriteMessage_FromServer.ProtoReflect.Descriptor instead.
func (*StreamWriteMessage_FromServer) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{6, 1}
}

func (x *StreamWriteMessage_FromServer) GetStatus() Ydb.StatusIds_StatusCode {
	if x != nil {
		return x.Status
	}
	return Ydb.StatusIds_StatusCode(0)
}

func (x *StreamWriteMessage_FromServer) GetIssues() []*Ydb_Issue.IssueMessage {
	if x != nil {
		return x.Issues
	}
	return nil
}

func (x *StreamWriteMessage_FromServer) GetServerMessage() isStreamWriteMessage_FromServer_ServerMessage {
	if x != nil {
		return x.ServerMessage
	}
	return nil
}

func (x *StreamWriteMessage_FromServer) GetInitResponse() *StreamWriteMessage_InitResponse {
	if x != nil {
		if x, ok := x.ServerMessage.(*StreamWriteMessage_FromServer_InitResponse); ok {
			return x.InitResponse
		}
	}
	return nil
}

func (x *StreamWriteMessage_FromServer) GetWriteResponse() *StreamWriteMessage_WriteResponse {
	if x != nil {
		if x, ok := x.ServerMessage.(*StreamWriteMessage_FromServer_WriteResponse); ok {
			return x.WriteResponse
		}
	}
	return nil
}

func (x *StreamWriteMessage_FromServer) GetUpdateTokenResponse() *UpdateTokenResponse {
	if x != nil {
		if x, ok := x.ServerMessage.(*StreamWriteMessage_FromServer_UpdateTokenResponse); ok {
			return x.UpdateTokenResponse
		}
	}
	return nil
}

type isStreamWriteMessage_FromServer_ServerMessage interface {
	isStreamWriteMessage_FromServer_ServerMessage()
}

type StreamWriteMessage_FromServer_InitResponse struct {
	InitResponse *StreamWriteMessage_InitResponse `protobuf:"bytes,3,opt,name=init_response,json=initResponse,proto3,oneof"`
}

type StreamWriteMessage_FromServer_WriteResponse struct {
	WriteResponse *StreamWriteMessage_WriteResponse `protobuf:"bytes,4,opt,name=write_response,json=writeResponse,proto3,oneof"`
}

type StreamWriteMessage_FromServer_UpdateTokenResponse struct {
	UpdateTokenResponse *UpdateTokenResponse `protobuf:"bytes,5,opt,name=update_token_response,json=updateTokenResponse,proto3,oneof"`
}

func (*StreamWriteMessage_FromServer_InitResponse) isStreamWriteMessage_FromServer_ServerMessage() {}

func (*StreamWriteMessage_FromServer_WriteResponse) isStreamWriteMessage_FromServer_ServerMessage() {}

func (*StreamWriteMessage_FromServer_UpdateTokenResponse) isStreamWriteMessage_FromServer_ServerMessage() {
}

// Handshake request that must be sent to server first.
type StreamWriteMessage_InitRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Full path of topic to write to.
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// Producer identifier of client data stream.
	// Used for message deduplication by sequence numbers.
	ProducerId string `protobuf:"bytes,2,opt,name=producer_id,json=producerId,proto3" json:"producer_id,omitempty"`
	// User metadata attached to this write session.
	// Reader will get this session meta data with each message read.
	WriteSessionMeta map[string]string `protobuf:"bytes,3,rep,name=write_session_meta,json=writeSessionMeta,proto3" json:"write_session_meta,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Option for setting order on messages.
	// If neither is set, no guarantees on ordering or partitions to write to.
	//
	// Types that are valid to be assigned to Partitioning:
	//
	//	*StreamWriteMessage_InitRequest_MessageGroupId
	//	*StreamWriteMessage_InitRequest_PartitionId
	//	*StreamWriteMessage_InitRequest_PartitionWithGeneration
	Partitioning isStreamWriteMessage_InitRequest_Partitioning `protobuf_oneof:"partitioning"`
	// Explicitly request for last sequential number
	// It may be expensive, if producer wrote to many partitions before.
	GetLastSeqNo  bool `protobuf:"varint,6,opt,name=get_last_seq_no,json=getLastSeqNo,proto3" json:"get_last_seq_no,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamWriteMessage_InitRequest) Reset() {
	*x = StreamWriteMessage_InitRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[48]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamWriteMessage_InitRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamWriteMessage_InitRequest) ProtoMessage() {}

func (x *StreamWriteMessage_InitRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[48]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamWriteMessage_InitRequest.ProtoReflect.Descriptor instead.
func (*StreamWriteMessage_InitRequest) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{6, 2}
}

func (x *StreamWriteMessage_InitRequest) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *StreamWriteMessage_InitRequest) GetProducerId() string {
	if x != nil {
		return x.ProducerId
	}
	return ""
}

func (x *StreamWriteMessage_InitRequest) GetWriteSessionMeta() map[string]string {
	if x != nil {
		return x.WriteSessionMeta
	}
	return nil
}

func (x *StreamWriteMessage_InitRequest) GetPartitioning() isStreamWriteMessage_InitRequest_Partitioning {
	if x != nil {
		return x.Partitioning
	}
	return nil
}

func (x *StreamWriteMessage_InitRequest) GetMessageGroupId() string {
	if x != nil {
		if x, ok := x.Partitioning.(*StreamWriteMessage_InitRequest_MessageGroupId); ok {
			return x.MessageGroupId
		}
	}
	return ""
}

func (x *StreamWriteMessage_InitRequest) GetPartitionId() int64 {
	if x != nil {
		if x, ok := x.Partitioning.(*StreamWriteMessage_InitRequest_PartitionId); ok {
			return x.PartitionId
		}
	}
	return 0
}

func (x *StreamWriteMessage_InitRequest) GetPartitionWithGeneration() *PartitionWithGeneration {
	if x != nil {
		if x, ok := x.Partitioning.(*StreamWriteMessage_InitRequest_PartitionWithGeneration); ok {
			return x.PartitionWithGeneration
		}
	}
	return nil
}

func (x *StreamWriteMessage_InitRequest) GetGetLastSeqNo() bool {
	if x != nil {
		return x.GetLastSeqNo
	}
	return false
}

type isStreamWriteMessage_InitRequest_Partitioning interface {
	isStreamWriteMessage_InitRequest_Partitioning()
}

type StreamWriteMessage_InitRequest_MessageGroupId struct {
	// All messages with given pair (producer_id, message_group_id) go to single partition in order of writes.
	MessageGroupId string `protobuf:"bytes,4,opt,name=message_group_id,json=messageGroupId,proto3,oneof"`
}

type StreamWriteMessage_InitRequest_PartitionId struct {
	// Explicit partition id to write to.
	PartitionId int64 `protobuf:"varint,5,opt,name=partition_id,json=partitionId,proto3,oneof"`
}

type StreamWriteMessage_InitRequest_PartitionWithGeneration struct {
	// Explicit partition location to write to.
	PartitionWithGeneration *PartitionWithGeneration `protobuf:"bytes,7,opt,name=partition_with_generation,json=partitionWithGeneration,proto3,oneof"`
}

func (*StreamWriteMessage_InitRequest_MessageGroupId) isStreamWriteMessage_InitRequest_Partitioning() {
}

func (*StreamWriteMessage_InitRequest_PartitionId) isStreamWriteMessage_InitRequest_Partitioning() {}

func (*StreamWriteMessage_InitRequest_PartitionWithGeneration) isStreamWriteMessage_InitRequest_Partitioning() {
}

// Response to the handshake.
type StreamWriteMessage_InitResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Last persisted message's sequence number for this producer.
	// Zero for new producer.
	LastSeqNo int64 `protobuf:"varint,1,opt,name=last_seq_no,json=lastSeqNo,proto3" json:"last_seq_no,omitempty"`
	// Unique identifier of write session. Used for debug purposes.
	SessionId string `protobuf:"bytes,2,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	// Identifier of partition that is matched for this write session.
	PartitionId int64 `protobuf:"varint,3,opt,name=partition_id,json=partitionId,proto3" json:"partition_id,omitempty"`
	// Client can only use compression codecs from this set to write messages to topic.
	// Otherwise session will be closed with BAD_REQUEST.
	SupportedCodecs *SupportedCodecs `protobuf:"bytes,4,opt,name=supported_codecs,json=supportedCodecs,proto3" json:"supported_codecs,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *StreamWriteMessage_InitResponse) Reset() {
	*x = StreamWriteMessage_InitResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[49]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamWriteMessage_InitResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamWriteMessage_InitResponse) ProtoMessage() {}

func (x *StreamWriteMessage_InitResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[49]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamWriteMessage_InitResponse.ProtoReflect.Descriptor instead.
func (*StreamWriteMessage_InitResponse) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{6, 3}
}

func (x *StreamWriteMessage_InitResponse) GetLastSeqNo() int64 {
	if x != nil {
		return x.LastSeqNo
	}
	return 0
}

func (x *StreamWriteMessage_InitResponse) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *StreamWriteMessage_InitResponse) GetPartitionId() int64 {
	if x != nil {
		return x.PartitionId
	}
	return 0
}

func (x *StreamWriteMessage_InitResponse) GetSupportedCodecs() *SupportedCodecs {
	if x != nil {
		return x.SupportedCodecs
	}
	return nil
}

// Represents portion of client messages.
type StreamWriteMessage_WriteRequest struct {
	state    protoimpl.MessageState                         `protogen:"open.v1"`
	Messages []*StreamWriteMessage_WriteRequest_MessageData `protobuf:"bytes,1,rep,name=messages,proto3" json:"messages,omitempty"`
	// Codec that is used for data compression.
	// See enum Codec above for values.
	Codec         int32                `protobuf:"varint,2,opt,name=codec,proto3" json:"codec,omitempty"`
	Tx            *TransactionIdentity `protobuf:"bytes,3,opt,name=tx,proto3,oneof" json:"tx,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamWriteMessage_WriteRequest) Reset() {
	*x = StreamWriteMessage_WriteRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[50]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamWriteMessage_WriteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamWriteMessage_WriteRequest) ProtoMessage() {}

func (x *StreamWriteMessage_WriteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[50]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamWriteMessage_WriteRequest.ProtoReflect.Descriptor instead.
func (*StreamWriteMessage_WriteRequest) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{6, 4}
}

func (x *StreamWriteMessage_WriteRequest) GetMessages() []*StreamWriteMessage_WriteRequest_MessageData {
	if x != nil {
		return x.Messages
	}
	return nil
}

func (x *StreamWriteMessage_WriteRequest) GetCodec() int32 {
	if x != nil {
		return x.Codec
	}
	return 0
}

func (x *StreamWriteMessage_WriteRequest) GetTx() *TransactionIdentity {
	if x != nil {
		return x.Tx
	}
	return nil
}

// Message that represents acknowledgment for sequence of client messages.
// This sequence is persisted together so write statistics is for messages batch.
type StreamWriteMessage_WriteResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Number of acks is equal to number of messages in the corresponding WriteRequests.
	Acks []*StreamWriteMessage_WriteResponse_WriteAck `protobuf:"bytes,1,rep,name=acks,proto3" json:"acks,omitempty"`
	// Assigned partition for all client messages inside this batch.
	// This actual partition may differ from that returned in InitResponse
	// or other WriteResponses in this write session.
	PartitionId int64 `protobuf:"varint,2,opt,name=partition_id,json=partitionId,proto3" json:"partition_id,omitempty"`
	// Write statistics for this sequence of client messages.
	WriteStatistics *StreamWriteMessage_WriteResponse_WriteStatistics `protobuf:"bytes,3,opt,name=write_statistics,json=writeStatistics,proto3" json:"write_statistics,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *StreamWriteMessage_WriteResponse) Reset() {
	*x = StreamWriteMessage_WriteResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[51]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamWriteMessage_WriteResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamWriteMessage_WriteResponse) ProtoMessage() {}

func (x *StreamWriteMessage_WriteResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[51]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamWriteMessage_WriteResponse.ProtoReflect.Descriptor instead.
func (*StreamWriteMessage_WriteResponse) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{6, 5}
}

func (x *StreamWriteMessage_WriteResponse) GetAcks() []*StreamWriteMessage_WriteResponse_WriteAck {
	if x != nil {
		return x.Acks
	}
	return nil
}

func (x *StreamWriteMessage_WriteResponse) GetPartitionId() int64 {
	if x != nil {
		return x.PartitionId
	}
	return 0
}

func (x *StreamWriteMessage_WriteResponse) GetWriteStatistics() *StreamWriteMessage_WriteResponse_WriteStatistics {
	if x != nil {
		return x.WriteStatistics
	}
	return nil
}

type StreamWriteMessage_WriteRequest_MessageData struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Message sequence number, provided by client for deduplication.
	// Starts at 1
	SeqNo int64 `protobuf:"varint,1,opt,name=seq_no,json=seqNo,proto3" json:"seq_no,omitempty"`
	// Creation timestamp
	CreatedAt *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// Compressed client message body.
	Data []byte `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	// Uncompressed size of client message body.
	UncompressedSize int64 `protobuf:"varint,4,opt,name=uncompressed_size,json=uncompressedSize,proto3" json:"uncompressed_size,omitempty"`
	// Per-message override for respective write session settings.
	//
	// Types that are valid to be assigned to Partitioning:
	//
	//	*StreamWriteMessage_WriteRequest_MessageData_MessageGroupId
	//	*StreamWriteMessage_WriteRequest_MessageData_PartitionId
	//	*StreamWriteMessage_WriteRequest_MessageData_PartitionWithGeneration
	Partitioning isStreamWriteMessage_WriteRequest_MessageData_Partitioning `protobuf_oneof:"partitioning"`
	// Message metadata. Overall size is limited to 4096 symbols (all keys and values combined).
	MetadataItems []*MetadataItem `protobuf:"bytes,7,rep,name=metadata_items,json=metadataItems,proto3" json:"metadata_items,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamWriteMessage_WriteRequest_MessageData) Reset() {
	*x = StreamWriteMessage_WriteRequest_MessageData{}
	mi := &file_protos_ydb_topic_proto_msgTypes[53]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamWriteMessage_WriteRequest_MessageData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamWriteMessage_WriteRequest_MessageData) ProtoMessage() {}

func (x *StreamWriteMessage_WriteRequest_MessageData) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[53]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamWriteMessage_WriteRequest_MessageData.ProtoReflect.Descriptor instead.
func (*StreamWriteMessage_WriteRequest_MessageData) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{6, 4, 0}
}

func (x *StreamWriteMessage_WriteRequest_MessageData) GetSeqNo() int64 {
	if x != nil {
		return x.SeqNo
	}
	return 0
}

func (x *StreamWriteMessage_WriteRequest_MessageData) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

func (x *StreamWriteMessage_WriteRequest_MessageData) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *StreamWriteMessage_WriteRequest_MessageData) GetUncompressedSize() int64 {
	if x != nil {
		return x.UncompressedSize
	}
	return 0
}

func (x *StreamWriteMessage_WriteRequest_MessageData) GetPartitioning() isStreamWriteMessage_WriteRequest_MessageData_Partitioning {
	if x != nil {
		return x.Partitioning
	}
	return nil
}

func (x *StreamWriteMessage_WriteRequest_MessageData) GetMessageGroupId() string {
	if x != nil {
		if x, ok := x.Partitioning.(*StreamWriteMessage_WriteRequest_MessageData_MessageGroupId); ok {
			return x.MessageGroupId
		}
	}
	return ""
}

func (x *StreamWriteMessage_WriteRequest_MessageData) GetPartitionId() int64 {
	if x != nil {
		if x, ok := x.Partitioning.(*StreamWriteMessage_WriteRequest_MessageData_PartitionId); ok {
			return x.PartitionId
		}
	}
	return 0
}

func (x *StreamWriteMessage_WriteRequest_MessageData) GetPartitionWithGeneration() *PartitionWithGeneration {
	if x != nil {
		if x, ok := x.Partitioning.(*StreamWriteMessage_WriteRequest_MessageData_PartitionWithGeneration); ok {
			return x.PartitionWithGeneration
		}
	}
	return nil
}

func (x *StreamWriteMessage_WriteRequest_MessageData) GetMetadataItems() []*MetadataItem {
	if x != nil {
		return x.MetadataItems
	}
	return nil
}

type isStreamWriteMessage_WriteRequest_MessageData_Partitioning interface {
	isStreamWriteMessage_WriteRequest_MessageData_Partitioning()
}

type StreamWriteMessage_WriteRequest_MessageData_MessageGroupId struct {
	// All messages with given pair (producer_id, message_group_id) go to single partition in order of writes.
	MessageGroupId string `protobuf:"bytes,5,opt,name=message_group_id,json=messageGroupId,proto3,oneof"`
}

type StreamWriteMessage_WriteRequest_MessageData_PartitionId struct {
	// Explicit partition id to write to.
	PartitionId int64 `protobuf:"varint,6,opt,name=partition_id,json=partitionId,proto3,oneof"`
}

type StreamWriteMessage_WriteRequest_MessageData_PartitionWithGeneration struct {
	// Explicit partition location to write to.
	PartitionWithGeneration *PartitionWithGeneration `protobuf:"bytes,8,opt,name=partition_with_generation,json=partitionWithGeneration,proto3,oneof"`
}

func (*StreamWriteMessage_WriteRequest_MessageData_MessageGroupId) isStreamWriteMessage_WriteRequest_MessageData_Partitioning() {
}

func (*StreamWriteMessage_WriteRequest_MessageData_PartitionId) isStreamWriteMessage_WriteRequest_MessageData_Partitioning() {
}

func (*StreamWriteMessage_WriteRequest_MessageData_PartitionWithGeneration) isStreamWriteMessage_WriteRequest_MessageData_Partitioning() {
}

// Acknowledgment for one persistently written message.
type StreamWriteMessage_WriteResponse_WriteAck struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Sequence number as in WriteRequest.
	SeqNo int64 `protobuf:"varint,1,opt,name=seq_no,json=seqNo,proto3" json:"seq_no,omitempty"`
	// Either message is written for the first time or duplicate.
	//
	// Types that are valid to be assigned to MessageWriteStatus:
	//
	//	*StreamWriteMessage_WriteResponse_WriteAck_Written_
	//	*StreamWriteMessage_WriteResponse_WriteAck_Skipped_
	//	*StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx_
	MessageWriteStatus isStreamWriteMessage_WriteResponse_WriteAck_MessageWriteStatus `protobuf_oneof:"message_write_status"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *StreamWriteMessage_WriteResponse_WriteAck) Reset() {
	*x = StreamWriteMessage_WriteResponse_WriteAck{}
	mi := &file_protos_ydb_topic_proto_msgTypes[54]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamWriteMessage_WriteResponse_WriteAck) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamWriteMessage_WriteResponse_WriteAck) ProtoMessage() {}

func (x *StreamWriteMessage_WriteResponse_WriteAck) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[54]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamWriteMessage_WriteResponse_WriteAck.ProtoReflect.Descriptor instead.
func (*StreamWriteMessage_WriteResponse_WriteAck) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{6, 5, 0}
}

func (x *StreamWriteMessage_WriteResponse_WriteAck) GetSeqNo() int64 {
	if x != nil {
		return x.SeqNo
	}
	return 0
}

func (x *StreamWriteMessage_WriteResponse_WriteAck) GetMessageWriteStatus() isStreamWriteMessage_WriteResponse_WriteAck_MessageWriteStatus {
	if x != nil {
		return x.MessageWriteStatus
	}
	return nil
}

func (x *StreamWriteMessage_WriteResponse_WriteAck) GetWritten() *StreamWriteMessage_WriteResponse_WriteAck_Written {
	if x != nil {
		if x, ok := x.MessageWriteStatus.(*StreamWriteMessage_WriteResponse_WriteAck_Written_); ok {
			return x.Written
		}
	}
	return nil
}

func (x *StreamWriteMessage_WriteResponse_WriteAck) GetSkipped() *StreamWriteMessage_WriteResponse_WriteAck_Skipped {
	if x != nil {
		if x, ok := x.MessageWriteStatus.(*StreamWriteMessage_WriteResponse_WriteAck_Skipped_); ok {
			return x.Skipped
		}
	}
	return nil
}

func (x *StreamWriteMessage_WriteResponse_WriteAck) GetWrittenInTx() *StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx {
	if x != nil {
		if x, ok := x.MessageWriteStatus.(*StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx_); ok {
			return x.WrittenInTx
		}
	}
	return nil
}

type isStreamWriteMessage_WriteResponse_WriteAck_MessageWriteStatus interface {
	isStreamWriteMessage_WriteResponse_WriteAck_MessageWriteStatus()
}

type StreamWriteMessage_WriteResponse_WriteAck_Written_ struct {
	Written *StreamWriteMessage_WriteResponse_WriteAck_Written `protobuf:"bytes,2,opt,name=written,proto3,oneof"`
}

type StreamWriteMessage_WriteResponse_WriteAck_Skipped_ struct {
	Skipped *StreamWriteMessage_WriteResponse_WriteAck_Skipped `protobuf:"bytes,3,opt,name=skipped,proto3,oneof"`
}

type StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx_ struct {
	WrittenInTx *StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx `protobuf:"bytes,4,opt,name=written_in_tx,json=writtenInTx,proto3,oneof"`
}

func (*StreamWriteMessage_WriteResponse_WriteAck_Written_) isStreamWriteMessage_WriteResponse_WriteAck_MessageWriteStatus() {
}

func (*StreamWriteMessage_WriteResponse_WriteAck_Skipped_) isStreamWriteMessage_WriteResponse_WriteAck_MessageWriteStatus() {
}

func (*StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx_) isStreamWriteMessage_WriteResponse_WriteAck_MessageWriteStatus() {
}

// Message with write statistics.
type StreamWriteMessage_WriteResponse_WriteStatistics struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Time spent in persisting of data. Same for each message in response.
	PersistingTime *durationpb.Duration `protobuf:"bytes,1,opt,name=persisting_time,json=persistingTime,proto3" json:"persisting_time,omitempty"`
	// Time spent in queue before persisting, minimal of all messages in response.
	MinQueueWaitTime *durationpb.Duration `protobuf:"bytes,2,opt,name=min_queue_wait_time,json=minQueueWaitTime,proto3" json:"min_queue_wait_time,omitempty"`
	// Time spent in queue before persisting, maximal of all messages in response.
	MaxQueueWaitTime *durationpb.Duration `protobuf:"bytes,3,opt,name=max_queue_wait_time,json=maxQueueWaitTime,proto3" json:"max_queue_wait_time,omitempty"`
	// Time spent awaiting for partition write quota. Same for each message in response.
	PartitionQuotaWaitTime *durationpb.Duration `protobuf:"bytes,4,opt,name=partition_quota_wait_time,json=partitionQuotaWaitTime,proto3" json:"partition_quota_wait_time,omitempty"`
	// Time spent awaiting for topic write quota. Same for each message in response.
	TopicQuotaWaitTime *durationpb.Duration `protobuf:"bytes,5,opt,name=topic_quota_wait_time,json=topicQuotaWaitTime,proto3" json:"topic_quota_wait_time,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *StreamWriteMessage_WriteResponse_WriteStatistics) Reset() {
	*x = StreamWriteMessage_WriteResponse_WriteStatistics{}
	mi := &file_protos_ydb_topic_proto_msgTypes[55]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamWriteMessage_WriteResponse_WriteStatistics) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamWriteMessage_WriteResponse_WriteStatistics) ProtoMessage() {}

func (x *StreamWriteMessage_WriteResponse_WriteStatistics) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[55]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamWriteMessage_WriteResponse_WriteStatistics.ProtoReflect.Descriptor instead.
func (*StreamWriteMessage_WriteResponse_WriteStatistics) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{6, 5, 1}
}

func (x *StreamWriteMessage_WriteResponse_WriteStatistics) GetPersistingTime() *durationpb.Duration {
	if x != nil {
		return x.PersistingTime
	}
	return nil
}

func (x *StreamWriteMessage_WriteResponse_WriteStatistics) GetMinQueueWaitTime() *durationpb.Duration {
	if x != nil {
		return x.MinQueueWaitTime
	}
	return nil
}

func (x *StreamWriteMessage_WriteResponse_WriteStatistics) GetMaxQueueWaitTime() *durationpb.Duration {
	if x != nil {
		return x.MaxQueueWaitTime
	}
	return nil
}

func (x *StreamWriteMessage_WriteResponse_WriteStatistics) GetPartitionQuotaWaitTime() *durationpb.Duration {
	if x != nil {
		return x.PartitionQuotaWaitTime
	}
	return nil
}

func (x *StreamWriteMessage_WriteResponse_WriteStatistics) GetTopicQuotaWaitTime() *durationpb.Duration {
	if x != nil {
		return x.TopicQuotaWaitTime
	}
	return nil
}

type StreamWriteMessage_WriteResponse_WriteAck_Written struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Assigned partition offset.
	Offset        int64 `protobuf:"varint,1,opt,name=offset,proto3" json:"offset,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamWriteMessage_WriteResponse_WriteAck_Written) Reset() {
	*x = StreamWriteMessage_WriteResponse_WriteAck_Written{}
	mi := &file_protos_ydb_topic_proto_msgTypes[56]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamWriteMessage_WriteResponse_WriteAck_Written) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamWriteMessage_WriteResponse_WriteAck_Written) ProtoMessage() {}

func (x *StreamWriteMessage_WriteResponse_WriteAck_Written) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[56]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamWriteMessage_WriteResponse_WriteAck_Written.ProtoReflect.Descriptor instead.
func (*StreamWriteMessage_WriteResponse_WriteAck_Written) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{6, 5, 0, 0}
}

func (x *StreamWriteMessage_WriteResponse_WriteAck_Written) GetOffset() int64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

type StreamWriteMessage_WriteResponse_WriteAck_Skipped struct {
	state         protoimpl.MessageState                                   `protogen:"open.v1"`
	Reason        StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason `protobuf:"varint,1,opt,name=reason,proto3,enum=Ydb.Topic.StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason" json:"reason,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamWriteMessage_WriteResponse_WriteAck_Skipped) Reset() {
	*x = StreamWriteMessage_WriteResponse_WriteAck_Skipped{}
	mi := &file_protos_ydb_topic_proto_msgTypes[57]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamWriteMessage_WriteResponse_WriteAck_Skipped) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamWriteMessage_WriteResponse_WriteAck_Skipped) ProtoMessage() {}

func (x *StreamWriteMessage_WriteResponse_WriteAck_Skipped) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[57]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamWriteMessage_WriteResponse_WriteAck_Skipped.ProtoReflect.Descriptor instead.
func (*StreamWriteMessage_WriteResponse_WriteAck_Skipped) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{6, 5, 0, 1}
}

func (x *StreamWriteMessage_WriteResponse_WriteAck_Skipped) GetReason() StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason {
	if x != nil {
		return x.Reason
	}
	return StreamWriteMessage_WriteResponse_WriteAck_Skipped_REASON_UNSPECIFIED
}

type StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx) Reset() {
	*x = StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx{}
	mi := &file_protos_ydb_topic_proto_msgTypes[58]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx) ProtoMessage() {}

func (x *StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[58]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx.ProtoReflect.Descriptor instead.
func (*StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{6, 5, 0, 2}
}

// Within a StreamRead session delivered messages are separated by partition.
// Reads from a single partition are represented by a partition session.
type StreamReadMessage_PartitionSession struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Identifier of partition session. Unique inside one RPC call.
	PartitionSessionId int64 `protobuf:"varint,1,opt,name=partition_session_id,json=partitionSessionId,proto3" json:"partition_session_id,omitempty"`
	// Topic path of partition.
	Path string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	// Partition identifier.
	PartitionId   int64 `protobuf:"varint,3,opt,name=partition_id,json=partitionId,proto3" json:"partition_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamReadMessage_PartitionSession) Reset() {
	*x = StreamReadMessage_PartitionSession{}
	mi := &file_protos_ydb_topic_proto_msgTypes[59]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_PartitionSession) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_PartitionSession) ProtoMessage() {}

func (x *StreamReadMessage_PartitionSession) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[59]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamReadMessage_PartitionSession.ProtoReflect.Descriptor instead.
func (*StreamReadMessage_PartitionSession) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{7, 0}
}

func (x *StreamReadMessage_PartitionSession) GetPartitionSessionId() int64 {
	if x != nil {
		return x.PartitionSessionId
	}
	return 0
}

func (x *StreamReadMessage_PartitionSession) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *StreamReadMessage_PartitionSession) GetPartitionId() int64 {
	if x != nil {
		return x.PartitionId
	}
	return 0
}

// Client-server message for read session. Contains one of:
//
//	InitRequest - handshake request.
//	ReadRequest - request for data.
//	CommitOffsetRequest - request for commit of some read data.
//	PartitionSessionStatusRequest - request for session status
//	UpdateTokenRequest - request to update auth token
//	DirectReadAck - client signals it has finished direct reading from the partition node.
//
//	StartPartitionSessionResponse - Response to StreamReadServerMessage.StartPartitionSessionRequest.
//	    Client signals it is ready to get data from partition.
//	StopPartitionSessionResponse - Response to StreamReadServerMessage.StopPartitionSessionRequest.
//	    Client signals it has finished working with partition. Mandatory for graceful stop, optional otherwise.
type StreamReadMessage_FromClient struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to ClientMessage:
	//
	//	*StreamReadMessage_FromClient_InitRequest
	//	*StreamReadMessage_FromClient_ReadRequest
	//	*StreamReadMessage_FromClient_CommitOffsetRequest
	//	*StreamReadMessage_FromClient_PartitionSessionStatusRequest
	//	*StreamReadMessage_FromClient_UpdateTokenRequest
	//	*StreamReadMessage_FromClient_DirectReadAck
	//	*StreamReadMessage_FromClient_StartPartitionSessionResponse
	//	*StreamReadMessage_FromClient_StopPartitionSessionResponse
	ClientMessage isStreamReadMessage_FromClient_ClientMessage `protobuf_oneof:"client_message"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamReadMessage_FromClient) Reset() {
	*x = StreamReadMessage_FromClient{}
	mi := &file_protos_ydb_topic_proto_msgTypes[60]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_FromClient) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_FromClient) ProtoMessage() {}

func (x *StreamReadMessage_FromClient) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[60]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamReadMessage_FromClient.ProtoReflect.Descriptor instead.
func (*StreamReadMessage_FromClient) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{7, 1}
}

func (x *StreamReadMessage_FromClient) GetClientMessage() isStreamReadMessage_FromClient_ClientMessage {
	if x != nil {
		return x.ClientMessage
	}
	return nil
}

func (x *StreamReadMessage_FromClient) GetInitRequest() *StreamReadMessage_InitRequest {
	if x != nil {
		if x, ok := x.ClientMessage.(*StreamReadMessage_FromClient_InitRequest); ok {
			return x.InitRequest
		}
	}
	return nil
}

func (x *StreamReadMessage_FromClient) GetReadRequest() *StreamReadMessage_ReadRequest {
	if x != nil {
		if x, ok := x.ClientMessage.(*StreamReadMessage_FromClient_ReadRequest); ok {
			return x.ReadRequest
		}
	}
	return nil
}

func (x *StreamReadMessage_FromClient) GetCommitOffsetRequest() *StreamReadMessage_CommitOffsetRequest {
	if x != nil {
		if x, ok := x.ClientMessage.(*StreamReadMessage_FromClient_CommitOffsetRequest); ok {
			return x.CommitOffsetRequest
		}
	}
	return nil
}

func (x *StreamReadMessage_FromClient) GetPartitionSessionStatusRequest() *StreamReadMessage_PartitionSessionStatusRequest {
	if x != nil {
		if x, ok := x.ClientMessage.(*StreamReadMessage_FromClient_PartitionSessionStatusRequest); ok {
			return x.PartitionSessionStatusRequest
		}
	}
	return nil
}

func (x *StreamReadMessage_FromClient) GetUpdateTokenRequest() *UpdateTokenRequest {
	if x != nil {
		if x, ok := x.ClientMessage.(*StreamReadMessage_FromClient_UpdateTokenRequest); ok {
			return x.UpdateTokenRequest
		}
	}
	return nil
}

func (x *StreamReadMessage_FromClient) GetDirectReadAck() *StreamReadMessage_DirectReadAck {
	if x != nil {
		if x, ok := x.ClientMessage.(*StreamReadMessage_FromClient_DirectReadAck); ok {
			return x.DirectReadAck
		}
	}
	return nil
}

func (x *StreamReadMessage_FromClient) GetStartPartitionSessionResponse() *StreamReadMessage_StartPartitionSessionResponse {
	if x != nil {
		if x, ok := x.ClientMessage.(*StreamReadMessage_FromClient_StartPartitionSessionResponse); ok {
			return x.StartPartitionSessionResponse
		}
	}
	return nil
}

func (x *StreamReadMessage_FromClient) GetStopPartitionSessionResponse() *StreamReadMessage_StopPartitionSessionResponse {
	if x != nil {
		if x, ok := x.ClientMessage.(*StreamReadMessage_FromClient_StopPartitionSessionResponse); ok {
			return x.StopPartitionSessionResponse
		}
	}
	return nil
}

type isStreamReadMessage_FromClient_ClientMessage interface {
	isStreamReadMessage_FromClient_ClientMessage()
}

type StreamReadMessage_FromClient_InitRequest struct {
	// Client requests.
	InitRequest *StreamReadMessage_InitRequest `protobuf:"bytes,1,opt,name=init_request,json=initRequest,proto3,oneof"`
}

type StreamReadMessage_FromClient_ReadRequest struct {
	ReadRequest *StreamReadMessage_ReadRequest `protobuf:"bytes,2,opt,name=read_request,json=readRequest,proto3,oneof"`
}

type StreamReadMessage_FromClient_CommitOffsetRequest struct {
	CommitOffsetRequest *StreamReadMessage_CommitOffsetRequest `protobuf:"bytes,3,opt,name=commit_offset_request,json=commitOffsetRequest,proto3,oneof"`
}

type StreamReadMessage_FromClient_PartitionSessionStatusRequest struct {
	PartitionSessionStatusRequest *StreamReadMessage_PartitionSessionStatusRequest `protobuf:"bytes,4,opt,name=partition_session_status_request,json=partitionSessionStatusRequest,proto3,oneof"`
}

type StreamReadMessage_FromClient_UpdateTokenRequest struct {
	UpdateTokenRequest *UpdateTokenRequest `protobuf:"bytes,5,opt,name=update_token_request,json=updateTokenRequest,proto3,oneof"`
}

type StreamReadMessage_FromClient_DirectReadAck struct {
	DirectReadAck *StreamReadMessage_DirectReadAck `protobuf:"bytes,8,opt,name=direct_read_ack,json=directReadAck,proto3,oneof"`
}

type StreamReadMessage_FromClient_StartPartitionSessionResponse struct {
	// Responses to respective server commands.
	StartPartitionSessionResponse *StreamReadMessage_StartPartitionSessionResponse `protobuf:"bytes,6,opt,name=start_partition_session_response,json=startPartitionSessionResponse,proto3,oneof"`
}

type StreamReadMessage_FromClient_StopPartitionSessionResponse struct {
	StopPartitionSessionResponse *StreamReadMessage_StopPartitionSessionResponse `protobuf:"bytes,7,opt,name=stop_partition_session_response,json=stopPartitionSessionResponse,proto3,oneof"`
}

func (*StreamReadMessage_FromClient_InitRequest) isStreamReadMessage_FromClient_ClientMessage() {}

func (*StreamReadMessage_FromClient_ReadRequest) isStreamReadMessage_FromClient_ClientMessage() {}

func (*StreamReadMessage_FromClient_CommitOffsetRequest) isStreamReadMessage_FromClient_ClientMessage() {
}

func (*StreamReadMessage_FromClient_PartitionSessionStatusRequest) isStreamReadMessage_FromClient_ClientMessage() {
}

func (*StreamReadMessage_FromClient_UpdateTokenRequest) isStreamReadMessage_FromClient_ClientMessage() {
}

func (*StreamReadMessage_FromClient_DirectReadAck) isStreamReadMessage_FromClient_ClientMessage() {}

func (*StreamReadMessage_FromClient_StartPartitionSessionResponse) isStreamReadMessage_FromClient_ClientMessage() {
}

func (*StreamReadMessage_FromClient_StopPartitionSessionResponse) isStreamReadMessage_FromClient_ClientMessage() {
}

// Server-client message for read session. Contains one of:
//
//	InitResponse - handshake response from server.
//	ReadResponse - portion of data.
//	CommitOffsetResponse - acknowledgment for commit.
//	PartitionSessionStatusResponse - server response with partition session status.
//	UpdateTokenResponse - acknowledgment of token update.
//
//	StartPartitionSessionRequest - command from server to create a partition session.
//	StopPartitionSessionRequest - command from server to destroy a partition session.
//	UpdatePartitionSession - command from server to update a partition session.
type StreamReadMessage_FromServer struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Server status of response.
	Status Ydb.StatusIds_StatusCode `protobuf:"varint,1,opt,name=status,proto3,enum=Ydb.StatusIds_StatusCode" json:"status,omitempty"`
	// Issues if any.
	Issues []*Ydb_Issue.IssueMessage `protobuf:"bytes,2,rep,name=issues,proto3" json:"issues,omitempty"`
	// Types that are valid to be assigned to ServerMessage:
	//
	//	*StreamReadMessage_FromServer_InitResponse
	//	*StreamReadMessage_FromServer_ReadResponse
	//	*StreamReadMessage_FromServer_CommitOffsetResponse
	//	*StreamReadMessage_FromServer_PartitionSessionStatusResponse
	//	*StreamReadMessage_FromServer_UpdateTokenResponse
	//	*StreamReadMessage_FromServer_StartPartitionSessionRequest
	//	*StreamReadMessage_FromServer_StopPartitionSessionRequest
	//	*StreamReadMessage_FromServer_UpdatePartitionSession
	//	*StreamReadMessage_FromServer_EndPartitionSession
	ServerMessage isStreamReadMessage_FromServer_ServerMessage `protobuf_oneof:"server_message"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamReadMessage_FromServer) Reset() {
	*x = StreamReadMessage_FromServer{}
	mi := &file_protos_ydb_topic_proto_msgTypes[61]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_FromServer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_FromServer) ProtoMessage() {}

func (x *StreamReadMessage_FromServer) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[61]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamReadMessage_FromServer.ProtoReflect.Descriptor instead.
func (*StreamReadMessage_FromServer) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{7, 2}
}

func (x *StreamReadMessage_FromServer) GetStatus() Ydb.StatusIds_StatusCode {
	if x != nil {
		return x.Status
	}
	return Ydb.StatusIds_StatusCode(0)
}

func (x *StreamReadMessage_FromServer) GetIssues() []*Ydb_Issue.IssueMessage {
	if x != nil {
		return x.Issues
	}
	return nil
}

func (x *StreamReadMessage_FromServer) GetServerMessage() isStreamReadMessage_FromServer_ServerMessage {
	if x != nil {
		return x.ServerMessage
	}
	return nil
}

func (x *StreamReadMessage_FromServer) GetInitResponse() *StreamReadMessage_InitResponse {
	if x != nil {
		if x, ok := x.ServerMessage.(*StreamReadMessage_FromServer_InitResponse); ok {
			return x.InitResponse
		}
	}
	return nil
}

func (x *StreamReadMessage_FromServer) GetReadResponse() *StreamReadMessage_ReadResponse {
	if x != nil {
		if x, ok := x.ServerMessage.(*StreamReadMessage_FromServer_ReadResponse); ok {
			return x.ReadResponse
		}
	}
	return nil
}

func (x *StreamReadMessage_FromServer) GetCommitOffsetResponse() *StreamReadMessage_CommitOffsetResponse {
	if x != nil {
		if x, ok := x.ServerMessage.(*StreamReadMessage_FromServer_CommitOffsetResponse); ok {
			return x.CommitOffsetResponse
		}
	}
	return nil
}

func (x *StreamReadMessage_FromServer) GetPartitionSessionStatusResponse() *StreamReadMessage_PartitionSessionStatusResponse {
	if x != nil {
		if x, ok := x.ServerMessage.(*StreamReadMessage_FromServer_PartitionSessionStatusResponse); ok {
			return x.PartitionSessionStatusResponse
		}
	}
	return nil
}

func (x *StreamReadMessage_FromServer) GetUpdateTokenResponse() *UpdateTokenResponse {
	if x != nil {
		if x, ok := x.ServerMessage.(*StreamReadMessage_FromServer_UpdateTokenResponse); ok {
			return x.UpdateTokenResponse
		}
	}
	return nil
}

func (x *StreamReadMessage_FromServer) GetStartPartitionSessionRequest() *StreamReadMessage_StartPartitionSessionRequest {
	if x != nil {
		if x, ok := x.ServerMessage.(*StreamReadMessage_FromServer_StartPartitionSessionRequest); ok {
			return x.StartPartitionSessionRequest
		}
	}
	return nil
}

func (x *StreamReadMessage_FromServer) GetStopPartitionSessionRequest() *StreamReadMessage_StopPartitionSessionRequest {
	if x != nil {
		if x, ok := x.ServerMessage.(*StreamReadMessage_FromServer_StopPartitionSessionRequest); ok {
			return x.StopPartitionSessionRequest
		}
	}
	return nil
}

func (x *StreamReadMessage_FromServer) GetUpdatePartitionSession() *StreamReadMessage_UpdatePartitionSession {
	if x != nil {
		if x, ok := x.ServerMessage.(*StreamReadMessage_FromServer_UpdatePartitionSession); ok {
			return x.UpdatePartitionSession
		}
	}
	return nil
}

func (x *StreamReadMessage_FromServer) GetEndPartitionSession() *StreamReadMessage_EndPartitionSession {
	if x != nil {
		if x, ok := x.ServerMessage.(*StreamReadMessage_FromServer_EndPartitionSession); ok {
			return x.EndPartitionSession
		}
	}
	return nil
}

type isStreamReadMessage_FromServer_ServerMessage interface {
	isStreamReadMessage_FromServer_ServerMessage()
}

type StreamReadMessage_FromServer_InitResponse struct {
	// Responses to respective client requests.
	InitResponse *StreamReadMessage_InitResponse `protobuf:"bytes,3,opt,name=init_response,json=initResponse,proto3,oneof"`
}

type StreamReadMessage_FromServer_ReadResponse struct {
	ReadResponse *StreamReadMessage_ReadResponse `protobuf:"bytes,4,opt,name=read_response,json=readResponse,proto3,oneof"`
}

type StreamReadMessage_FromServer_CommitOffsetResponse struct {
	CommitOffsetResponse *StreamReadMessage_CommitOffsetResponse `protobuf:"bytes,5,opt,name=commit_offset_response,json=commitOffsetResponse,proto3,oneof"`
}

type StreamReadMessage_FromServer_PartitionSessionStatusResponse struct {
	PartitionSessionStatusResponse *StreamReadMessage_PartitionSessionStatusResponse `protobuf:"bytes,6,opt,name=partition_session_status_response,json=partitionSessionStatusResponse,proto3,oneof"`
}

type StreamReadMessage_FromServer_UpdateTokenResponse struct {
	UpdateTokenResponse *UpdateTokenResponse `protobuf:"bytes,7,opt,name=update_token_response,json=updateTokenResponse,proto3,oneof"`
}

type StreamReadMessage_FromServer_StartPartitionSessionRequest struct {
	// Server commands.
	StartPartitionSessionRequest *StreamReadMessage_StartPartitionSessionRequest `protobuf:"bytes,8,opt,name=start_partition_session_request,json=startPartitionSessionRequest,proto3,oneof"`
}

type StreamReadMessage_FromServer_StopPartitionSessionRequest struct {
	StopPartitionSessionRequest *StreamReadMessage_StopPartitionSessionRequest `protobuf:"bytes,9,opt,name=stop_partition_session_request,json=stopPartitionSessionRequest,proto3,oneof"`
}

type StreamReadMessage_FromServer_UpdatePartitionSession struct {
	UpdatePartitionSession *StreamReadMessage_UpdatePartitionSession `protobuf:"bytes,10,opt,name=update_partition_session,json=updatePartitionSession,proto3,oneof"`
}

type StreamReadMessage_FromServer_EndPartitionSession struct {
	EndPartitionSession *StreamReadMessage_EndPartitionSession `protobuf:"bytes,11,opt,name=end_partition_session,json=endPartitionSession,proto3,oneof"`
}

func (*StreamReadMessage_FromServer_InitResponse) isStreamReadMessage_FromServer_ServerMessage() {}

func (*StreamReadMessage_FromServer_ReadResponse) isStreamReadMessage_FromServer_ServerMessage() {}

func (*StreamReadMessage_FromServer_CommitOffsetResponse) isStreamReadMessage_FromServer_ServerMessage() {
}

func (*StreamReadMessage_FromServer_PartitionSessionStatusResponse) isStreamReadMessage_FromServer_ServerMessage() {
}

func (*StreamReadMessage_FromServer_UpdateTokenResponse) isStreamReadMessage_FromServer_ServerMessage() {
}

func (*StreamReadMessage_FromServer_StartPartitionSessionRequest) isStreamReadMessage_FromServer_ServerMessage() {
}

func (*StreamReadMessage_FromServer_StopPartitionSessionRequest) isStreamReadMessage_FromServer_ServerMessage() {
}

func (*StreamReadMessage_FromServer_UpdatePartitionSession) isStreamReadMessage_FromServer_ServerMessage() {
}

func (*StreamReadMessage_FromServer_EndPartitionSession) isStreamReadMessage_FromServer_ServerMessage() {
}

// Handshake request.
type StreamReadMessage_InitRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Message that describes topic to read.
	// Topics that will be read by this session.
	TopicsReadSettings []*StreamReadMessage_InitRequest_TopicReadSettings `protobuf:"bytes,1,rep,name=topics_read_settings,json=topicsReadSettings,proto3" json:"topics_read_settings,omitempty"`
	// Path of consumer that is used for reading by this session.
	Consumer string `protobuf:"bytes,2,opt,name=consumer,proto3" json:"consumer,omitempty"`
	// Optional name. Will be shown in debug stat.
	ReaderName string `protobuf:"bytes,3,opt,name=reader_name,json=readerName,proto3" json:"reader_name,omitempty"`
	// Direct reading from a partition node.
	DirectRead bool `protobuf:"varint,4,opt,name=direct_read,json=directRead,proto3" json:"direct_read,omitempty"`
	// Indicates that the SDK supports auto partitioning.
	AutoPartitioningSupport bool `protobuf:"varint,5,opt,name=auto_partitioning_support,json=autoPartitioningSupport,proto3" json:"auto_partitioning_support,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *StreamReadMessage_InitRequest) Reset() {
	*x = StreamReadMessage_InitRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[62]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_InitRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_InitRequest) ProtoMessage() {}

func (x *StreamReadMessage_InitRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[62]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamReadMessage_InitRequest.ProtoReflect.Descriptor instead.
func (*StreamReadMessage_InitRequest) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{7, 3}
}

func (x *StreamReadMessage_InitRequest) GetTopicsReadSettings() []*StreamReadMessage_InitRequest_TopicReadSettings {
	if x != nil {
		return x.TopicsReadSettings
	}
	return nil
}

func (x *StreamReadMessage_InitRequest) GetConsumer() string {
	if x != nil {
		return x.Consumer
	}
	return ""
}

func (x *StreamReadMessage_InitRequest) GetReaderName() string {
	if x != nil {
		return x.ReaderName
	}
	return ""
}

func (x *StreamReadMessage_InitRequest) GetDirectRead() bool {
	if x != nil {
		return x.DirectRead
	}
	return false
}

func (x *StreamReadMessage_InitRequest) GetAutoPartitioningSupport() bool {
	if x != nil {
		return x.AutoPartitioningSupport
	}
	return false
}

// Handshake response.
type StreamReadMessage_InitResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Read session identifier.
	SessionId     string `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamReadMessage_InitResponse) Reset() {
	*x = StreamReadMessage_InitResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[63]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_InitResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_InitResponse) ProtoMessage() {}

func (x *StreamReadMessage_InitResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[63]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamReadMessage_InitResponse.ProtoReflect.Descriptor instead.
func (*StreamReadMessage_InitResponse) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{7, 4}
}

func (x *StreamReadMessage_InitResponse) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

// Message that represents client readiness for receiving more data.
type StreamReadMessage_ReadRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Server and client each keep track of total bytes size of all ReadResponses.
	// When client is ready to receive N more bytes in responses (to increment possible total by N),
	// it sends a ReadRequest with bytes_size = N.
	// bytes_size value must be positive.
	// So in expression 'A = (sum of bytes_size in all ReadRequests) - (sum of bytes_size in all ReadResponses)'
	//
	//	server will keep A (available size for responses) non-negative.
	//
	// But there is an exception. If server receives ReadRequest, and the first message in response exceeds A -
	// then it will still be delivered, and A will become negative until enough additional ReadRequests.
	//
	// Example:
	//  1. Let client have 200 bytes buffer. It sends ReadRequest with bytes_size = 200;
	//  2. Server may return one ReadResponse with bytes_size = 70 and than another 80 bytes response;
	//     now client buffer has 50 free bytes, server is free to send up to 50 bytes in responses.
	//  3. Client processes 100 bytes from buffer, now buffer free space is 150 bytes,
	//     so client sends ReadRequest with bytes_size = 100;
	//  4. Server is free to send up to 50 + 100 = 150 bytes. But the next read message is too big,
	//     and it sends 160 bytes ReadResponse.
	//  5. Let's assume client somehow processes it, and its 200 bytes buffer is free again.
	//     It should account for excess 10 bytes and send ReadRequest with bytes_size = 210.
	BytesSize     int64 `protobuf:"varint,1,opt,name=bytes_size,json=bytesSize,proto3" json:"bytes_size,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamReadMessage_ReadRequest) Reset() {
	*x = StreamReadMessage_ReadRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[64]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_ReadRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_ReadRequest) ProtoMessage() {}

func (x *StreamReadMessage_ReadRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[64]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamReadMessage_ReadRequest.ProtoReflect.Descriptor instead.
func (*StreamReadMessage_ReadRequest) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{7, 5}
}

func (x *StreamReadMessage_ReadRequest) GetBytesSize() int64 {
	if x != nil {
		return x.BytesSize
	}
	return 0
}

// Data read.
type StreamReadMessage_ReadResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Client messages, divided by partitions.
	PartitionData []*StreamReadMessage_ReadResponse_PartitionData `protobuf:"bytes,1,rep,name=partition_data,json=partitionData,proto3" json:"partition_data,omitempty"`
	// Total size in bytes of this response as calculated by server.
	// See ReadRequest comment above.
	BytesSize     int64 `protobuf:"varint,2,opt,name=bytes_size,json=bytesSize,proto3" json:"bytes_size,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamReadMessage_ReadResponse) Reset() {
	*x = StreamReadMessage_ReadResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[65]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_ReadResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_ReadResponse) ProtoMessage() {}

func (x *StreamReadMessage_ReadResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[65]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamReadMessage_ReadResponse.ProtoReflect.Descriptor instead.
func (*StreamReadMessage_ReadResponse) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{7, 6}
}

func (x *StreamReadMessage_ReadResponse) GetPartitionData() []*StreamReadMessage_ReadResponse_PartitionData {
	if x != nil {
		return x.PartitionData
	}
	return nil
}

func (x *StreamReadMessage_ReadResponse) GetBytesSize() int64 {
	if x != nil {
		return x.BytesSize
	}
	return 0
}

// Signal for server that client processed some read data.
type StreamReadMessage_CommitOffsetRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Partition offsets that indicates processed data.
	CommitOffsets []*StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset `protobuf:"bytes,1,rep,name=commit_offsets,json=commitOffsets,proto3" json:"commit_offsets,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamReadMessage_CommitOffsetRequest) Reset() {
	*x = StreamReadMessage_CommitOffsetRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[66]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_CommitOffsetRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_CommitOffsetRequest) ProtoMessage() {}

func (x *StreamReadMessage_CommitOffsetRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[66]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamReadMessage_CommitOffsetRequest.ProtoReflect.Descriptor instead.
func (*StreamReadMessage_CommitOffsetRequest) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{7, 7}
}

func (x *StreamReadMessage_CommitOffsetRequest) GetCommitOffsets() []*StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset {
	if x != nil {
		return x.CommitOffsets
	}
	return nil
}

// Acknowledgement for commits.
type StreamReadMessage_CommitOffsetResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Partitions with progress.
	PartitionsCommittedOffsets []*StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset `protobuf:"bytes,1,rep,name=partitions_committed_offsets,json=partitionsCommittedOffsets,proto3" json:"partitions_committed_offsets,omitempty"`
	unknownFields              protoimpl.UnknownFields
	sizeCache                  protoimpl.SizeCache
}

func (x *StreamReadMessage_CommitOffsetResponse) Reset() {
	*x = StreamReadMessage_CommitOffsetResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[67]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_CommitOffsetResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_CommitOffsetResponse) ProtoMessage() {}

func (x *StreamReadMessage_CommitOffsetResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[67]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamReadMessage_CommitOffsetResponse.ProtoReflect.Descriptor instead.
func (*StreamReadMessage_CommitOffsetResponse) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{7, 8}
}

func (x *StreamReadMessage_CommitOffsetResponse) GetPartitionsCommittedOffsets() []*StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset {
	if x != nil {
		return x.PartitionsCommittedOffsets
	}
	return nil
}

type StreamReadMessage_PartitionSessionStatusRequest struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	PartitionSessionId int64                  `protobuf:"varint,1,opt,name=partition_session_id,json=partitionSessionId,proto3" json:"partition_session_id,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *StreamReadMessage_PartitionSessionStatusRequest) Reset() {
	*x = StreamReadMessage_PartitionSessionStatusRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[68]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_PartitionSessionStatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_PartitionSessionStatusRequest) ProtoMessage() {}

func (x *StreamReadMessage_PartitionSessionStatusRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[68]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamReadMessage_PartitionSessionStatusRequest.ProtoReflect.Descriptor instead.
func (*StreamReadMessage_PartitionSessionStatusRequest) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{7, 9}
}

func (x *StreamReadMessage_PartitionSessionStatusRequest) GetPartitionSessionId() int64 {
	if x != nil {
		return x.PartitionSessionId
	}
	return 0
}

// Response to status request.
type StreamReadMessage_PartitionSessionStatusResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Identifier of partition session whose status was requested.
	PartitionSessionId int64 `protobuf:"varint,1,opt,name=partition_session_id,json=partitionSessionId,proto3" json:"partition_session_id,omitempty"`
	// Partition contains messages with offsets in range [start, end).
	PartitionOffsets *OffsetsRange `protobuf:"bytes,2,opt,name=partition_offsets,json=partitionOffsets,proto3" json:"partition_offsets,omitempty"`
	// Each offset up to and including (committed_offset - 1) was fully processed.
	CommittedOffset int64 `protobuf:"varint,3,opt,name=committed_offset,json=committedOffset,proto3" json:"committed_offset,omitempty"`
	// Write timestamp of next message written to this partition will be no less than write_time_high_watermark.
	WriteTimeHighWatermark *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=write_time_high_watermark,json=writeTimeHighWatermark,proto3" json:"write_time_high_watermark,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *StreamReadMessage_PartitionSessionStatusResponse) Reset() {
	*x = StreamReadMessage_PartitionSessionStatusResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[69]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_PartitionSessionStatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_PartitionSessionStatusResponse) ProtoMessage() {}

func (x *StreamReadMessage_PartitionSessionStatusResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[69]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamReadMessage_PartitionSessionStatusResponse.ProtoReflect.Descriptor instead.
func (*StreamReadMessage_PartitionSessionStatusResponse) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{7, 10}
}

func (x *StreamReadMessage_PartitionSessionStatusResponse) GetPartitionSessionId() int64 {
	if x != nil {
		return x.PartitionSessionId
	}
	return 0
}

func (x *StreamReadMessage_PartitionSessionStatusResponse) GetPartitionOffsets() *OffsetsRange {
	if x != nil {
		return x.PartitionOffsets
	}
	return nil
}

func (x *StreamReadMessage_PartitionSessionStatusResponse) GetCommittedOffset() int64 {
	if x != nil {
		return x.CommittedOffset
	}
	return 0
}

func (x *StreamReadMessage_PartitionSessionStatusResponse) GetWriteTimeHighWatermark() *timestamppb.Timestamp {
	if x != nil {
		return x.WriteTimeHighWatermark
	}
	return nil
}

// Command from server to create and start a partition session.
// Client must respond with StartPartitionSessionResponse when ready to receive data from this partition.
type StreamReadMessage_StartPartitionSessionRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Partition session description.
	PartitionSession *StreamReadMessage_PartitionSession `protobuf:"bytes,1,opt,name=partition_session,json=partitionSession,proto3" json:"partition_session,omitempty"`
	// Each offset up to and including (committed_offset - 1) was fully processed.
	CommittedOffset int64 `protobuf:"varint,2,opt,name=committed_offset,json=committedOffset,proto3" json:"committed_offset,omitempty"`
	// Partition contains messages with offsets in range [start, end).
	PartitionOffsets *OffsetsRange `protobuf:"bytes,3,opt,name=partition_offsets,json=partitionOffsets,proto3" json:"partition_offsets,omitempty"`
	// Partition location, filled only when InitRequest.direct_read is true.
	PartitionLocation *PartitionLocation `protobuf:"bytes,4,opt,name=partition_location,json=partitionLocation,proto3" json:"partition_location,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *StreamReadMessage_StartPartitionSessionRequest) Reset() {
	*x = StreamReadMessage_StartPartitionSessionRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[70]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_StartPartitionSessionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_StartPartitionSessionRequest) ProtoMessage() {}

func (x *StreamReadMessage_StartPartitionSessionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[70]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamReadMessage_StartPartitionSessionRequest.ProtoReflect.Descriptor instead.
func (*StreamReadMessage_StartPartitionSessionRequest) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{7, 11}
}

func (x *StreamReadMessage_StartPartitionSessionRequest) GetPartitionSession() *StreamReadMessage_PartitionSession {
	if x != nil {
		return x.PartitionSession
	}
	return nil
}

func (x *StreamReadMessage_StartPartitionSessionRequest) GetCommittedOffset() int64 {
	if x != nil {
		return x.CommittedOffset
	}
	return 0
}

func (x *StreamReadMessage_StartPartitionSessionRequest) GetPartitionOffsets() *OffsetsRange {
	if x != nil {
		return x.PartitionOffsets
	}
	return nil
}

func (x *StreamReadMessage_StartPartitionSessionRequest) GetPartitionLocation() *PartitionLocation {
	if x != nil {
		return x.PartitionLocation
	}
	return nil
}

// Signal for server that client is ready to recive data for partition.
type StreamReadMessage_StartPartitionSessionResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Partition session identifier of partition to start read.
	PartitionSessionId int64 `protobuf:"varint,1,opt,name=partition_session_id,json=partitionSessionId,proto3" json:"partition_session_id,omitempty"`
	// Reads in this partition session will start from offset no less than read_offset.
	// If read_offset is set, server will check that read_offset is no less that actual committed offset.
	// If check fails then server will send an error message (status != SUCCESS) and close stream.
	//
	// If read_offset is not set, no check will be made.
	// InitRequest.max_lag and InitRequest.read_from could lead to skip of more messages.
	// Server will return data starting from offset that is maximum of actual committed offset, read_offset (if set)
	// and offsets calculated from InitRequest.max_lag and InitRequest.read_from.
	ReadOffset *int64 `protobuf:"varint,2,opt,name=read_offset,json=readOffset,proto3,oneof" json:"read_offset,omitempty"`
	// All messages with offset less than commit_offset are processed by client.
	// Server will commit this position if this is not done yet.
	CommitOffset  *int64 `protobuf:"varint,3,opt,name=commit_offset,json=commitOffset,proto3,oneof" json:"commit_offset,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamReadMessage_StartPartitionSessionResponse) Reset() {
	*x = StreamReadMessage_StartPartitionSessionResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[71]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_StartPartitionSessionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_StartPartitionSessionResponse) ProtoMessage() {}

func (x *StreamReadMessage_StartPartitionSessionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[71]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamReadMessage_StartPartitionSessionResponse.ProtoReflect.Descriptor instead.
func (*StreamReadMessage_StartPartitionSessionResponse) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{7, 12}
}

func (x *StreamReadMessage_StartPartitionSessionResponse) GetPartitionSessionId() int64 {
	if x != nil {
		return x.PartitionSessionId
	}
	return 0
}

func (x *StreamReadMessage_StartPartitionSessionResponse) GetReadOffset() int64 {
	if x != nil && x.ReadOffset != nil {
		return *x.ReadOffset
	}
	return 0
}

func (x *StreamReadMessage_StartPartitionSessionResponse) GetCommitOffset() int64 {
	if x != nil && x.CommitOffset != nil {
		return *x.CommitOffset
	}
	return 0
}

// Command from server to stop and destroy concrete partition session.
type StreamReadMessage_StopPartitionSessionRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Identifier of partition session that is ready to be closed by server.
	PartitionSessionId int64 `protobuf:"varint,1,opt,name=partition_session_id,json=partitionSessionId,proto3" json:"partition_session_id,omitempty"`
	// Flag of graceful stop.
	// If set, server will wait for response from client before giving this partition to other read session.
	// Server will not send more data from this partition.
	// Client can process all received data and wait for commit and only after send response.
	// If False then server gives partition for other session right now.
	// All further commits for this partition session has no effect. Server is not waiting for response.
	Graceful bool `protobuf:"varint,2,opt,name=graceful,proto3" json:"graceful,omitempty"`
	// Upper bound for committed offsets.
	CommittedOffset int64 `protobuf:"varint,3,opt,name=committed_offset,json=committedOffset,proto3" json:"committed_offset,omitempty"`
	// Upper bound for read request identifiers, filled only when InitRequest.direct_read is true and graceful is true.
	LastDirectReadId int64 `protobuf:"varint,4,opt,name=last_direct_read_id,json=lastDirectReadId,proto3" json:"last_direct_read_id,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *StreamReadMessage_StopPartitionSessionRequest) Reset() {
	*x = StreamReadMessage_StopPartitionSessionRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[72]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_StopPartitionSessionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_StopPartitionSessionRequest) ProtoMessage() {}

func (x *StreamReadMessage_StopPartitionSessionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[72]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamReadMessage_StopPartitionSessionRequest.ProtoReflect.Descriptor instead.
func (*StreamReadMessage_StopPartitionSessionRequest) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{7, 13}
}

func (x *StreamReadMessage_StopPartitionSessionRequest) GetPartitionSessionId() int64 {
	if x != nil {
		return x.PartitionSessionId
	}
	return 0
}

func (x *StreamReadMessage_StopPartitionSessionRequest) GetGraceful() bool {
	if x != nil {
		return x.Graceful
	}
	return false
}

func (x *StreamReadMessage_StopPartitionSessionRequest) GetCommittedOffset() int64 {
	if x != nil {
		return x.CommittedOffset
	}
	return 0
}

func (x *StreamReadMessage_StopPartitionSessionRequest) GetLastDirectReadId() int64 {
	if x != nil {
		return x.LastDirectReadId
	}
	return 0
}

// Signal for server that client finished working with this partition.
// Must be sent only after corresponding StopPartitionSessionRequest from server.
// Server will give this partition to other read session only after StopPartitionSessionResponse signal.
type StreamReadMessage_StopPartitionSessionResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Partition session identifier of partition session that is released by client.
	PartitionSessionId int64 `protobuf:"varint,1,opt,name=partition_session_id,json=partitionSessionId,proto3" json:"partition_session_id,omitempty"`
	// Flag of graceful stop, used only when InitRequest.direct_read is true
	// Client must pass this value unchanged from the StopPartitionSessionRequest.
	// Server can sent two StopPartitionSessionRequests, the first with graceful=true, the second with graceful=false. The client must answer both of them.
	Graceful      bool `protobuf:"varint,2,opt,name=graceful,proto3" json:"graceful,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamReadMessage_StopPartitionSessionResponse) Reset() {
	*x = StreamReadMessage_StopPartitionSessionResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[73]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_StopPartitionSessionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_StopPartitionSessionResponse) ProtoMessage() {}

func (x *StreamReadMessage_StopPartitionSessionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[73]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamReadMessage_StopPartitionSessionResponse.ProtoReflect.Descriptor instead.
func (*StreamReadMessage_StopPartitionSessionResponse) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{7, 14}
}

func (x *StreamReadMessage_StopPartitionSessionResponse) GetPartitionSessionId() int64 {
	if x != nil {
		return x.PartitionSessionId
	}
	return 0
}

func (x *StreamReadMessage_StopPartitionSessionResponse) GetGraceful() bool {
	if x != nil {
		return x.Graceful
	}
	return false
}

// Command from server to notify about a partition session update.
// Client should not send a response to the command.
type StreamReadMessage_UpdatePartitionSession struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Partition session identifier.
	PartitionSessionId int64 `protobuf:"varint,1,opt,name=partition_session_id,json=partitionSessionId,proto3" json:"partition_session_id,omitempty"`
	// Partition location, filled only when InitRequest.direct_read is true.
	PartitionLocation *PartitionLocation `protobuf:"bytes,2,opt,name=partition_location,json=partitionLocation,proto3" json:"partition_location,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *StreamReadMessage_UpdatePartitionSession) Reset() {
	*x = StreamReadMessage_UpdatePartitionSession{}
	mi := &file_protos_ydb_topic_proto_msgTypes[74]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_UpdatePartitionSession) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_UpdatePartitionSession) ProtoMessage() {}

func (x *StreamReadMessage_UpdatePartitionSession) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[74]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamReadMessage_UpdatePartitionSession.ProtoReflect.Descriptor instead.
func (*StreamReadMessage_UpdatePartitionSession) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{7, 15}
}

func (x *StreamReadMessage_UpdatePartitionSession) GetPartitionSessionId() int64 {
	if x != nil {
		return x.PartitionSessionId
	}
	return 0
}

func (x *StreamReadMessage_UpdatePartitionSession) GetPartitionLocation() *PartitionLocation {
	if x != nil {
		return x.PartitionLocation
	}
	return nil
}

// Signal for server that client has finished direct reading.
// Server should not send a response to the command.
type StreamReadMessage_DirectReadAck struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Partition session identifier.
	PartitionSessionId int64 `protobuf:"varint,1,opt,name=partition_session_id,json=partitionSessionId,proto3" json:"partition_session_id,omitempty"`
	// Identifier of the successfully completed read request.
	DirectReadId  int64 `protobuf:"varint,2,opt,name=direct_read_id,json=directReadId,proto3" json:"direct_read_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamReadMessage_DirectReadAck) Reset() {
	*x = StreamReadMessage_DirectReadAck{}
	mi := &file_protos_ydb_topic_proto_msgTypes[75]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_DirectReadAck) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_DirectReadAck) ProtoMessage() {}

func (x *StreamReadMessage_DirectReadAck) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[75]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamReadMessage_DirectReadAck.ProtoReflect.Descriptor instead.
func (*StreamReadMessage_DirectReadAck) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{7, 16}
}

func (x *StreamReadMessage_DirectReadAck) GetPartitionSessionId() int64 {
	if x != nil {
		return x.PartitionSessionId
	}
	return 0
}

func (x *StreamReadMessage_DirectReadAck) GetDirectReadId() int64 {
	if x != nil {
		return x.DirectReadId
	}
	return 0
}

// Signal from server that client has finished reading the partition and all messages have been read.
// Once a partition has been finished no further messages will ever arrive to that partition.
// This command is a hint to the client to commit offsets, after which the child partitions will be balanced independently in different reading sessions.
// Unlike StopPartitionSessionRequest, the client does not have to close the reading session.
// Client should not send a response to the command.
type StreamReadMessage_EndPartitionSession struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Partition session identifier.
	PartitionSessionId int64 `protobuf:"varint,1,opt,name=partition_session_id,json=partitionSessionId,proto3" json:"partition_session_id,omitempty"`
	// Ids of partitions which were merged with the ended partition.
	AdjacentPartitionIds []int64 `protobuf:"varint,2,rep,packed,name=adjacent_partition_ids,json=adjacentPartitionIds,proto3" json:"adjacent_partition_ids,omitempty"`
	// Ids of partitions which was formed when the ended partition was split or merged.
	ChildPartitionIds []int64 `protobuf:"varint,3,rep,packed,name=child_partition_ids,json=childPartitionIds,proto3" json:"child_partition_ids,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *StreamReadMessage_EndPartitionSession) Reset() {
	*x = StreamReadMessage_EndPartitionSession{}
	mi := &file_protos_ydb_topic_proto_msgTypes[76]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_EndPartitionSession) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_EndPartitionSession) ProtoMessage() {}

func (x *StreamReadMessage_EndPartitionSession) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[76]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamReadMessage_EndPartitionSession.ProtoReflect.Descriptor instead.
func (*StreamReadMessage_EndPartitionSession) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{7, 17}
}

func (x *StreamReadMessage_EndPartitionSession) GetPartitionSessionId() int64 {
	if x != nil {
		return x.PartitionSessionId
	}
	return 0
}

func (x *StreamReadMessage_EndPartitionSession) GetAdjacentPartitionIds() []int64 {
	if x != nil {
		return x.AdjacentPartitionIds
	}
	return nil
}

func (x *StreamReadMessage_EndPartitionSession) GetChildPartitionIds() []int64 {
	if x != nil {
		return x.ChildPartitionIds
	}
	return nil
}

type StreamReadMessage_InitRequest_TopicReadSettings struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Topic path.
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// Partitions that will be read by this session.
	// If list is empty - then session will read all partitions.
	PartitionIds []int64 `protobuf:"varint,2,rep,packed,name=partition_ids,json=partitionIds,proto3" json:"partition_ids,omitempty"`
	// Skip all messages that has write timestamp smaller than now - max_lag.
	// Zero means infinite lag.
	MaxLag *durationpb.Duration `protobuf:"bytes,3,opt,name=max_lag,json=maxLag,proto3" json:"max_lag,omitempty"`
	// Read data only after this timestamp from this topic.
	// Read only messages with 'written_at' value greater or equal than this timestamp.
	ReadFrom      *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=read_from,json=readFrom,proto3" json:"read_from,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamReadMessage_InitRequest_TopicReadSettings) Reset() {
	*x = StreamReadMessage_InitRequest_TopicReadSettings{}
	mi := &file_protos_ydb_topic_proto_msgTypes[77]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_InitRequest_TopicReadSettings) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_InitRequest_TopicReadSettings) ProtoMessage() {}

func (x *StreamReadMessage_InitRequest_TopicReadSettings) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[77]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamReadMessage_InitRequest_TopicReadSettings.ProtoReflect.Descriptor instead.
func (*StreamReadMessage_InitRequest_TopicReadSettings) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{7, 3, 0}
}

func (x *StreamReadMessage_InitRequest_TopicReadSettings) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *StreamReadMessage_InitRequest_TopicReadSettings) GetPartitionIds() []int64 {
	if x != nil {
		return x.PartitionIds
	}
	return nil
}

func (x *StreamReadMessage_InitRequest_TopicReadSettings) GetMaxLag() *durationpb.Duration {
	if x != nil {
		return x.MaxLag
	}
	return nil
}

func (x *StreamReadMessage_InitRequest_TopicReadSettings) GetReadFrom() *timestamppb.Timestamp {
	if x != nil {
		return x.ReadFrom
	}
	return nil
}

// One client message representation.
type StreamReadMessage_ReadResponse_MessageData struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Partition offset in partition that assigned for message.
	Offset int64 `protobuf:"varint,1,opt,name=offset,proto3" json:"offset,omitempty"` //unique value for client side deduplication - Topic:Partition:Offset
	// Sequence number that provided with message on write from client.
	SeqNo int64 `protobuf:"varint,2,opt,name=seq_no,json=seqNo,proto3" json:"seq_no,omitempty"`
	// Timestamp of creation of message provided on write from client.
	CreatedAt *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// Compressed client message body.
	Data []byte `protobuf:"bytes,5,opt,name=data,proto3" json:"data,omitempty"`
	// Uncompressed size of client message body.
	// sent as is from WriteRequest, without check on server side. May be empty (for writes from old client) or wrong (if bug in writer).
	// Use it for optimization purposes only, don't trust it.
	UncompressedSize int64 `protobuf:"varint,6,opt,name=uncompressed_size,json=uncompressedSize,proto3" json:"uncompressed_size,omitempty"`
	// Filled if message_group_id was set on message write.
	MessageGroupId string          `protobuf:"bytes,7,opt,name=message_group_id,json=messageGroupId,proto3" json:"message_group_id,omitempty"`
	MetadataItems  []*MetadataItem `protobuf:"bytes,8,rep,name=metadata_items,json=metadataItems,proto3" json:"metadata_items,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *StreamReadMessage_ReadResponse_MessageData) Reset() {
	*x = StreamReadMessage_ReadResponse_MessageData{}
	mi := &file_protos_ydb_topic_proto_msgTypes[78]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_ReadResponse_MessageData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_ReadResponse_MessageData) ProtoMessage() {}

func (x *StreamReadMessage_ReadResponse_MessageData) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[78]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamReadMessage_ReadResponse_MessageData.ProtoReflect.Descriptor instead.
func (*StreamReadMessage_ReadResponse_MessageData) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{7, 6, 0}
}

func (x *StreamReadMessage_ReadResponse_MessageData) GetOffset() int64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

func (x *StreamReadMessage_ReadResponse_MessageData) GetSeqNo() int64 {
	if x != nil {
		return x.SeqNo
	}
	return 0
}

func (x *StreamReadMessage_ReadResponse_MessageData) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

func (x *StreamReadMessage_ReadResponse_MessageData) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *StreamReadMessage_ReadResponse_MessageData) GetUncompressedSize() int64 {
	if x != nil {
		return x.UncompressedSize
	}
	return 0
}

func (x *StreamReadMessage_ReadResponse_MessageData) GetMessageGroupId() string {
	if x != nil {
		return x.MessageGroupId
	}
	return ""
}

func (x *StreamReadMessage_ReadResponse_MessageData) GetMetadataItems() []*MetadataItem {
	if x != nil {
		return x.MetadataItems
	}
	return nil
}

// Representation of sequence of client messages from one write session.
type StreamReadMessage_ReadResponse_Batch struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of client messages.
	MessageData []*StreamReadMessage_ReadResponse_MessageData `protobuf:"bytes,1,rep,name=message_data,json=messageData,proto3" json:"message_data,omitempty"`
	// Producer identifier provided by client for this batch of client messages.
	ProducerId string `protobuf:"bytes,2,opt,name=producer_id,json=producerId,proto3" json:"producer_id,omitempty"`
	// Client metadata attached to write session, the same for all messages in batch.
	WriteSessionMeta map[string]string `protobuf:"bytes,3,rep,name=write_session_meta,json=writeSessionMeta,proto3" json:"write_session_meta,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Codec that is used for data compression.
	// See enum Codec above for values.
	Codec int32 `protobuf:"varint,4,opt,name=codec,proto3" json:"codec,omitempty"`
	// Persist timestamp on server for batch.
	WrittenAt     *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=written_at,json=writtenAt,proto3" json:"written_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamReadMessage_ReadResponse_Batch) Reset() {
	*x = StreamReadMessage_ReadResponse_Batch{}
	mi := &file_protos_ydb_topic_proto_msgTypes[79]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_ReadResponse_Batch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_ReadResponse_Batch) ProtoMessage() {}

func (x *StreamReadMessage_ReadResponse_Batch) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[79]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamReadMessage_ReadResponse_Batch.ProtoReflect.Descriptor instead.
func (*StreamReadMessage_ReadResponse_Batch) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{7, 6, 1}
}

func (x *StreamReadMessage_ReadResponse_Batch) GetMessageData() []*StreamReadMessage_ReadResponse_MessageData {
	if x != nil {
		return x.MessageData
	}
	return nil
}

func (x *StreamReadMessage_ReadResponse_Batch) GetProducerId() string {
	if x != nil {
		return x.ProducerId
	}
	return ""
}

func (x *StreamReadMessage_ReadResponse_Batch) GetWriteSessionMeta() map[string]string {
	if x != nil {
		return x.WriteSessionMeta
	}
	return nil
}

func (x *StreamReadMessage_ReadResponse_Batch) GetCodec() int32 {
	if x != nil {
		return x.Codec
	}
	return 0
}

func (x *StreamReadMessage_ReadResponse_Batch) GetWrittenAt() *timestamppb.Timestamp {
	if x != nil {
		return x.WrittenAt
	}
	return nil
}

// Representation of sequence of messages from one partition.
type StreamReadMessage_ReadResponse_PartitionData struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	PartitionSessionId int64                  `protobuf:"varint,1,opt,name=partition_session_id,json=partitionSessionId,proto3" json:"partition_session_id,omitempty"`
	// Client messages, divided by write sessions.
	Batches       []*StreamReadMessage_ReadResponse_Batch `protobuf:"bytes,2,rep,name=batches,proto3" json:"batches,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamReadMessage_ReadResponse_PartitionData) Reset() {
	*x = StreamReadMessage_ReadResponse_PartitionData{}
	mi := &file_protos_ydb_topic_proto_msgTypes[80]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_ReadResponse_PartitionData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_ReadResponse_PartitionData) ProtoMessage() {}

func (x *StreamReadMessage_ReadResponse_PartitionData) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[80]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamReadMessage_ReadResponse_PartitionData.ProtoReflect.Descriptor instead.
func (*StreamReadMessage_ReadResponse_PartitionData) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{7, 6, 2}
}

func (x *StreamReadMessage_ReadResponse_PartitionData) GetPartitionSessionId() int64 {
	if x != nil {
		return x.PartitionSessionId
	}
	return 0
}

func (x *StreamReadMessage_ReadResponse_PartitionData) GetBatches() []*StreamReadMessage_ReadResponse_Batch {
	if x != nil {
		return x.Batches
	}
	return nil
}

// Message that is used for describing commit.
type StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Identifier of partition session with data to commit.
	PartitionSessionId int64 `protobuf:"varint,1,opt,name=partition_session_id,json=partitionSessionId,proto3" json:"partition_session_id,omitempty"`
	// Processed offsets ranges, repeated in case of disjoint ranges.
	Offsets       []*OffsetsRange `protobuf:"bytes,2,rep,name=offsets,proto3" json:"offsets,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset) Reset() {
	*x = StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset{}
	mi := &file_protos_ydb_topic_proto_msgTypes[82]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset) ProtoMessage() {}

func (x *StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[82]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset.ProtoReflect.Descriptor instead.
func (*StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{7, 7, 0}
}

func (x *StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset) GetPartitionSessionId() int64 {
	if x != nil {
		return x.PartitionSessionId
	}
	return 0
}

func (x *StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset) GetOffsets() []*OffsetsRange {
	if x != nil {
		return x.Offsets
	}
	return nil
}

// Per-partition commit representation.
type StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Partition session identifier.
	PartitionSessionId int64 `protobuf:"varint,1,opt,name=partition_session_id,json=partitionSessionId,proto3" json:"partition_session_id,omitempty"`
	// Upper bound for committed offsets.
	CommittedOffset int64 `protobuf:"varint,2,opt,name=committed_offset,json=committedOffset,proto3" json:"committed_offset,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset) Reset() {
	*x = StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset{}
	mi := &file_protos_ydb_topic_proto_msgTypes[83]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset) ProtoMessage() {}

func (x *StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[83]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset.ProtoReflect.Descriptor instead.
func (*StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{7, 8, 0}
}

func (x *StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset) GetPartitionSessionId() int64 {
	if x != nil {
		return x.PartitionSessionId
	}
	return 0
}

func (x *StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset) GetCommittedOffset() int64 {
	if x != nil {
		return x.CommittedOffset
	}
	return 0
}

// Client-server message for direct read session.
//
//	InitRequest - command from client to create and start a direct read session.
//	StartDirectReadPartitionSessionRequest - command from client to create and start a direct read partition session.
//	    Client signals it is ready to get data from partition.
//	UpdateTokenRequest - request to update auth token
type StreamDirectReadMessage_FromClient struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to ClientMessage:
	//
	//	*StreamDirectReadMessage_FromClient_InitRequest
	//	*StreamDirectReadMessage_FromClient_StartDirectReadPartitionSessionRequest
	//	*StreamDirectReadMessage_FromClient_UpdateTokenRequest
	ClientMessage isStreamDirectReadMessage_FromClient_ClientMessage `protobuf_oneof:"client_message"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamDirectReadMessage_FromClient) Reset() {
	*x = StreamDirectReadMessage_FromClient{}
	mi := &file_protos_ydb_topic_proto_msgTypes[84]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamDirectReadMessage_FromClient) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamDirectReadMessage_FromClient) ProtoMessage() {}

func (x *StreamDirectReadMessage_FromClient) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[84]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamDirectReadMessage_FromClient.ProtoReflect.Descriptor instead.
func (*StreamDirectReadMessage_FromClient) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{8, 0}
}

func (x *StreamDirectReadMessage_FromClient) GetClientMessage() isStreamDirectReadMessage_FromClient_ClientMessage {
	if x != nil {
		return x.ClientMessage
	}
	return nil
}

func (x *StreamDirectReadMessage_FromClient) GetInitRequest() *StreamDirectReadMessage_InitRequest {
	if x != nil {
		if x, ok := x.ClientMessage.(*StreamDirectReadMessage_FromClient_InitRequest); ok {
			return x.InitRequest
		}
	}
	return nil
}

func (x *StreamDirectReadMessage_FromClient) GetStartDirectReadPartitionSessionRequest() *StreamDirectReadMessage_StartDirectReadPartitionSessionRequest {
	if x != nil {
		if x, ok := x.ClientMessage.(*StreamDirectReadMessage_FromClient_StartDirectReadPartitionSessionRequest); ok {
			return x.StartDirectReadPartitionSessionRequest
		}
	}
	return nil
}

func (x *StreamDirectReadMessage_FromClient) GetUpdateTokenRequest() *UpdateTokenRequest {
	if x != nil {
		if x, ok := x.ClientMessage.(*StreamDirectReadMessage_FromClient_UpdateTokenRequest); ok {
			return x.UpdateTokenRequest
		}
	}
	return nil
}

type isStreamDirectReadMessage_FromClient_ClientMessage interface {
	isStreamDirectReadMessage_FromClient_ClientMessage()
}

type StreamDirectReadMessage_FromClient_InitRequest struct {
	InitRequest *StreamDirectReadMessage_InitRequest `protobuf:"bytes,1,opt,name=init_request,json=initRequest,proto3,oneof"`
}

type StreamDirectReadMessage_FromClient_StartDirectReadPartitionSessionRequest struct {
	StartDirectReadPartitionSessionRequest *StreamDirectReadMessage_StartDirectReadPartitionSessionRequest `protobuf:"bytes,2,opt,name=start_direct_read_partition_session_request,json=startDirectReadPartitionSessionRequest,proto3,oneof"`
}

type StreamDirectReadMessage_FromClient_UpdateTokenRequest struct {
	UpdateTokenRequest *UpdateTokenRequest `protobuf:"bytes,3,opt,name=update_token_request,json=updateTokenRequest,proto3,oneof"`
}

func (*StreamDirectReadMessage_FromClient_InitRequest) isStreamDirectReadMessage_FromClient_ClientMessage() {
}

func (*StreamDirectReadMessage_FromClient_StartDirectReadPartitionSessionRequest) isStreamDirectReadMessage_FromClient_ClientMessage() {
}

func (*StreamDirectReadMessage_FromClient_UpdateTokenRequest) isStreamDirectReadMessage_FromClient_ClientMessage() {
}

// Server-client message for direct read session.
//
//	InitResponse - correct handshake response.
//	StartDirectReadPartitionSessionResponse - Response to StartDirectReadPartitionSessionRequest.
//	DirectReadResponse - portion of message data.
//	StopDirectReadPartitionSession - command from server to stop a direct read partition session.
//	UpdateTokenResponse - acknowledgment of token update.
type StreamDirectReadMessage_FromServer struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Server status of response.
	Status Ydb.StatusIds_StatusCode `protobuf:"varint,1,opt,name=status,proto3,enum=Ydb.StatusIds_StatusCode" json:"status,omitempty"`
	// Issues if any.
	Issues []*Ydb_Issue.IssueMessage `protobuf:"bytes,2,rep,name=issues,proto3" json:"issues,omitempty"`
	// Types that are valid to be assigned to ServerMessage:
	//
	//	*StreamDirectReadMessage_FromServer_InitResponse
	//	*StreamDirectReadMessage_FromServer_StartDirectReadPartitionSessionResponse
	//	*StreamDirectReadMessage_FromServer_StopDirectReadPartitionSession
	//	*StreamDirectReadMessage_FromServer_DirectReadResponse
	//	*StreamDirectReadMessage_FromServer_UpdateTokenResponse
	ServerMessage isStreamDirectReadMessage_FromServer_ServerMessage `protobuf_oneof:"server_message"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamDirectReadMessage_FromServer) Reset() {
	*x = StreamDirectReadMessage_FromServer{}
	mi := &file_protos_ydb_topic_proto_msgTypes[85]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamDirectReadMessage_FromServer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamDirectReadMessage_FromServer) ProtoMessage() {}

func (x *StreamDirectReadMessage_FromServer) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[85]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamDirectReadMessage_FromServer.ProtoReflect.Descriptor instead.
func (*StreamDirectReadMessage_FromServer) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{8, 1}
}

func (x *StreamDirectReadMessage_FromServer) GetStatus() Ydb.StatusIds_StatusCode {
	if x != nil {
		return x.Status
	}
	return Ydb.StatusIds_StatusCode(0)
}

func (x *StreamDirectReadMessage_FromServer) GetIssues() []*Ydb_Issue.IssueMessage {
	if x != nil {
		return x.Issues
	}
	return nil
}

func (x *StreamDirectReadMessage_FromServer) GetServerMessage() isStreamDirectReadMessage_FromServer_ServerMessage {
	if x != nil {
		return x.ServerMessage
	}
	return nil
}

func (x *StreamDirectReadMessage_FromServer) GetInitResponse() *StreamDirectReadMessage_InitResponse {
	if x != nil {
		if x, ok := x.ServerMessage.(*StreamDirectReadMessage_FromServer_InitResponse); ok {
			return x.InitResponse
		}
	}
	return nil
}

func (x *StreamDirectReadMessage_FromServer) GetStartDirectReadPartitionSessionResponse() *StreamDirectReadMessage_StartDirectReadPartitionSessionResponse {
	if x != nil {
		if x, ok := x.ServerMessage.(*StreamDirectReadMessage_FromServer_StartDirectReadPartitionSessionResponse); ok {
			return x.StartDirectReadPartitionSessionResponse
		}
	}
	return nil
}

func (x *StreamDirectReadMessage_FromServer) GetStopDirectReadPartitionSession() *StreamDirectReadMessage_StopDirectReadPartitionSession {
	if x != nil {
		if x, ok := x.ServerMessage.(*StreamDirectReadMessage_FromServer_StopDirectReadPartitionSession); ok {
			return x.StopDirectReadPartitionSession
		}
	}
	return nil
}

func (x *StreamDirectReadMessage_FromServer) GetDirectReadResponse() *StreamDirectReadMessage_DirectReadResponse {
	if x != nil {
		if x, ok := x.ServerMessage.(*StreamDirectReadMessage_FromServer_DirectReadResponse); ok {
			return x.DirectReadResponse
		}
	}
	return nil
}

func (x *StreamDirectReadMessage_FromServer) GetUpdateTokenResponse() *UpdateTokenResponse {
	if x != nil {
		if x, ok := x.ServerMessage.(*StreamDirectReadMessage_FromServer_UpdateTokenResponse); ok {
			return x.UpdateTokenResponse
		}
	}
	return nil
}

type isStreamDirectReadMessage_FromServer_ServerMessage interface {
	isStreamDirectReadMessage_FromServer_ServerMessage()
}

type StreamDirectReadMessage_FromServer_InitResponse struct {
	InitResponse *StreamDirectReadMessage_InitResponse `protobuf:"bytes,6,opt,name=init_response,json=initResponse,proto3,oneof"`
}

type StreamDirectReadMessage_FromServer_StartDirectReadPartitionSessionResponse struct {
	StartDirectReadPartitionSessionResponse *StreamDirectReadMessage_StartDirectReadPartitionSessionResponse `protobuf:"bytes,7,opt,name=start_direct_read_partition_session_response,json=startDirectReadPartitionSessionResponse,proto3,oneof"`
}

type StreamDirectReadMessage_FromServer_StopDirectReadPartitionSession struct {
	StopDirectReadPartitionSession *StreamDirectReadMessage_StopDirectReadPartitionSession `protobuf:"bytes,3,opt,name=stop_direct_read_partition_session,json=stopDirectReadPartitionSession,proto3,oneof"`
}

type StreamDirectReadMessage_FromServer_DirectReadResponse struct {
	DirectReadResponse *StreamDirectReadMessage_DirectReadResponse `protobuf:"bytes,4,opt,name=direct_read_response,json=directReadResponse,proto3,oneof"`
}

type StreamDirectReadMessage_FromServer_UpdateTokenResponse struct {
	UpdateTokenResponse *UpdateTokenResponse `protobuf:"bytes,5,opt,name=update_token_response,json=updateTokenResponse,proto3,oneof"`
}

func (*StreamDirectReadMessage_FromServer_InitResponse) isStreamDirectReadMessage_FromServer_ServerMessage() {
}

func (*StreamDirectReadMessage_FromServer_StartDirectReadPartitionSessionResponse) isStreamDirectReadMessage_FromServer_ServerMessage() {
}

func (*StreamDirectReadMessage_FromServer_StopDirectReadPartitionSession) isStreamDirectReadMessage_FromServer_ServerMessage() {
}

func (*StreamDirectReadMessage_FromServer_DirectReadResponse) isStreamDirectReadMessage_FromServer_ServerMessage() {
}

func (*StreamDirectReadMessage_FromServer_UpdateTokenResponse) isStreamDirectReadMessage_FromServer_ServerMessage() {
}

// Command from client to create and start a direct read session.
// Server should not send a response to the command.
type StreamDirectReadMessage_InitRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Read session identifier.
	SessionId string `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	// Topics that will be read by this session.
	TopicsReadSettings []*StreamDirectReadMessage_InitRequest_TopicReadSettings `protobuf:"bytes,2,rep,name=topics_read_settings,json=topicsReadSettings,proto3" json:"topics_read_settings,omitempty"`
	// Path of consumer that is used for reading by this session.
	Consumer      string `protobuf:"bytes,3,opt,name=consumer,proto3" json:"consumer,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamDirectReadMessage_InitRequest) Reset() {
	*x = StreamDirectReadMessage_InitRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[86]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamDirectReadMessage_InitRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamDirectReadMessage_InitRequest) ProtoMessage() {}

func (x *StreamDirectReadMessage_InitRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[86]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamDirectReadMessage_InitRequest.ProtoReflect.Descriptor instead.
func (*StreamDirectReadMessage_InitRequest) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{8, 2}
}

func (x *StreamDirectReadMessage_InitRequest) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *StreamDirectReadMessage_InitRequest) GetTopicsReadSettings() []*StreamDirectReadMessage_InitRequest_TopicReadSettings {
	if x != nil {
		return x.TopicsReadSettings
	}
	return nil
}

func (x *StreamDirectReadMessage_InitRequest) GetConsumer() string {
	if x != nil {
		return x.Consumer
	}
	return ""
}

// Response to the handshake.
type StreamDirectReadMessage_InitResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamDirectReadMessage_InitResponse) Reset() {
	*x = StreamDirectReadMessage_InitResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[87]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamDirectReadMessage_InitResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamDirectReadMessage_InitResponse) ProtoMessage() {}

func (x *StreamDirectReadMessage_InitResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[87]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamDirectReadMessage_InitResponse.ProtoReflect.Descriptor instead.
func (*StreamDirectReadMessage_InitResponse) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{8, 3}
}

// Command from client to create and start a direct read partition session.
type StreamDirectReadMessage_StartDirectReadPartitionSessionRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Partition session identifier.
	PartitionSessionId int64 `protobuf:"varint,1,opt,name=partition_session_id,json=partitionSessionId,proto3" json:"partition_session_id,omitempty"`
	// Upper bound for read request identifiers.
	LastDirectReadId int64 `protobuf:"varint,2,opt,name=last_direct_read_id,json=lastDirectReadId,proto3" json:"last_direct_read_id,omitempty"`
	// Partition generation.
	Generation    int64 `protobuf:"varint,3,opt,name=generation,proto3" json:"generation,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionRequest) Reset() {
	*x = StreamDirectReadMessage_StartDirectReadPartitionSessionRequest{}
	mi := &file_protos_ydb_topic_proto_msgTypes[88]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamDirectReadMessage_StartDirectReadPartitionSessionRequest) ProtoMessage() {}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[88]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamDirectReadMessage_StartDirectReadPartitionSessionRequest.ProtoReflect.Descriptor instead.
func (*StreamDirectReadMessage_StartDirectReadPartitionSessionRequest) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{8, 4}
}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionRequest) GetPartitionSessionId() int64 {
	if x != nil {
		return x.PartitionSessionId
	}
	return 0
}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionRequest) GetLastDirectReadId() int64 {
	if x != nil {
		return x.LastDirectReadId
	}
	return 0
}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionRequest) GetGeneration() int64 {
	if x != nil {
		return x.Generation
	}
	return 0
}

// Signal for server that client is ready to receive data for partition.
type StreamDirectReadMessage_StartDirectReadPartitionSessionResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Partition session identifier of partition to start read.
	PartitionSessionId int64 `protobuf:"varint,1,opt,name=partition_session_id,json=partitionSessionId,proto3" json:"partition_session_id,omitempty"`
	// Partition generation.
	Generation    int64 `protobuf:"varint,2,opt,name=generation,proto3" json:"generation,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionResponse) Reset() {
	*x = StreamDirectReadMessage_StartDirectReadPartitionSessionResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[89]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamDirectReadMessage_StartDirectReadPartitionSessionResponse) ProtoMessage() {}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[89]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamDirectReadMessage_StartDirectReadPartitionSessionResponse.ProtoReflect.Descriptor instead.
func (*StreamDirectReadMessage_StartDirectReadPartitionSessionResponse) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{8, 5}
}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionResponse) GetPartitionSessionId() int64 {
	if x != nil {
		return x.PartitionSessionId
	}
	return 0
}

func (x *StreamDirectReadMessage_StartDirectReadPartitionSessionResponse) GetGeneration() int64 {
	if x != nil {
		return x.Generation
	}
	return 0
}

// Command from server to stop a direct read partition session.
// Client should not send a response to the command.
type StreamDirectReadMessage_StopDirectReadPartitionSession struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The reason for the stop.
	Status Ydb.StatusIds_StatusCode `protobuf:"varint,1,opt,name=status,proto3,enum=Ydb.StatusIds_StatusCode" json:"status,omitempty"`
	// Issues if any.
	Issues []*Ydb_Issue.IssueMessage `protobuf:"bytes,2,rep,name=issues,proto3" json:"issues,omitempty"`
	// Partition session identifier.
	PartitionSessionId int64 `protobuf:"varint,3,opt,name=partition_session_id,json=partitionSessionId,proto3" json:"partition_session_id,omitempty"`
	// Partition generation.
	Generation    int64 `protobuf:"varint,4,opt,name=generation,proto3" json:"generation,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamDirectReadMessage_StopDirectReadPartitionSession) Reset() {
	*x = StreamDirectReadMessage_StopDirectReadPartitionSession{}
	mi := &file_protos_ydb_topic_proto_msgTypes[90]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamDirectReadMessage_StopDirectReadPartitionSession) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamDirectReadMessage_StopDirectReadPartitionSession) ProtoMessage() {}

func (x *StreamDirectReadMessage_StopDirectReadPartitionSession) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[90]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamDirectReadMessage_StopDirectReadPartitionSession.ProtoReflect.Descriptor instead.
func (*StreamDirectReadMessage_StopDirectReadPartitionSession) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{8, 6}
}

func (x *StreamDirectReadMessage_StopDirectReadPartitionSession) GetStatus() Ydb.StatusIds_StatusCode {
	if x != nil {
		return x.Status
	}
	return Ydb.StatusIds_StatusCode(0)
}

func (x *StreamDirectReadMessage_StopDirectReadPartitionSession) GetIssues() []*Ydb_Issue.IssueMessage {
	if x != nil {
		return x.Issues
	}
	return nil
}

func (x *StreamDirectReadMessage_StopDirectReadPartitionSession) GetPartitionSessionId() int64 {
	if x != nil {
		return x.PartitionSessionId
	}
	return 0
}

func (x *StreamDirectReadMessage_StopDirectReadPartitionSession) GetGeneration() int64 {
	if x != nil {
		return x.Generation
	}
	return 0
}

// Messages that have been read directly from the partition node.
// It's a response to StreamRead.ReadRequest
type StreamDirectReadMessage_DirectReadResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Partition session identifier.
	PartitionSessionId int64 `protobuf:"varint,1,opt,name=partition_session_id,json=partitionSessionId,proto3" json:"partition_session_id,omitempty"`
	// Read request identifier.
	DirectReadId int64 `protobuf:"varint,2,opt,name=direct_read_id,json=directReadId,proto3" json:"direct_read_id,omitempty"`
	// Messages data
	PartitionData *StreamReadMessage_ReadResponse_PartitionData `protobuf:"bytes,3,opt,name=partition_data,json=partitionData,proto3" json:"partition_data,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamDirectReadMessage_DirectReadResponse) Reset() {
	*x = StreamDirectReadMessage_DirectReadResponse{}
	mi := &file_protos_ydb_topic_proto_msgTypes[91]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamDirectReadMessage_DirectReadResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamDirectReadMessage_DirectReadResponse) ProtoMessage() {}

func (x *StreamDirectReadMessage_DirectReadResponse) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[91]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamDirectReadMessage_DirectReadResponse.ProtoReflect.Descriptor instead.
func (*StreamDirectReadMessage_DirectReadResponse) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{8, 7}
}

func (x *StreamDirectReadMessage_DirectReadResponse) GetPartitionSessionId() int64 {
	if x != nil {
		return x.PartitionSessionId
	}
	return 0
}

func (x *StreamDirectReadMessage_DirectReadResponse) GetDirectReadId() int64 {
	if x != nil {
		return x.DirectReadId
	}
	return 0
}

func (x *StreamDirectReadMessage_DirectReadResponse) GetPartitionData() *StreamReadMessage_ReadResponse_PartitionData {
	if x != nil {
		return x.PartitionData
	}
	return nil
}

type StreamDirectReadMessage_InitRequest_TopicReadSettings struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Topic path.
	Path          string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamDirectReadMessage_InitRequest_TopicReadSettings) Reset() {
	*x = StreamDirectReadMessage_InitRequest_TopicReadSettings{}
	mi := &file_protos_ydb_topic_proto_msgTypes[92]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamDirectReadMessage_InitRequest_TopicReadSettings) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamDirectReadMessage_InitRequest_TopicReadSettings) ProtoMessage() {}

func (x *StreamDirectReadMessage_InitRequest_TopicReadSettings) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[92]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamDirectReadMessage_InitRequest_TopicReadSettings.ProtoReflect.Descriptor instead.
func (*StreamDirectReadMessage_InitRequest_TopicReadSettings) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{8, 2, 0}
}

func (x *StreamDirectReadMessage_InitRequest_TopicReadSettings) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

type UpdateOffsetsInTransactionRequest_TopicOffsets struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Topic path.
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// Ranges of offsets by partitions.
	Partitions    []*UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets `protobuf:"bytes,2,rep,name=partitions,proto3" json:"partitions,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateOffsetsInTransactionRequest_TopicOffsets) Reset() {
	*x = UpdateOffsetsInTransactionRequest_TopicOffsets{}
	mi := &file_protos_ydb_topic_proto_msgTypes[93]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateOffsetsInTransactionRequest_TopicOffsets) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateOffsetsInTransactionRequest_TopicOffsets) ProtoMessage() {}

func (x *UpdateOffsetsInTransactionRequest_TopicOffsets) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[93]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateOffsetsInTransactionRequest_TopicOffsets.ProtoReflect.Descriptor instead.
func (*UpdateOffsetsInTransactionRequest_TopicOffsets) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{10, 0}
}

func (x *UpdateOffsetsInTransactionRequest_TopicOffsets) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *UpdateOffsetsInTransactionRequest_TopicOffsets) GetPartitions() []*UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets {
	if x != nil {
		return x.Partitions
	}
	return nil
}

type UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Partition identifier.
	PartitionId int64 `protobuf:"varint,1,opt,name=partition_id,json=partitionId,proto3" json:"partition_id,omitempty"`
	// List of offset ranges.
	PartitionOffsets []*OffsetsRange `protobuf:"bytes,2,rep,name=partition_offsets,json=partitionOffsets,proto3" json:"partition_offsets,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets) Reset() {
	*x = UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets{}
	mi := &file_protos_ydb_topic_proto_msgTypes[94]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets) ProtoMessage() {}

func (x *UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[94]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets.ProtoReflect.Descriptor instead.
func (*UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{10, 0, 0}
}

func (x *UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets) GetPartitionId() int64 {
	if x != nil {
		return x.PartitionId
	}
	return 0
}

func (x *UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets) GetPartitionOffsets() []*OffsetsRange {
	if x != nil {
		return x.PartitionOffsets
	}
	return nil
}

type Consumer_ConsumerStats struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Minimal timestamp of last read from partitions.
	MinPartitionsLastReadTime *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=min_partitions_last_read_time,json=minPartitionsLastReadTime,proto3" json:"min_partitions_last_read_time,omitempty"`
	// Maximum of differences between timestamp of read and write timestamp for all messages, read during last minute.
	MaxReadTimeLag *durationpb.Duration `protobuf:"bytes,2,opt,name=max_read_time_lag,json=maxReadTimeLag,proto3" json:"max_read_time_lag,omitempty"`
	// Maximum of differences between write timestamp and create timestamp for all messages, read during last minute.
	MaxWriteTimeLag *durationpb.Duration `protobuf:"bytes,3,opt,name=max_write_time_lag,json=maxWriteTimeLag,proto3" json:"max_write_time_lag,omitempty"`
	// Bytes read statistics.
	BytesRead     *MultipleWindowsStat `protobuf:"bytes,4,opt,name=bytes_read,json=bytesRead,proto3" json:"bytes_read,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Consumer_ConsumerStats) Reset() {
	*x = Consumer_ConsumerStats{}
	mi := &file_protos_ydb_topic_proto_msgTypes[96]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Consumer_ConsumerStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Consumer_ConsumerStats) ProtoMessage() {}

func (x *Consumer_ConsumerStats) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[96]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Consumer_ConsumerStats.ProtoReflect.Descriptor instead.
func (*Consumer_ConsumerStats) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{17, 1}
}

func (x *Consumer_ConsumerStats) GetMinPartitionsLastReadTime() *timestamppb.Timestamp {
	if x != nil {
		return x.MinPartitionsLastReadTime
	}
	return nil
}

func (x *Consumer_ConsumerStats) GetMaxReadTimeLag() *durationpb.Duration {
	if x != nil {
		return x.MaxReadTimeLag
	}
	return nil
}

func (x *Consumer_ConsumerStats) GetMaxWriteTimeLag() *durationpb.Duration {
	if x != nil {
		return x.MaxWriteTimeLag
	}
	return nil
}

func (x *Consumer_ConsumerStats) GetBytesRead() *MultipleWindowsStat {
	if x != nil {
		return x.BytesRead
	}
	return nil
}

type DescribeTopicResult_PartitionInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Partition identifier.
	PartitionId int64 `protobuf:"varint,1,opt,name=partition_id,json=partitionId,proto3" json:"partition_id,omitempty"`
	// Is partition open for write.
	Active bool `protobuf:"varint,2,opt,name=active,proto3" json:"active,omitempty"`
	// Ids of partitions which was formed when this partition was split or merged.
	ChildPartitionIds []int64 `protobuf:"varint,3,rep,packed,name=child_partition_ids,json=childPartitionIds,proto3" json:"child_partition_ids,omitempty"`
	// Ids of partitions from which this partition was formed by split or merge.
	ParentPartitionIds []int64 `protobuf:"varint,4,rep,packed,name=parent_partition_ids,json=parentPartitionIds,proto3" json:"parent_partition_ids,omitempty"`
	// Stats for partition, filled only when include_stats in request is true.
	PartitionStats *PartitionStats `protobuf:"bytes,5,opt,name=partition_stats,json=partitionStats,proto3" json:"partition_stats,omitempty"`
	// Partition location, filled only when include_location in request is true.
	PartitionLocation *PartitionLocation `protobuf:"bytes,6,opt,name=partition_location,json=partitionLocation,proto3" json:"partition_location,omitempty"`
	KeyRange          *PartitionKeyRange `protobuf:"bytes,7,opt,name=key_range,json=keyRange,proto3" json:"key_range,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *DescribeTopicResult_PartitionInfo) Reset() {
	*x = DescribeTopicResult_PartitionInfo{}
	mi := &file_protos_ydb_topic_proto_msgTypes[100]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DescribeTopicResult_PartitionInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DescribeTopicResult_PartitionInfo) ProtoMessage() {}

func (x *DescribeTopicResult_PartitionInfo) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[100]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DescribeTopicResult_PartitionInfo.ProtoReflect.Descriptor instead.
func (*DescribeTopicResult_PartitionInfo) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{32, 1}
}

func (x *DescribeTopicResult_PartitionInfo) GetPartitionId() int64 {
	if x != nil {
		return x.PartitionId
	}
	return 0
}

func (x *DescribeTopicResult_PartitionInfo) GetActive() bool {
	if x != nil {
		return x.Active
	}
	return false
}

func (x *DescribeTopicResult_PartitionInfo) GetChildPartitionIds() []int64 {
	if x != nil {
		return x.ChildPartitionIds
	}
	return nil
}

func (x *DescribeTopicResult_PartitionInfo) GetParentPartitionIds() []int64 {
	if x != nil {
		return x.ParentPartitionIds
	}
	return nil
}

func (x *DescribeTopicResult_PartitionInfo) GetPartitionStats() *PartitionStats {
	if x != nil {
		return x.PartitionStats
	}
	return nil
}

func (x *DescribeTopicResult_PartitionInfo) GetPartitionLocation() *PartitionLocation {
	if x != nil {
		return x.PartitionLocation
	}
	return nil
}

func (x *DescribeTopicResult_PartitionInfo) GetKeyRange() *PartitionKeyRange {
	if x != nil {
		return x.KeyRange
	}
	return nil
}

type DescribeTopicResult_TopicStats struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Approximate size of topic.
	StoreSizeBytes int64 `protobuf:"varint,1,opt,name=store_size_bytes,json=storeSizeBytes,proto3" json:"store_size_bytes,omitempty"`
	// Minimum of timestamps of last write among all partitions.
	MinLastWriteTime *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=min_last_write_time,json=minLastWriteTime,proto3" json:"min_last_write_time,omitempty"`
	// Maximum of differences between write timestamp and create timestamp for all messages, written during last minute.
	MaxWriteTimeLag *durationpb.Duration `protobuf:"bytes,3,opt,name=max_write_time_lag,json=maxWriteTimeLag,proto3" json:"max_write_time_lag,omitempty"`
	// How much bytes were written statistics.
	BytesWritten  *MultipleWindowsStat `protobuf:"bytes,4,opt,name=bytes_written,json=bytesWritten,proto3" json:"bytes_written,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DescribeTopicResult_TopicStats) Reset() {
	*x = DescribeTopicResult_TopicStats{}
	mi := &file_protos_ydb_topic_proto_msgTypes[101]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DescribeTopicResult_TopicStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DescribeTopicResult_TopicStats) ProtoMessage() {}

func (x *DescribeTopicResult_TopicStats) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[101]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DescribeTopicResult_TopicStats.ProtoReflect.Descriptor instead.
func (*DescribeTopicResult_TopicStats) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{32, 2}
}

func (x *DescribeTopicResult_TopicStats) GetStoreSizeBytes() int64 {
	if x != nil {
		return x.StoreSizeBytes
	}
	return 0
}

func (x *DescribeTopicResult_TopicStats) GetMinLastWriteTime() *timestamppb.Timestamp {
	if x != nil {
		return x.MinLastWriteTime
	}
	return nil
}

func (x *DescribeTopicResult_TopicStats) GetMaxWriteTimeLag() *durationpb.Duration {
	if x != nil {
		return x.MaxWriteTimeLag
	}
	return nil
}

func (x *DescribeTopicResult_TopicStats) GetBytesWritten() *MultipleWindowsStat {
	if x != nil {
		return x.BytesWritten
	}
	return nil
}

type DescribeConsumerResult_PartitionInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Partition identifier.
	PartitionId int64 `protobuf:"varint,1,opt,name=partition_id,json=partitionId,proto3" json:"partition_id,omitempty"`
	// Is partition open for write.
	Active bool `protobuf:"varint,2,opt,name=active,proto3" json:"active,omitempty"`
	// Ids of partitions which was formed when this partition was split or merged.
	ChildPartitionIds []int64 `protobuf:"varint,3,rep,packed,name=child_partition_ids,json=childPartitionIds,proto3" json:"child_partition_ids,omitempty"`
	// Ids of partitions from which this partition was formed by split or merge.
	ParentPartitionIds []int64 `protobuf:"varint,4,rep,packed,name=parent_partition_ids,json=parentPartitionIds,proto3" json:"parent_partition_ids,omitempty"`
	// Stats for partition, filled only when include_stats in request is true.
	PartitionStats *PartitionStats `protobuf:"bytes,5,opt,name=partition_stats,json=partitionStats,proto3" json:"partition_stats,omitempty"`
	// Stats for consumer of this partition, filled only when include_stats in request is true.
	PartitionConsumerStats *DescribeConsumerResult_PartitionConsumerStats `protobuf:"bytes,6,opt,name=partition_consumer_stats,json=partitionConsumerStats,proto3" json:"partition_consumer_stats,omitempty"`
	// Partition location, filled only when include_location in request is true.
	PartitionLocation *PartitionLocation `protobuf:"bytes,7,opt,name=partition_location,json=partitionLocation,proto3" json:"partition_location,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *DescribeConsumerResult_PartitionInfo) Reset() {
	*x = DescribeConsumerResult_PartitionInfo{}
	mi := &file_protos_ydb_topic_proto_msgTypes[102]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DescribeConsumerResult_PartitionInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DescribeConsumerResult_PartitionInfo) ProtoMessage() {}

func (x *DescribeConsumerResult_PartitionInfo) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[102]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DescribeConsumerResult_PartitionInfo.ProtoReflect.Descriptor instead.
func (*DescribeConsumerResult_PartitionInfo) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{38, 0}
}

func (x *DescribeConsumerResult_PartitionInfo) GetPartitionId() int64 {
	if x != nil {
		return x.PartitionId
	}
	return 0
}

func (x *DescribeConsumerResult_PartitionInfo) GetActive() bool {
	if x != nil {
		return x.Active
	}
	return false
}

func (x *DescribeConsumerResult_PartitionInfo) GetChildPartitionIds() []int64 {
	if x != nil {
		return x.ChildPartitionIds
	}
	return nil
}

func (x *DescribeConsumerResult_PartitionInfo) GetParentPartitionIds() []int64 {
	if x != nil {
		return x.ParentPartitionIds
	}
	return nil
}

func (x *DescribeConsumerResult_PartitionInfo) GetPartitionStats() *PartitionStats {
	if x != nil {
		return x.PartitionStats
	}
	return nil
}

func (x *DescribeConsumerResult_PartitionInfo) GetPartitionConsumerStats() *DescribeConsumerResult_PartitionConsumerStats {
	if x != nil {
		return x.PartitionConsumerStats
	}
	return nil
}

func (x *DescribeConsumerResult_PartitionInfo) GetPartitionLocation() *PartitionLocation {
	if x != nil {
		return x.PartitionLocation
	}
	return nil
}

type DescribeConsumerResult_PartitionConsumerStats struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Last read offset from this partition.
	LastReadOffset int64 `protobuf:"varint,1,opt,name=last_read_offset,json=lastReadOffset,proto3" json:"last_read_offset,omitempty"`
	// Committed offset for this partition.
	CommittedOffset int64 `protobuf:"varint,2,opt,name=committed_offset,json=committedOffset,proto3" json:"committed_offset,omitempty"`
	// Reading this partition read session identifier.
	ReadSessionId string `protobuf:"bytes,3,opt,name=read_session_id,json=readSessionId,proto3" json:"read_session_id,omitempty"`
	// Timestamp of providing this partition to this session by server.
	PartitionReadSessionCreateTime *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=partition_read_session_create_time,json=partitionReadSessionCreateTime,proto3" json:"partition_read_session_create_time,omitempty"`
	// Timestamp of last read from this partition.
	LastReadTime *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=last_read_time,json=lastReadTime,proto3" json:"last_read_time,omitempty"`
	// Maximum of differences between timestamp of read and write timestamp for all messages, read during last minute.
	MaxReadTimeLag *durationpb.Duration `protobuf:"bytes,6,opt,name=max_read_time_lag,json=maxReadTimeLag,proto3" json:"max_read_time_lag,omitempty"`
	// Maximum of differences between write timestamp and create timestamp for all messages, read during last minute.
	MaxWriteTimeLag *durationpb.Duration `protobuf:"bytes,7,opt,name=max_write_time_lag,json=maxWriteTimeLag,proto3" json:"max_write_time_lag,omitempty"`
	// How much bytes were read during several windows statistics from this partition.
	BytesRead *MultipleWindowsStat `protobuf:"bytes,8,opt,name=bytes_read,json=bytesRead,proto3" json:"bytes_read,omitempty"`
	// Read session name, provided by client.
	ReaderName string `protobuf:"bytes,11,opt,name=reader_name,json=readerName,proto3" json:"reader_name,omitempty"`
	// Host where read session connected.
	ConnectionNodeId int32 `protobuf:"varint,12,opt,name=connection_node_id,json=connectionNodeId,proto3" json:"connection_node_id,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *DescribeConsumerResult_PartitionConsumerStats) Reset() {
	*x = DescribeConsumerResult_PartitionConsumerStats{}
	mi := &file_protos_ydb_topic_proto_msgTypes[103]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DescribeConsumerResult_PartitionConsumerStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DescribeConsumerResult_PartitionConsumerStats) ProtoMessage() {}

func (x *DescribeConsumerResult_PartitionConsumerStats) ProtoReflect() protoreflect.Message {
	mi := &file_protos_ydb_topic_proto_msgTypes[103]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DescribeConsumerResult_PartitionConsumerStats.ProtoReflect.Descriptor instead.
func (*DescribeConsumerResult_PartitionConsumerStats) Descriptor() ([]byte, []int) {
	return file_protos_ydb_topic_proto_rawDescGZIP(), []int{38, 1}
}

func (x *DescribeConsumerResult_PartitionConsumerStats) GetLastReadOffset() int64 {
	if x != nil {
		return x.LastReadOffset
	}
	return 0
}

func (x *DescribeConsumerResult_PartitionConsumerStats) GetCommittedOffset() int64 {
	if x != nil {
		return x.CommittedOffset
	}
	return 0
}

func (x *DescribeConsumerResult_PartitionConsumerStats) GetReadSessionId() string {
	if x != nil {
		return x.ReadSessionId
	}
	return ""
}

func (x *DescribeConsumerResult_PartitionConsumerStats) GetPartitionReadSessionCreateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.PartitionReadSessionCreateTime
	}
	return nil
}

func (x *DescribeConsumerResult_PartitionConsumerStats) GetLastReadTime() *timestamppb.Timestamp {
	if x != nil {
		return x.LastReadTime
	}
	return nil
}

func (x *DescribeConsumerResult_PartitionConsumerStats) GetMaxReadTimeLag() *durationpb.Duration {
	if x != nil {
		return x.MaxReadTimeLag
	}
	return nil
}

func (x *DescribeConsumerResult_PartitionConsumerStats) GetMaxWriteTimeLag() *durationpb.Duration {
	if x != nil {
		return x.MaxWriteTimeLag
	}
	return nil
}

func (x *DescribeConsumerResult_PartitionConsumerStats) GetBytesRead() *MultipleWindowsStat {
	if x != nil {
		return x.BytesRead
	}
	return nil
}

func (x *DescribeConsumerResult_PartitionConsumerStats) GetReaderName() string {
	if x != nil {
		return x.ReaderName
	}
	return ""
}

func (x *DescribeConsumerResult_PartitionConsumerStats) GetConnectionNodeId() int32 {
	if x != nil {
		return x.ConnectionNodeId
	}
	return 0
}

var File_protos_ydb_topic_proto protoreflect.FileDescriptor

const file_protos_ydb_topic_proto_rawDesc = "" +
	"\n" +
	"\x16protos/ydb_topic.proto\x12\tYdb.Topic\x1a\x1aprotos/ydb_operation.proto\x1a\x17protos/ydb_scheme.proto\x1a\x1dprotos/ydb_status_codes.proto\x1a\x1eprotos/ydb_issue_message.proto\x1a\"protos/annotations/sensitive.proto\x1a#protos/annotations/validation.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"?\n" +
	"\x0fSupportedCodecs\x12,\n" +
	"\x06codecs\x18\x01 \x03(\x05B\x14\x9a\xe6*\x02\x18d\xb2\xe6*\n" +
	"[1; 19999]R\x06codecs\"6\n" +
	"\fOffsetsRange\x12\x14\n" +
	"\x05start\x18\x01 \x01(\x03R\x05start\x12\x10\n" +
	"\x03end\x18\x02 \x01(\x03R\x03end\"0\n" +
	"\x12UpdateTokenRequest\x12\x1a\n" +
	"\x05token\x18\x01 \x01(\tB\x04\xb8\xe6*\x01R\x05token\"\x15\n" +
	"\x13UpdateTokenResponse\"\\\n" +
	"\x17PartitionWithGeneration\x12!\n" +
	"\fpartition_id\x18\x01 \x01(\x03R\vpartitionId\x12\x1e\n" +
	"\n" +
	"generation\x18\x02 \x01(\x03R\n" +
	"generation\"6\n" +
	"\fMetadataItem\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value\"\xf5\x18\n" +
	"\x12StreamWriteMessage\x1a\x94\x02\n" +
	"\n" +
	"FromClient\x12N\n" +
	"\finit_request\x18\x01 \x01(\v2).Ydb.Topic.StreamWriteMessage.InitRequestH\x00R\vinitRequest\x12Q\n" +
	"\rwrite_request\x18\x02 \x01(\v2*.Ydb.Topic.StreamWriteMessage.WriteRequestH\x00R\fwriteRequest\x12Q\n" +
	"\x14update_token_request\x18\x03 \x01(\v2\x1d.Ydb.Topic.UpdateTokenRequestH\x00R\x12updateTokenRequestB\x10\n" +
	"\x0eclient_message\x1a\x81\x03\n" +
	"\n" +
	"FromServer\x121\n" +
	"\x06status\x18\x01 \x01(\x0e2\x19.Ydb.StatusIds.StatusCodeR\x06status\x12/\n" +
	"\x06issues\x18\x02 \x03(\v2\x17.Ydb.Issue.IssueMessageR\x06issues\x12Q\n" +
	"\rinit_response\x18\x03 \x01(\v2*.Ydb.Topic.StreamWriteMessage.InitResponseH\x00R\finitResponse\x12T\n" +
	"\x0ewrite_response\x18\x04 \x01(\v2+.Ydb.Topic.StreamWriteMessage.WriteResponseH\x00R\rwriteResponse\x12T\n" +
	"\x15update_token_response\x18\x05 \x01(\v2\x1e.Ydb.Topic.UpdateTokenResponseH\x00R\x13updateTokenResponseB\x10\n" +
	"\x0eserver_message\x1a\xf2\x03\n" +
	"\vInitRequest\x12\x12\n" +
	"\x04path\x18\x01 \x01(\tR\x04path\x12(\n" +
	"\vproducer_id\x18\x02 \x01(\tB\a\xa2\xe6*\x03\x18\x80\x10R\n" +
	"producerId\x12m\n" +
	"\x12write_session_meta\x18\x03 \x03(\v2?.Ydb.Topic.StreamWriteMessage.InitRequest.WriteSessionMetaEntryR\x10writeSessionMeta\x123\n" +
	"\x10message_group_id\x18\x04 \x01(\tB\a\xa2\xe6*\x03\x18\x80\x10H\x00R\x0emessageGroupId\x12#\n" +
	"\fpartition_id\x18\x05 \x01(\x03H\x00R\vpartitionId\x12`\n" +
	"\x19partition_with_generation\x18\a \x01(\v2\".Ydb.Topic.PartitionWithGenerationH\x00R\x17partitionWithGeneration\x12%\n" +
	"\x0fget_last_seq_no\x18\x06 \x01(\bR\fgetLastSeqNo\x1aC\n" +
	"\x15WriteSessionMetaEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01B\x0e\n" +
	"\fpartitioning\x1a\xb7\x01\n" +
	"\fInitResponse\x12\x1e\n" +
	"\vlast_seq_no\x18\x01 \x01(\x03R\tlastSeqNo\x12\x1d\n" +
	"\n" +
	"session_id\x18\x02 \x01(\tR\tsessionId\x12!\n" +
	"\fpartition_id\x18\x03 \x01(\x03R\vpartitionId\x12E\n" +
	"\x10supported_codecs\x18\x04 \x01(\v2\x1a.Ydb.Topic.SupportedCodecsR\x0fsupportedCodecs\x1a\xec\x04\n" +
	"\fWriteRequest\x12R\n" +
	"\bmessages\x18\x01 \x03(\v26.Ydb.Topic.StreamWriteMessage.WriteRequest.MessageDataR\bmessages\x12\x14\n" +
	"\x05codec\x18\x02 \x01(\x05R\x05codec\x123\n" +
	"\x02tx\x18\x03 \x01(\v2\x1e.Ydb.Topic.TransactionIdentityH\x00R\x02tx\x88\x01\x01\x1a\xb5\x03\n" +
	"\vMessageData\x12\x15\n" +
	"\x06seq_no\x18\x01 \x01(\x03R\x05seqNo\x129\n" +
	"\n" +
	"created_at\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\x12\x12\n" +
	"\x04data\x18\x03 \x01(\fR\x04data\x12+\n" +
	"\x11uncompressed_size\x18\x04 \x01(\x03R\x10uncompressedSize\x123\n" +
	"\x10message_group_id\x18\x05 \x01(\tB\a\xa2\xe6*\x03\x18\x80\x10H\x00R\x0emessageGroupId\x12#\n" +
	"\fpartition_id\x18\x06 \x01(\x03H\x00R\vpartitionId\x12`\n" +
	"\x19partition_with_generation\x18\b \x01(\v2\".Ydb.Topic.PartitionWithGenerationH\x00R\x17partitionWithGeneration\x12G\n" +
	"\x0emetadata_items\x18\a \x03(\v2\x17.Ydb.Topic.MetadataItemB\a\x9a\xe6*\x03\x18\xe8\aR\rmetadataItemsB\x0e\n" +
	"\fpartitioningB\x05\n" +
	"\x03_tx\x1a\xa5\t\n" +
	"\rWriteResponse\x12H\n" +
	"\x04acks\x18\x01 \x03(\v24.Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAckR\x04acks\x12!\n" +
	"\fpartition_id\x18\x02 \x01(\x03R\vpartitionId\x12f\n" +
	"\x10write_statistics\x18\x03 \x01(\v2;.Ydb.Topic.StreamWriteMessage.WriteResponse.WriteStatisticsR\x0fwriteStatistics\x1a\xae\x04\n" +
	"\bWriteAck\x12\x15\n" +
	"\x06seq_no\x18\x01 \x01(\x03R\x05seqNo\x12X\n" +
	"\awritten\x18\x02 \x01(\v2<.Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.WrittenH\x00R\awritten\x12X\n" +
	"\askipped\x18\x03 \x01(\v2<.Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.SkippedH\x00R\askipped\x12f\n" +
	"\rwritten_in_tx\x18\x04 \x01(\v2@.Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.WrittenInTxH\x00R\vwrittenInTx\x1a!\n" +
	"\aWritten\x12\x16\n" +
	"\x06offset\x18\x01 \x01(\x03R\x06offset\x1a\xa4\x01\n" +
	"\aSkipped\x12[\n" +
	"\x06reason\x18\x01 \x01(\x0e2C.Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.Skipped.ReasonR\x06reason\"<\n" +
	"\x06Reason\x12\x16\n" +
	"\x12REASON_UNSPECIFIED\x10\x00\x12\x1a\n" +
	"\x16REASON_ALREADY_WRITTEN\x10\x01\x1a\r\n" +
	"\vWrittenInTxB\x16\n" +
	"\x14message_write_status\x1a\x8d\x03\n" +
	"\x0fWriteStatistics\x12B\n" +
	"\x0fpersisting_time\x18\x01 \x01(\v2\x19.google.protobuf.DurationR\x0epersistingTime\x12H\n" +
	"\x13min_queue_wait_time\x18\x02 \x01(\v2\x19.google.protobuf.DurationR\x10minQueueWaitTime\x12H\n" +
	"\x13max_queue_wait_time\x18\x03 \x01(\v2\x19.google.protobuf.DurationR\x10maxQueueWaitTime\x12T\n" +
	"\x19partition_quota_wait_time\x18\x04 \x01(\v2\x19.google.protobuf.DurationR\x16partitionQuotaWaitTime\x12L\n" +
	"\x15topic_quota_wait_time\x18\x05 \x01(\v2\x19.google.protobuf.DurationR\x12topicQuotaWaitTime\"\xe0-\n" +
	"\x11StreamReadMessage\x1a{\n" +
	"\x10PartitionSession\x120\n" +
	"\x14partition_session_id\x18\x01 \x01(\x03R\x12partitionSessionId\x12\x12\n" +
	"\x04path\x18\x02 \x01(\tR\x04path\x12!\n" +
	"\fpartition_id\x18\x03 \x01(\x03R\vpartitionId\x1a\xe2\x06\n" +
	"\n" +
	"FromClient\x12M\n" +
	"\finit_request\x18\x01 \x01(\v2(.Ydb.Topic.StreamReadMessage.InitRequestH\x00R\vinitRequest\x12M\n" +
	"\fread_request\x18\x02 \x01(\v2(.Ydb.Topic.StreamReadMessage.ReadRequestH\x00R\vreadRequest\x12f\n" +
	"\x15commit_offset_request\x18\x03 \x01(\v20.Ydb.Topic.StreamReadMessage.CommitOffsetRequestH\x00R\x13commitOffsetRequest\x12\x85\x01\n" +
	" partition_session_status_request\x18\x04 \x01(\v2:.Ydb.Topic.StreamReadMessage.PartitionSessionStatusRequestH\x00R\x1dpartitionSessionStatusRequest\x12Q\n" +
	"\x14update_token_request\x18\x05 \x01(\v2\x1d.Ydb.Topic.UpdateTokenRequestH\x00R\x12updateTokenRequest\x12T\n" +
	"\x0fdirect_read_ack\x18\b \x01(\v2*.Ydb.Topic.StreamReadMessage.DirectReadAckH\x00R\rdirectReadAck\x12\x85\x01\n" +
	" start_partition_session_response\x18\x06 \x01(\v2:.Ydb.Topic.StreamReadMessage.StartPartitionSessionResponseH\x00R\x1dstartPartitionSessionResponse\x12\x82\x01\n" +
	"\x1fstop_partition_session_response\x18\a \x01(\v29.Ydb.Topic.StreamReadMessage.StopPartitionSessionResponseH\x00R\x1cstopPartitionSessionResponseB\x10\n" +
	"\x0eclient_message\x1a\xd1\b\n" +
	"\n" +
	"FromServer\x121\n" +
	"\x06status\x18\x01 \x01(\x0e2\x19.Ydb.StatusIds.StatusCodeR\x06status\x12/\n" +
	"\x06issues\x18\x02 \x03(\v2\x17.Ydb.Issue.IssueMessageR\x06issues\x12P\n" +
	"\rinit_response\x18\x03 \x01(\v2).Ydb.Topic.StreamReadMessage.InitResponseH\x00R\finitResponse\x12P\n" +
	"\rread_response\x18\x04 \x01(\v2).Ydb.Topic.StreamReadMessage.ReadResponseH\x00R\freadResponse\x12i\n" +
	"\x16commit_offset_response\x18\x05 \x01(\v21.Ydb.Topic.StreamReadMessage.CommitOffsetResponseH\x00R\x14commitOffsetResponse\x12\x88\x01\n" +
	"!partition_session_status_response\x18\x06 \x01(\v2;.Ydb.Topic.StreamReadMessage.PartitionSessionStatusResponseH\x00R\x1epartitionSessionStatusResponse\x12T\n" +
	"\x15update_token_response\x18\a \x01(\v2\x1e.Ydb.Topic.UpdateTokenResponseH\x00R\x13updateTokenResponse\x12\x82\x01\n" +
	"\x1fstart_partition_session_request\x18\b \x01(\v29.Ydb.Topic.StreamReadMessage.StartPartitionSessionRequestH\x00R\x1cstartPartitionSessionRequest\x12\x7f\n" +
	"\x1estop_partition_session_request\x18\t \x01(\v28.Ydb.Topic.StreamReadMessage.StopPartitionSessionRequestH\x00R\x1bstopPartitionSessionRequest\x12o\n" +
	"\x18update_partition_session\x18\n" +
	" \x01(\v23.Ydb.Topic.StreamReadMessage.UpdatePartitionSessionH\x00R\x16updatePartitionSession\x12f\n" +
	"\x15end_partition_session\x18\v \x01(\v20.Ydb.Topic.StreamReadMessage.EndPartitionSessionH\x00R\x13endPartitionSessionB\x10\n" +
	"\x0eserver_message\x1a\xd1\x03\n" +
	"\vInitRequest\x12l\n" +
	"\x14topics_read_settings\x18\x01 \x03(\v2:.Ydb.Topic.StreamReadMessage.InitRequest.TopicReadSettingsR\x12topicsReadSettings\x12\x1a\n" +
	"\bconsumer\x18\x02 \x01(\tR\bconsumer\x12\x1f\n" +
	"\vreader_name\x18\x03 \x01(\tR\n" +
	"readerName\x12\x1f\n" +
	"\vdirect_read\x18\x04 \x01(\bR\n" +
	"directRead\x12:\n" +
	"\x19auto_partitioning_support\x18\x05 \x01(\bR\x17autoPartitioningSupport\x1a\xb9\x01\n" +
	"\x11TopicReadSettings\x12\x12\n" +
	"\x04path\x18\x01 \x01(\tR\x04path\x12#\n" +
	"\rpartition_ids\x18\x02 \x03(\x03R\fpartitionIds\x122\n" +
	"\amax_lag\x18\x03 \x01(\v2\x19.google.protobuf.DurationR\x06maxLag\x127\n" +
	"\tread_from\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\breadFrom\x1a-\n" +
	"\fInitResponse\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\x1a,\n" +
	"\vReadRequest\x12\x1d\n" +
	"\n" +
	"bytes_size\x18\x01 \x01(\x03R\tbytesSize\x1a\xe3\a\n" +
	"\fReadResponse\x12^\n" +
	"\x0epartition_data\x18\x01 \x03(\v27.Ydb.Topic.StreamReadMessage.ReadResponse.PartitionDataR\rpartitionData\x12\x1d\n" +
	"\n" +
	"bytes_size\x18\x02 \x01(\x03R\tbytesSize\x1a\xab\x02\n" +
	"\vMessageData\x12\x16\n" +
	"\x06offset\x18\x01 \x01(\x03R\x06offset\x12\x15\n" +
	"\x06seq_no\x18\x02 \x01(\x03R\x05seqNo\x129\n" +
	"\n" +
	"created_at\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\x12\x12\n" +
	"\x04data\x18\x05 \x01(\fR\x04data\x12+\n" +
	"\x11uncompressed_size\x18\x06 \x01(\x03R\x10uncompressedSize\x121\n" +
	"\x10message_group_id\x18\a \x01(\tB\a\xa2\xe6*\x03\x18\x80\x10R\x0emessageGroupId\x12>\n" +
	"\x0emetadata_items\x18\b \x03(\v2\x17.Ydb.Topic.MetadataItemR\rmetadataItems\x1a\x96\x03\n" +
	"\x05Batch\x12X\n" +
	"\fmessage_data\x18\x01 \x03(\v25.Ydb.Topic.StreamReadMessage.ReadResponse.MessageDataR\vmessageData\x12(\n" +
	"\vproducer_id\x18\x02 \x01(\tB\a\xa2\xe6*\x03\x18\x80\x10R\n" +
	"producerId\x12s\n" +
	"\x12write_session_meta\x18\x03 \x03(\v2E.Ydb.Topic.StreamReadMessage.ReadResponse.Batch.WriteSessionMetaEntryR\x10writeSessionMeta\x12\x14\n" +
	"\x05codec\x18\x04 \x01(\x05R\x05codec\x129\n" +
	"\n" +
	"written_at\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\twrittenAt\x1aC\n" +
	"\x15WriteSessionMetaEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1a\x8c\x01\n" +
	"\rPartitionData\x120\n" +
	"\x14partition_session_id\x18\x01 \x01(\x03R\x12partitionSessionId\x12I\n" +
	"\abatches\x18\x02 \x03(\v2/.Ydb.Topic.StreamReadMessage.ReadResponse.BatchR\abatches\x1a\x82\x02\n" +
	"\x13CommitOffsetRequest\x12m\n" +
	"\x0ecommit_offsets\x18\x01 \x03(\v2F.Ydb.Topic.StreamReadMessage.CommitOffsetRequest.PartitionCommitOffsetR\rcommitOffsets\x1a|\n" +
	"\x15PartitionCommitOffset\x120\n" +
	"\x14partition_session_id\x18\x01 \x01(\x03R\x12partitionSessionId\x121\n" +
	"\aoffsets\x18\x02 \x03(\v2\x17.Ydb.Topic.OffsetsRangeR\aoffsets\x1a\x9e\x02\n" +
	"\x14CommitOffsetResponse\x12\x8c\x01\n" +
	"\x1cpartitions_committed_offsets\x18\x01 \x03(\v2J.Ydb.Topic.StreamReadMessage.CommitOffsetResponse.PartitionCommittedOffsetR\x1apartitionsCommittedOffsets\x1aw\n" +
	"\x18PartitionCommittedOffset\x120\n" +
	"\x14partition_session_id\x18\x01 \x01(\x03R\x12partitionSessionId\x12)\n" +
	"\x10committed_offset\x18\x02 \x01(\x03R\x0fcommittedOffset\x1aQ\n" +
	"\x1dPartitionSessionStatusRequest\x120\n" +
	"\x14partition_session_id\x18\x01 \x01(\x03R\x12partitionSessionId\x1a\x9a\x02\n" +
	"\x1ePartitionSessionStatusResponse\x120\n" +
	"\x14partition_session_id\x18\x01 \x01(\x03R\x12partitionSessionId\x12D\n" +
	"\x11partition_offsets\x18\x02 \x01(\v2\x17.Ydb.Topic.OffsetsRangeR\x10partitionOffsets\x12)\n" +
	"\x10committed_offset\x18\x03 \x01(\x03R\x0fcommittedOffset\x12U\n" +
	"\x19write_time_high_watermark\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\x16writeTimeHighWatermark\x1a\xb8\x02\n" +
	"\x1cStartPartitionSessionRequest\x12Z\n" +
	"\x11partition_session\x18\x01 \x01(\v2-.Ydb.Topic.StreamReadMessage.PartitionSessionR\x10partitionSession\x12)\n" +
	"\x10committed_offset\x18\x02 \x01(\x03R\x0fcommittedOffset\x12D\n" +
	"\x11partition_offsets\x18\x03 \x01(\v2\x17.Ydb.Topic.OffsetsRangeR\x10partitionOffsets\x12K\n" +
	"\x12partition_location\x18\x04 \x01(\v2\x1c.Ydb.Topic.PartitionLocationR\x11partitionLocation\x1a\xc3\x01\n" +
	"\x1dStartPartitionSessionResponse\x120\n" +
	"\x14partition_session_id\x18\x01 \x01(\x03R\x12partitionSessionId\x12$\n" +
	"\vread_offset\x18\x02 \x01(\x03H\x00R\n" +
	"readOffset\x88\x01\x01\x12(\n" +
	"\rcommit_offset\x18\x03 \x01(\x03H\x01R\fcommitOffset\x88\x01\x01B\x0e\n" +
	"\f_read_offsetB\x10\n" +
	"\x0e_commit_offset\x1a\xc5\x01\n" +
	"\x1bStopPartitionSessionRequest\x120\n" +
	"\x14partition_session_id\x18\x01 \x01(\x03R\x12partitionSessionId\x12\x1a\n" +
	"\bgraceful\x18\x02 \x01(\bR\bgraceful\x12)\n" +
	"\x10committed_offset\x18\x03 \x01(\x03R\x0fcommittedOffset\x12-\n" +
	"\x13last_direct_read_id\x18\x04 \x01(\x03R\x10lastDirectReadId\x1al\n" +
	"\x1cStopPartitionSessionResponse\x120\n" +
	"\x14partition_session_id\x18\x01 \x01(\x03R\x12partitionSessionId\x12\x1a\n" +
	"\bgraceful\x18\x02 \x01(\bR\bgraceful\x1a\x97\x01\n" +
	"\x16UpdatePartitionSession\x120\n" +
	"\x14partition_session_id\x18\x01 \x01(\x03R\x12partitionSessionId\x12K\n" +
	"\x12partition_location\x18\x02 \x01(\v2\x1c.Ydb.Topic.PartitionLocationR\x11partitionLocation\x1ag\n" +
	"\rDirectReadAck\x120\n" +
	"\x14partition_session_id\x18\x01 \x01(\x03R\x12partitionSessionId\x12$\n" +
	"\x0edirect_read_id\x18\x02 \x01(\x03R\fdirectReadId\x1a\xad\x01\n" +
	"\x13EndPartitionSession\x120\n" +
	"\x14partition_session_id\x18\x01 \x01(\x03R\x12partitionSessionId\x124\n" +
	"\x16adjacent_partition_ids\x18\x02 \x03(\x03R\x14adjacentPartitionIds\x12.\n" +
	"\x13child_partition_ids\x18\x03 \x03(\x03R\x11childPartitionIds\"\xb4\x10\n" +
	"\x17StreamDirectReadMessage\x1a\xf1\x02\n" +
	"\n" +
	"FromClient\x12S\n" +
	"\finit_request\x18\x01 \x01(\v2..Ydb.Topic.StreamDirectReadMessage.InitRequestH\x00R\vinitRequest\x12\xa8\x01\n" +
	"+start_direct_read_partition_session_request\x18\x02 \x01(\v2I.Ydb.Topic.StreamDirectReadMessage.StartDirectReadPartitionSessionRequestH\x00R&startDirectReadPartitionSessionRequest\x12Q\n" +
	"\x14update_token_request\x18\x03 \x01(\v2\x1d.Ydb.Topic.UpdateTokenRequestH\x00R\x12updateTokenRequestB\x10\n" +
	"\x0eclient_message\x1a\xdb\x05\n" +
	"\n" +
	"FromServer\x121\n" +
	"\x06status\x18\x01 \x01(\x0e2\x19.Ydb.StatusIds.StatusCodeR\x06status\x12/\n" +
	"\x06issues\x18\x02 \x03(\v2\x17.Ydb.Issue.IssueMessageR\x06issues\x12V\n" +
	"\rinit_response\x18\x06 \x01(\v2/.Ydb.Topic.StreamDirectReadMessage.InitResponseH\x00R\finitResponse\x12\xab\x01\n" +
	",start_direct_read_partition_session_response\x18\a \x01(\v2J.Ydb.Topic.StreamDirectReadMessage.StartDirectReadPartitionSessionResponseH\x00R'startDirectReadPartitionSessionResponse\x12\x8f\x01\n" +
	"\"stop_direct_read_partition_session\x18\x03 \x01(\v2A.Ydb.Topic.StreamDirectReadMessage.StopDirectReadPartitionSessionH\x00R\x1estopDirectReadPartitionSession\x12i\n" +
	"\x14direct_read_response\x18\x04 \x01(\v25.Ydb.Topic.StreamDirectReadMessage.DirectReadResponseH\x00R\x12directReadResponse\x12T\n" +
	"\x15update_token_response\x18\x05 \x01(\v2\x1e.Ydb.Topic.UpdateTokenResponseH\x00R\x13updateTokenResponseB\x10\n" +
	"\x0eserver_message\x1a\xe5\x01\n" +
	"\vInitRequest\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\x12r\n" +
	"\x14topics_read_settings\x18\x02 \x03(\v2@.Ydb.Topic.StreamDirectReadMessage.InitRequest.TopicReadSettingsR\x12topicsReadSettings\x12\x1a\n" +
	"\bconsumer\x18\x03 \x01(\tR\bconsumer\x1a'\n" +
	"\x11TopicReadSettings\x12\x12\n" +
	"\x04path\x18\x01 \x01(\tR\x04path\x1a\x0e\n" +
	"\fInitResponse\x1a\xa9\x01\n" +
	"&StartDirectReadPartitionSessionRequest\x120\n" +
	"\x14partition_session_id\x18\x01 \x01(\x03R\x12partitionSessionId\x12-\n" +
	"\x13last_direct_read_id\x18\x02 \x01(\x03R\x10lastDirectReadId\x12\x1e\n" +
	"\n" +
	"generation\x18\x03 \x01(\x03R\n" +
	"generation\x1a{\n" +
	"'StartDirectReadPartitionSessionResponse\x120\n" +
	"\x14partition_session_id\x18\x01 \x01(\x03R\x12partitionSessionId\x12\x1e\n" +
	"\n" +
	"generation\x18\x02 \x01(\x03R\n" +
	"generation\x1a\xd6\x01\n" +
	"\x1eStopDirectReadPartitionSession\x121\n" +
	"\x06status\x18\x01 \x01(\x0e2\x19.Ydb.StatusIds.StatusCodeR\x06status\x12/\n" +
	"\x06issues\x18\x02 \x03(\v2\x17.Ydb.Issue.IssueMessageR\x06issues\x120\n" +
	"\x14partition_session_id\x18\x03 \x01(\x03R\x12partitionSessionId\x12\x1e\n" +
	"\n" +
	"generation\x18\x04 \x01(\x03R\n" +
	"generation\x1a\xcc\x01\n" +
	"\x12DirectReadResponse\x120\n" +
	"\x14partition_session_id\x18\x01 \x01(\x03R\x12partitionSessionId\x12$\n" +
	"\x0edirect_read_id\x18\x02 \x01(\x03R\fdirectReadId\x12^\n" +
	"\x0epartition_data\x18\x03 \x01(\v27.Ydb.Topic.StreamReadMessage.ReadResponse.PartitionDataR\rpartitionData\"?\n" +
	"\x13TransactionIdentity\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x18\n" +
	"\asession\x18\x02 \x01(\tR\asession\"\x9c\x04\n" +
	"!UpdateOffsetsInTransactionRequest\x12J\n" +
	"\x10operation_params\x18\x01 \x01(\v2\x1f.Ydb.Operations.OperationParamsR\x0foperationParams\x12.\n" +
	"\x02tx\x18\x02 \x01(\v2\x1e.Ydb.Topic.TransactionIdentityR\x02tx\x12Q\n" +
	"\x06topics\x18\x03 \x03(\v29.Ydb.Topic.UpdateOffsetsInTransactionRequest.TopicOffsetsR\x06topics\x12\x1a\n" +
	"\bconsumer\x18\x04 \x01(\tR\bconsumer\x1a\x8b\x02\n" +
	"\fTopicOffsets\x12\x12\n" +
	"\x04path\x18\x01 \x01(\tR\x04path\x12j\n" +
	"\n" +
	"partitions\x18\x02 \x03(\v2J.Ydb.Topic.UpdateOffsetsInTransactionRequest.TopicOffsets.PartitionOffsetsR\n" +
	"partitions\x1a{\n" +
	"\x10PartitionOffsets\x12!\n" +
	"\fpartition_id\x18\x01 \x01(\x03R\vpartitionId\x12D\n" +
	"\x11partition_offsets\x18\x02 \x03(\v2\x17.Ydb.Topic.OffsetsRangeR\x10partitionOffsets\"]\n" +
	"\"UpdateOffsetsInTransactionResponse\x127\n" +
	"\toperation\x18\x01 \x01(\v2\x19.Ydb.Operations.OperationR\toperation\"\"\n" +
	" UpdateOffsetsInTransactionResult\"\xcc\x01\n" +
	"\x13CommitOffsetRequest\x12J\n" +
	"\x10operation_params\x18\x01 \x01(\v2\x1f.Ydb.Operations.OperationParamsR\x0foperationParams\x12\x12\n" +
	"\x04path\x18\x02 \x01(\tR\x04path\x12!\n" +
	"\fpartition_id\x18\x03 \x01(\x03R\vpartitionId\x12\x1a\n" +
	"\bconsumer\x18\x04 \x01(\tR\bconsumer\x12\x16\n" +
	"\x06offset\x18\x05 \x01(\x03R\x06offset\"O\n" +
	"\x14CommitOffsetResponse\x127\n" +
	"\toperation\x18\x01 \x01(\v2\x19.Ydb.Operations.OperationR\toperation\"\x14\n" +
	"\x12CommitOffsetResult\"h\n" +
	"\x13MultipleWindowsStat\x12\x1d\n" +
	"\n" +
	"per_minute\x18\x01 \x01(\x03R\tperMinute\x12\x19\n" +
	"\bper_hour\x18\x02 \x01(\x03R\aperHour\x12\x17\n" +
	"\aper_day\x18\x03 \x01(\x03R\x06perDay\"\xcd\x05\n" +
	"\bConsumer\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x1c\n" +
	"\timportant\x18\x02 \x01(\bR\timportant\x127\n" +
	"\tread_from\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\breadFrom\x12E\n" +
	"\x10supported_codecs\x18\x05 \x01(\v2\x1a.Ydb.Topic.SupportedCodecsR\x0fsupportedCodecs\x12C\n" +
	"\n" +
	"attributes\x18\x06 \x03(\v2#.Ydb.Topic.Consumer.AttributesEntryR\n" +
	"attributes\x12H\n" +
	"\x0econsumer_stats\x18\a \x01(\v2!.Ydb.Topic.Consumer.ConsumerStatsR\rconsumerStats\x1a=\n" +
	"\x0fAttributesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1a\xba\x02\n" +
	"\rConsumerStats\x12\\\n" +
	"\x1dmin_partitions_last_read_time\x18\x01 \x01(\v2\x1a.google.protobuf.TimestampR\x19minPartitionsLastReadTime\x12D\n" +
	"\x11max_read_time_lag\x18\x02 \x01(\v2\x19.google.protobuf.DurationR\x0emaxReadTimeLag\x12F\n" +
	"\x12max_write_time_lag\x18\x03 \x01(\v2\x19.google.protobuf.DurationR\x0fmaxWriteTimeLag\x12=\n" +
	"\n" +
	"bytes_read\x18\x04 \x01(\v2\x1e.Ydb.Topic.MultipleWindowsStatR\tbytesReadJ\x04\b\x04\x10\x05\"\x91\x03\n" +
	"\rAlterConsumer\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12(\n" +
	"\rset_important\x18\x02 \x01(\bH\x00R\fsetImportant\x88\x01\x01\x12>\n" +
	"\rset_read_from\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\vsetReadFrom\x12L\n" +
	"\x14set_supported_codecs\x18\x05 \x01(\v2\x1a.Ydb.Topic.SupportedCodecsR\x12setSupportedCodecs\x12X\n" +
	"\x10alter_attributes\x18\x06 \x03(\v2-.Ydb.Topic.AlterConsumer.AlterAttributesEntryR\x0falterAttributes\x1aB\n" +
	"\x14AlterAttributesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01B\x10\n" +
	"\x0e_set_importantJ\x04\b\x04\x10\x05\"\xb5\x02\n" +
	"\x14PartitioningSettings\x12<\n" +
	"\x15min_active_partitions\x18\x01 \x01(\x03B\b\xb2\xe6*\x04>= 0R\x13minActivePartitions\x12<\n" +
	"\x15max_active_partitions\x18\x03 \x01(\x03B\b\xb2\xe6*\x04>= 0R\x13maxActivePartitions\x12>\n" +
	"\x15partition_count_limit\x18\x02 \x01(\x03B\n" +
	"\xb2\xe6*\x04>= 0\x18\x01R\x13partitionCountLimit\x12a\n" +
	"\x1aauto_partitioning_settings\x18\x04 \x01(\v2#.Ydb.Topic.AutoPartitioningSettingsR\x18autoPartitioningSettings\"\xbe\x01\n" +
	"\x18AutoPartitioningSettings\x12?\n" +
	"\bstrategy\x18\x01 \x01(\x0e2#.Ydb.Topic.AutoPartitioningStrategyR\bstrategy\x12a\n" +
	"\x15partition_write_speed\x18\x02 \x01(\v2-.Ydb.Topic.AutoPartitioningWriteSpeedStrategyR\x13partitionWriteSpeed\"\xf6\x01\n" +
	"\"AutoPartitioningWriteSpeedStrategy\x12L\n" +
	"\x14stabilization_window\x18\x01 \x01(\v2\x19.google.protobuf.DurationR\x13stabilizationWindow\x12>\n" +
	"\x16up_utilization_percent\x18\x02 \x01(\x05B\b\xb2\xe6*\x04>= 0R\x14upUtilizationPercent\x12B\n" +
	"\x18down_utilization_percent\x18\x03 \x01(\x05B\b\xb2\xe6*\x04>= 0R\x16downUtilizationPercent\"\xf2\x03\n" +
	"\x19AlterPartitioningSettings\x12H\n" +
	"\x19set_min_active_partitions\x18\x01 \x01(\x03B\b\xb2\xe6*\x04>= 0H\x00R\x16setMinActivePartitions\x88\x01\x01\x12H\n" +
	"\x19set_max_active_partitions\x18\x03 \x01(\x03B\b\xb2\xe6*\x04>= 0H\x01R\x16setMaxActivePartitions\x88\x01\x01\x12J\n" +
	"\x19set_partition_count_limit\x18\x02 \x01(\x03B\n" +
	"\xb2\xe6*\x04>= 0\x18\x01H\x02R\x16setPartitionCountLimit\x88\x01\x01\x12v\n" +
	" alter_auto_partitioning_settings\x18\x04 \x01(\v2(.Ydb.Topic.AlterAutoPartitioningSettingsH\x03R\x1dalterAutoPartitioningSettings\x88\x01\x01B\x1c\n" +
	"\x1a_set_min_active_partitionsB\x1c\n" +
	"\x1a_set_max_active_partitionsB\x1c\n" +
	"\x1a_set_partition_count_limitB#\n" +
	"!_alter_auto_partitioning_settings\"\x8f\x02\n" +
	"\x1dAlterAutoPartitioningSettings\x12K\n" +
	"\fset_strategy\x18\x01 \x01(\x0e2#.Ydb.Topic.AutoPartitioningStrategyH\x00R\vsetStrategy\x88\x01\x01\x12r\n" +
	"\x19set_partition_write_speed\x18\x02 \x01(\v22.Ydb.Topic.AlterAutoPartitioningWriteSpeedStrategyH\x01R\x16setPartitionWriteSpeed\x88\x01\x01B\x0f\n" +
	"\r_set_strategyB\x1c\n" +
	"\x1a_set_partition_write_speed\"\xfc\x02\n" +
	"'AlterAutoPartitioningWriteSpeedStrategy\x12X\n" +
	"\x18set_stabilization_window\x18\x01 \x01(\v2\x19.google.protobuf.DurationH\x00R\x16setStabilizationWindow\x88\x01\x01\x12J\n" +
	"\x1aset_up_utilization_percent\x18\x02 \x01(\x05B\b\xb2\xe6*\x04>= 0H\x01R\x17setUpUtilizationPercent\x88\x01\x01\x12N\n" +
	"\x1cset_down_utilization_percent\x18\x03 \x01(\x05B\b\xb2\xe6*\x04>= 0H\x02R\x19setDownUtilizationPercent\x88\x01\x01B\x1b\n" +
	"\x19_set_stabilization_windowB\x1d\n" +
	"\x1b_set_up_utilization_percentB\x1f\n" +
	"\x1d_set_down_utilization_percent\"\xc7\x06\n" +
	"\x12CreateTopicRequest\x12J\n" +
	"\x10operation_params\x18\x01 \x01(\v2\x1f.Ydb.Operations.OperationParamsR\x0foperationParams\x12\x12\n" +
	"\x04path\x18\x02 \x01(\tR\x04path\x12T\n" +
	"\x15partitioning_settings\x18\x03 \x01(\v2\x1f.Ydb.Topic.PartitioningSettingsR\x14partitioningSettings\x12D\n" +
	"\x10retention_period\x18\x04 \x01(\v2\x19.google.protobuf.DurationR\x0fretentionPeriod\x12:\n" +
	"\x14retention_storage_mb\x18\x05 \x01(\x03B\b\xb2\xe6*\x04>= 0R\x12retentionStorageMb\x12E\n" +
	"\x10supported_codecs\x18\a \x01(\v2\x1a.Ydb.Topic.SupportedCodecsR\x0fsupportedCodecs\x12[\n" +
	"&partition_write_speed_bytes_per_second\x18\b \x01(\x03B\b\xb2\xe6*\x04>= 0R!partitionWriteSpeedBytesPerSecond\x12G\n" +
	"\x1bpartition_write_burst_bytes\x18\t \x01(\x03B\b\xb2\xe6*\x04>= 0R\x18partitionWriteBurstBytes\x12M\n" +
	"\n" +
	"attributes\x18\n" +
	" \x03(\v2-.Ydb.Topic.CreateTopicRequest.AttributesEntryR\n" +
	"attributes\x12:\n" +
	"\tconsumers\x18\v \x03(\v2\x13.Ydb.Topic.ConsumerB\a\x9a\xe6*\x03\x18\xb8\x17R\tconsumers\x12<\n" +
	"\rmetering_mode\x18\f \x01(\x0e2\x17.Ydb.Topic.MeteringModeR\fmeteringMode\x1a=\n" +
	"\x0fAttributesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01J\x04\b\x06\x10\a\"N\n" +
	"\x13CreateTopicResponse\x127\n" +
	"\toperation\x18\x01 \x01(\v2\x19.Ydb.Operations.OperationR\toperation\"\x13\n" +
	"\x11CreateTopicResult\"L\n" +
	"\x11PartitionLocation\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\x05R\x06nodeId\x12\x1e\n" +
	"\n" +
	"generation\x18\x02 \x01(\x03R\n" +
	"generation\"\xc6\x01\n" +
	"\x14DescribeTopicRequest\x12J\n" +
	"\x10operation_params\x18\x01 \x01(\v2\x1f.Ydb.Operations.OperationParamsR\x0foperationParams\x12\x12\n" +
	"\x04path\x18\x02 \x01(\tR\x04path\x12#\n" +
	"\rinclude_stats\x18\x03 \x01(\bR\fincludeStats\x12)\n" +
	"\x10include_location\x18\x04 \x01(\bR\x0fincludeLocation\"P\n" +
	"\x15DescribeTopicResponse\x127\n" +
	"\toperation\x18\x01 \x01(\v2\x19.Ydb.Operations.OperationR\toperation\"s\n" +
	"\x11PartitionKeyRange\x12\"\n" +
	"\n" +
	"from_bound\x18\x01 \x01(\fH\x00R\tfromBound\x88\x01\x01\x12\x1e\n" +
	"\bto_bound\x18\x02 \x01(\fH\x01R\atoBound\x88\x01\x01B\r\n" +
	"\v_from_boundB\v\n" +
	"\t_to_bound\"\xcd\r\n" +
	"\x13DescribeTopicResult\x12%\n" +
	"\x04self\x18\x01 \x01(\v2\x11.Ydb.Scheme.EntryR\x04self\x12T\n" +
	"\x15partitioning_settings\x18\x02 \x01(\v2\x1f.Ydb.Topic.PartitioningSettingsR\x14partitioningSettings\x12L\n" +
	"\n" +
	"partitions\x18\x03 \x03(\v2,.Ydb.Topic.DescribeTopicResult.PartitionInfoR\n" +
	"partitions\x12D\n" +
	"\x10retention_period\x18\x04 \x01(\v2\x19.google.protobuf.DurationR\x0fretentionPeriod\x120\n" +
	"\x14retention_storage_mb\x18\x05 \x01(\x03R\x12retentionStorageMb\x12E\n" +
	"\x10supported_codecs\x18\a \x01(\v2\x1a.Ydb.Topic.SupportedCodecsR\x0fsupportedCodecs\x12Q\n" +
	"&partition_write_speed_bytes_per_second\x18\b \x01(\x03R!partitionWriteSpeedBytesPerSecond\x12Z\n" +
	"+partition_total_read_speed_bytes_per_second\x18\x0e \x01(\x03R%partitionTotalReadSpeedBytesPerSecond\x12`\n" +
	".partition_consumer_read_speed_bytes_per_second\x18\x0f \x01(\x03R(partitionConsumerReadSpeedBytesPerSecond\x12=\n" +
	"\x1bpartition_write_burst_bytes\x18\t \x01(\x03R\x18partitionWriteBurstBytes\x12N\n" +
	"\n" +
	"attributes\x18\n" +
	" \x03(\v2..Ydb.Topic.DescribeTopicResult.AttributesEntryR\n" +
	"attributes\x121\n" +
	"\tconsumers\x18\v \x03(\v2\x13.Ydb.Topic.ConsumerR\tconsumers\x12<\n" +
	"\rmetering_mode\x18\f \x01(\x0e2\x17.Ydb.Topic.MeteringModeR\fmeteringMode\x12J\n" +
	"\vtopic_stats\x18\r \x01(\v2).Ydb.Topic.DescribeTopicResult.TopicStatsR\n" +
	"topicStats\x1a=\n" +
	"\x0fAttributesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1a\xf8\x02\n" +
	"\rPartitionInfo\x12!\n" +
	"\fpartition_id\x18\x01 \x01(\x03R\vpartitionId\x12\x16\n" +
	"\x06active\x18\x02 \x01(\bR\x06active\x12.\n" +
	"\x13child_partition_ids\x18\x03 \x03(\x03R\x11childPartitionIds\x120\n" +
	"\x14parent_partition_ids\x18\x04 \x03(\x03R\x12parentPartitionIds\x12B\n" +
	"\x0fpartition_stats\x18\x05 \x01(\v2\x19.Ydb.Topic.PartitionStatsR\x0epartitionStats\x12K\n" +
	"\x12partition_location\x18\x06 \x01(\v2\x1c.Ydb.Topic.PartitionLocationR\x11partitionLocation\x129\n" +
	"\tkey_range\x18\a \x01(\v2\x1c.Ydb.Topic.PartitionKeyRangeR\bkeyRange\x1a\x8e\x02\n" +
	"\n" +
	"TopicStats\x12(\n" +
	"\x10store_size_bytes\x18\x01 \x01(\x03R\x0estoreSizeBytes\x12I\n" +
	"\x13min_last_write_time\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\x10minLastWriteTime\x12F\n" +
	"\x12max_write_time_lag\x18\x03 \x01(\v2\x19.google.protobuf.DurationR\x0fmaxWriteTimeLag\x12C\n" +
	"\rbytes_written\x18\x04 \x01(\v2\x1e.Ydb.Topic.MultipleWindowsStatR\fbytesWrittenJ\x04\b\x06\x10\a\"\xed\x01\n" +
	"\x18DescribePartitionRequest\x12J\n" +
	"\x10operation_params\x18\x01 \x01(\v2\x1f.Ydb.Operations.OperationParamsR\x0foperationParams\x12\x12\n" +
	"\x04path\x18\x02 \x01(\tR\x04path\x12!\n" +
	"\fpartition_id\x18\x03 \x01(\x03R\vpartitionId\x12#\n" +
	"\rinclude_stats\x18\x04 \x01(\bR\fincludeStats\x12)\n" +
	"\x10include_location\x18\x05 \x01(\bR\x0fincludeLocation\"T\n" +
	"\x19DescribePartitionResponse\x127\n" +
	"\toperation\x18\x01 \x01(\v2\x19.Ydb.Operations.OperationR\toperation\"e\n" +
	"\x17DescribePartitionResult\x12J\n" +
	"\tpartition\x18\x01 \x01(\v2,.Ydb.Topic.DescribeTopicResult.PartitionInfoR\tpartition\"\xe5\x01\n" +
	"\x17DescribeConsumerRequest\x12J\n" +
	"\x10operation_params\x18\x01 \x01(\v2\x1f.Ydb.Operations.OperationParamsR\x0foperationParams\x12\x12\n" +
	"\x04path\x18\x02 \x01(\tR\x04path\x12\x1a\n" +
	"\bconsumer\x18\x03 \x01(\tR\bconsumer\x12#\n" +
	"\rinclude_stats\x18\x04 \x01(\bR\fincludeStats\x12)\n" +
	"\x10include_location\x18\x05 \x01(\bR\x0fincludeLocation\"S\n" +
	"\x18DescribeConsumerResponse\x127\n" +
	"\toperation\x18\x01 \x01(\v2\x19.Ydb.Operations.OperationR\toperation\"\xd3\t\n" +
	"\x16DescribeConsumerResult\x12%\n" +
	"\x04self\x18\x01 \x01(\v2\x11.Ydb.Scheme.EntryR\x04self\x12/\n" +
	"\bconsumer\x18\x02 \x01(\v2\x13.Ydb.Topic.ConsumerR\bconsumer\x12O\n" +
	"\n" +
	"partitions\x18\x03 \x03(\v2/.Ydb.Topic.DescribeConsumerResult.PartitionInfoR\n" +
	"partitions\x1a\xb1\x03\n" +
	"\rPartitionInfo\x12!\n" +
	"\fpartition_id\x18\x01 \x01(\x03R\vpartitionId\x12\x16\n" +
	"\x06active\x18\x02 \x01(\bR\x06active\x12.\n" +
	"\x13child_partition_ids\x18\x03 \x03(\x03R\x11childPartitionIds\x120\n" +
	"\x14parent_partition_ids\x18\x04 \x03(\x03R\x12parentPartitionIds\x12B\n" +
	"\x0fpartition_stats\x18\x05 \x01(\v2\x19.Ydb.Topic.PartitionStatsR\x0epartitionStats\x12r\n" +
	"\x18partition_consumer_stats\x18\x06 \x01(\v28.Ydb.Topic.DescribeConsumerResult.PartitionConsumerStatsR\x16partitionConsumerStats\x12K\n" +
	"\x12partition_location\x18\a \x01(\v2\x1c.Ydb.Topic.PartitionLocationR\x11partitionLocation\x1a\xdb\x04\n" +
	"\x16PartitionConsumerStats\x12(\n" +
	"\x10last_read_offset\x18\x01 \x01(\x03R\x0elastReadOffset\x12)\n" +
	"\x10committed_offset\x18\x02 \x01(\x03R\x0fcommittedOffset\x12&\n" +
	"\x0fread_session_id\x18\x03 \x01(\tR\rreadSessionId\x12f\n" +
	"\"partition_read_session_create_time\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\x1epartitionReadSessionCreateTime\x12@\n" +
	"\x0elast_read_time\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\flastReadTime\x12D\n" +
	"\x11max_read_time_lag\x18\x06 \x01(\v2\x19.google.protobuf.DurationR\x0emaxReadTimeLag\x12F\n" +
	"\x12max_write_time_lag\x18\a \x01(\v2\x19.google.protobuf.DurationR\x0fmaxWriteTimeLag\x12=\n" +
	"\n" +
	"bytes_read\x18\b \x01(\v2\x1e.Ydb.Topic.MultipleWindowsStatR\tbytesRead\x12\x1f\n" +
	"\vreader_name\x18\v \x01(\tR\n" +
	"readerName\x12,\n" +
	"\x12connection_node_id\x18\f \x01(\x05R\x10connectionNodeId\"\x81\x03\n" +
	"\x0ePartitionStats\x12D\n" +
	"\x11partition_offsets\x18\x01 \x01(\v2\x17.Ydb.Topic.OffsetsRangeR\x10partitionOffsets\x12(\n" +
	"\x10store_size_bytes\x18\x02 \x01(\x03R\x0estoreSizeBytes\x12B\n" +
	"\x0flast_write_time\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\rlastWriteTime\x12F\n" +
	"\x12max_write_time_lag\x18\x04 \x01(\v2\x19.google.protobuf.DurationR\x0fmaxWriteTimeLag\x12C\n" +
	"\rbytes_written\x18\x05 \x01(\v2\x1e.Ydb.Topic.MultipleWindowsStatR\fbytesWritten\x12.\n" +
	"\x11partition_node_id\x18\b \x01(\x05B\x02\x18\x01R\x0fpartitionNodeId\"\x96\t\n" +
	"\x11AlterTopicRequest\x12J\n" +
	"\x10operation_params\x18\x01 \x01(\v2\x1f.Ydb.Operations.OperationParamsR\x0foperationParams\x12\x12\n" +
	"\x04path\x18\x02 \x01(\tR\x04path\x12d\n" +
	"\x1balter_partitioning_settings\x18\x03 \x01(\v2$.Ydb.Topic.AlterPartitioningSettingsR\x19alterPartitioningSettings\x12K\n" +
	"\x14set_retention_period\x18\x04 \x01(\v2\x19.google.protobuf.DurationR\x12setRetentionPeriod\x12F\n" +
	"\x18set_retention_storage_mb\x18\x05 \x01(\x03B\b\xb2\xe6*\x04>= 0H\x00R\x15setRetentionStorageMb\x88\x01\x01\x12L\n" +
	"\x14set_supported_codecs\x18\a \x01(\v2\x1a.Ydb.Topic.SupportedCodecsR\x12setSupportedCodecs\x12g\n" +
	"*set_partition_write_speed_bytes_per_second\x18\b \x01(\x03B\b\xb2\xe6*\x04>= 0H\x01R$setPartitionWriteSpeedBytesPerSecond\x88\x01\x01\x12S\n" +
	"\x1fset_partition_write_burst_bytes\x18\t \x01(\x03B\b\xb2\xe6*\x04>= 0H\x02R\x1bsetPartitionWriteBurstBytes\x88\x01\x01\x12\\\n" +
	"\x10alter_attributes\x18\n" +
	" \x03(\v21.Ydb.Topic.AlterTopicRequest.AlterAttributesEntryR\x0falterAttributes\x12A\n" +
	"\radd_consumers\x18\v \x03(\v2\x13.Ydb.Topic.ConsumerB\a\x9a\xe6*\x03\x18\xb8\x17R\faddConsumers\x12.\n" +
	"\x0edrop_consumers\x18\f \x03(\tB\a\x9a\xe6*\x03\x18\xb8\x17R\rdropConsumers\x12J\n" +
	"\x0falter_consumers\x18\r \x03(\v2\x18.Ydb.Topic.AlterConsumerB\a\x9a\xe6*\x03\x18\xb8\x17R\x0ealterConsumers\x12C\n" +
	"\x11set_metering_mode\x18\x0e \x01(\x0e2\x17.Ydb.Topic.MeteringModeR\x0fsetMeteringMode\x1aB\n" +
	"\x14AlterAttributesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01B\x1b\n" +
	"\x19_set_retention_storage_mbB-\n" +
	"+_set_partition_write_speed_bytes_per_secondB\"\n" +
	" _set_partition_write_burst_bytesJ\x04\b\x06\x10\a\"M\n" +
	"\x12AlterTopicResponse\x127\n" +
	"\toperation\x18\x01 \x01(\v2\x19.Ydb.Operations.OperationR\toperation\"\x12\n" +
	"\x10AlterTopicResult\"r\n" +
	"\x10DropTopicRequest\x12J\n" +
	"\x10operation_params\x18\x01 \x01(\v2\x1f.Ydb.Operations.OperationParamsR\x0foperationParams\x12\x12\n" +
	"\x04path\x18\x02 \x01(\tR\x04path\"L\n" +
	"\x11DropTopicResponse\x127\n" +
	"\toperation\x18\x01 \x01(\v2\x19.Ydb.Operations.OperationR\toperation\"\x11\n" +
	"\x0fDropTopicResult*\x83\x01\n" +
	"\x05Codec\x12\x15\n" +
	"\x11CODEC_UNSPECIFIED\x10\x00\x12\r\n" +
	"\tCODEC_RAW\x10\x01\x12\x0e\n" +
	"\n" +
	"CODEC_GZIP\x10\x02\x12\x0e\n" +
	"\n" +
	"CODEC_LZOP\x10\x03\x12\x0e\n" +
	"\n" +
	"CODEC_ZSTD\x10\x04\x12\x11\n" +
	"\fCODEC_CUSTOM\x10\x90N\"\x05\b\x05\x10\x8fN\"\n" +
	"\b\xa0\x9c\x01\x10\xff\xff\xff\xff\a*\xf1\x01\n" +
	"\x18AutoPartitioningStrategy\x12*\n" +
	"&AUTO_PARTITIONING_STRATEGY_UNSPECIFIED\x10\x00\x12'\n" +
	"#AUTO_PARTITIONING_STRATEGY_DISABLED\x10\x01\x12'\n" +
	"#AUTO_PARTITIONING_STRATEGY_SCALE_UP\x10\x02\x120\n" +
	",AUTO_PARTITIONING_STRATEGY_SCALE_UP_AND_DOWN\x10\x03\x12%\n" +
	"!AUTO_PARTITIONING_STRATEGY_PAUSED\x10\x04*s\n" +
	"\fMeteringMode\x12\x1d\n" +
	"\x19METERING_MODE_UNSPECIFIED\x10\x00\x12#\n" +
	"\x1fMETERING_MODE_RESERVED_CAPACITY\x10\x01\x12\x1f\n" +
	"\x1bMETERING_MODE_REQUEST_UNITS\x10\x02BS\n" +
	"\x14tech.ydb.proto.topicZ8github.com/ydb-platform/ydb-go-genproto/protos/Ydb_Topic\xf8\x01\x01b\x06proto3"

var (
	file_protos_ydb_topic_proto_rawDescOnce sync.Once
	file_protos_ydb_topic_proto_rawDescData []byte
)

func file_protos_ydb_topic_proto_rawDescGZIP() []byte {
	file_protos_ydb_topic_proto_rawDescOnce.Do(func() {
		file_protos_ydb_topic_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_protos_ydb_topic_proto_rawDesc), len(file_protos_ydb_topic_proto_rawDesc)))
	})
	return file_protos_ydb_topic_proto_rawDescData
}

var file_protos_ydb_topic_proto_enumTypes = make([]protoimpl.EnumInfo, 4)
var file_protos_ydb_topic_proto_msgTypes = make([]protoimpl.MessageInfo, 105)
var file_protos_ydb_topic_proto_goTypes = []any{
	(Codec)(0),                    // 0: Ydb.Topic.Codec
	(AutoPartitioningStrategy)(0), // 1: Ydb.Topic.AutoPartitioningStrategy
	(MeteringMode)(0),             // 2: Ydb.Topic.MeteringMode
	(StreamWriteMessage_WriteResponse_WriteAck_Skipped_Reason)(0), // 3: Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.Skipped.Reason
	(*SupportedCodecs)(nil),                                       // 4: Ydb.Topic.SupportedCodecs
	(*OffsetsRange)(nil),                                          // 5: Ydb.Topic.OffsetsRange
	(*UpdateTokenRequest)(nil),                                    // 6: Ydb.Topic.UpdateTokenRequest
	(*UpdateTokenResponse)(nil),                                   // 7: Ydb.Topic.UpdateTokenResponse
	(*PartitionWithGeneration)(nil),                               // 8: Ydb.Topic.PartitionWithGeneration
	(*MetadataItem)(nil),                                          // 9: Ydb.Topic.MetadataItem
	(*StreamWriteMessage)(nil),                                    // 10: Ydb.Topic.StreamWriteMessage
	(*StreamReadMessage)(nil),                                     // 11: Ydb.Topic.StreamReadMessage
	(*StreamDirectReadMessage)(nil),                               // 12: Ydb.Topic.StreamDirectReadMessage
	(*TransactionIdentity)(nil),                                   // 13: Ydb.Topic.TransactionIdentity
	(*UpdateOffsetsInTransactionRequest)(nil),                     // 14: Ydb.Topic.UpdateOffsetsInTransactionRequest
	(*UpdateOffsetsInTransactionResponse)(nil),                    // 15: Ydb.Topic.UpdateOffsetsInTransactionResponse
	(*UpdateOffsetsInTransactionResult)(nil),                      // 16: Ydb.Topic.UpdateOffsetsInTransactionResult
	(*CommitOffsetRequest)(nil),                                   // 17: Ydb.Topic.CommitOffsetRequest
	(*CommitOffsetResponse)(nil),                                  // 18: Ydb.Topic.CommitOffsetResponse
	(*CommitOffsetResult)(nil),                                    // 19: Ydb.Topic.CommitOffsetResult
	(*MultipleWindowsStat)(nil),                                   // 20: Ydb.Topic.MultipleWindowsStat
	(*Consumer)(nil),                                              // 21: Ydb.Topic.Consumer
	(*AlterConsumer)(nil),                                         // 22: Ydb.Topic.AlterConsumer
	(*PartitioningSettings)(nil),                                  // 23: Ydb.Topic.PartitioningSettings
	(*AutoPartitioningSettings)(nil),                              // 24: Ydb.Topic.AutoPartitioningSettings
	(*AutoPartitioningWriteSpeedStrategy)(nil),                    // 25: Ydb.Topic.AutoPartitioningWriteSpeedStrategy
	(*AlterPartitioningSettings)(nil),                             // 26: Ydb.Topic.AlterPartitioningSettings
	(*AlterAutoPartitioningSettings)(nil),                         // 27: Ydb.Topic.AlterAutoPartitioningSettings
	(*AlterAutoPartitioningWriteSpeedStrategy)(nil),               // 28: Ydb.Topic.AlterAutoPartitioningWriteSpeedStrategy
	(*CreateTopicRequest)(nil),                                    // 29: Ydb.Topic.CreateTopicRequest
	(*CreateTopicResponse)(nil),                                   // 30: Ydb.Topic.CreateTopicResponse
	(*CreateTopicResult)(nil),                                     // 31: Ydb.Topic.CreateTopicResult
	(*PartitionLocation)(nil),                                     // 32: Ydb.Topic.PartitionLocation
	(*DescribeTopicRequest)(nil),                                  // 33: Ydb.Topic.DescribeTopicRequest
	(*DescribeTopicResponse)(nil),                                 // 34: Ydb.Topic.DescribeTopicResponse
	(*PartitionKeyRange)(nil),                                     // 35: Ydb.Topic.PartitionKeyRange
	(*DescribeTopicResult)(nil),                                   // 36: Ydb.Topic.DescribeTopicResult
	(*DescribePartitionRequest)(nil),                              // 37: Ydb.Topic.DescribePartitionRequest
	(*DescribePartitionResponse)(nil),                             // 38: Ydb.Topic.DescribePartitionResponse
	(*DescribePartitionResult)(nil),                               // 39: Ydb.Topic.DescribePartitionResult
	(*DescribeConsumerRequest)(nil),                               // 40: Ydb.Topic.DescribeConsumerRequest
	(*DescribeConsumerResponse)(nil),                              // 41: Ydb.Topic.DescribeConsumerResponse
	(*DescribeConsumerResult)(nil),                                // 42: Ydb.Topic.DescribeConsumerResult
	(*PartitionStats)(nil),                                        // 43: Ydb.Topic.PartitionStats
	(*AlterTopicRequest)(nil),                                     // 44: Ydb.Topic.AlterTopicRequest
	(*AlterTopicResponse)(nil),                                    // 45: Ydb.Topic.AlterTopicResponse
	(*AlterTopicResult)(nil),                                      // 46: Ydb.Topic.AlterTopicResult
	(*DropTopicRequest)(nil),                                      // 47: Ydb.Topic.DropTopicRequest
	(*DropTopicResponse)(nil),                                     // 48: Ydb.Topic.DropTopicResponse
	(*DropTopicResult)(nil),                                       // 49: Ydb.Topic.DropTopicResult
	(*StreamWriteMessage_FromClient)(nil),                         // 50: Ydb.Topic.StreamWriteMessage.FromClient
	(*StreamWriteMessage_FromServer)(nil),                         // 51: Ydb.Topic.StreamWriteMessage.FromServer
	(*StreamWriteMessage_InitRequest)(nil),                        // 52: Ydb.Topic.StreamWriteMessage.InitRequest
	(*StreamWriteMessage_InitResponse)(nil),                       // 53: Ydb.Topic.StreamWriteMessage.InitResponse
	(*StreamWriteMessage_WriteRequest)(nil),                       // 54: Ydb.Topic.StreamWriteMessage.WriteRequest
	(*StreamWriteMessage_WriteResponse)(nil),                      // 55: Ydb.Topic.StreamWriteMessage.WriteResponse
	nil,                                                           // 56: Ydb.Topic.StreamWriteMessage.InitRequest.WriteSessionMetaEntry
	(*StreamWriteMessage_WriteRequest_MessageData)(nil),           // 57: Ydb.Topic.StreamWriteMessage.WriteRequest.MessageData
	(*StreamWriteMessage_WriteResponse_WriteAck)(nil),             // 58: Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck
	(*StreamWriteMessage_WriteResponse_WriteStatistics)(nil),      // 59: Ydb.Topic.StreamWriteMessage.WriteResponse.WriteStatistics
	(*StreamWriteMessage_WriteResponse_WriteAck_Written)(nil),     // 60: Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.Written
	(*StreamWriteMessage_WriteResponse_WriteAck_Skipped)(nil),     // 61: Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.Skipped
	(*StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx)(nil), // 62: Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.WrittenInTx
	(*StreamReadMessage_PartitionSession)(nil),                    // 63: Ydb.Topic.StreamReadMessage.PartitionSession
	(*StreamReadMessage_FromClient)(nil),                          // 64: Ydb.Topic.StreamReadMessage.FromClient
	(*StreamReadMessage_FromServer)(nil),                          // 65: Ydb.Topic.StreamReadMessage.FromServer
	(*StreamReadMessage_InitRequest)(nil),                         // 66: Ydb.Topic.StreamReadMessage.InitRequest
	(*StreamReadMessage_InitResponse)(nil),                        // 67: Ydb.Topic.StreamReadMessage.InitResponse
	(*StreamReadMessage_ReadRequest)(nil),                         // 68: Ydb.Topic.StreamReadMessage.ReadRequest
	(*StreamReadMessage_ReadResponse)(nil),                        // 69: Ydb.Topic.StreamReadMessage.ReadResponse
	(*StreamReadMessage_CommitOffsetRequest)(nil),                 // 70: Ydb.Topic.StreamReadMessage.CommitOffsetRequest
	(*StreamReadMessage_CommitOffsetResponse)(nil),                // 71: Ydb.Topic.StreamReadMessage.CommitOffsetResponse
	(*StreamReadMessage_PartitionSessionStatusRequest)(nil),       // 72: Ydb.Topic.StreamReadMessage.PartitionSessionStatusRequest
	(*StreamReadMessage_PartitionSessionStatusResponse)(nil),      // 73: Ydb.Topic.StreamReadMessage.PartitionSessionStatusResponse
	(*StreamReadMessage_StartPartitionSessionRequest)(nil),        // 74: Ydb.Topic.StreamReadMessage.StartPartitionSessionRequest
	(*StreamReadMessage_StartPartitionSessionResponse)(nil),       // 75: Ydb.Topic.StreamReadMessage.StartPartitionSessionResponse
	(*StreamReadMessage_StopPartitionSessionRequest)(nil),         // 76: Ydb.Topic.StreamReadMessage.StopPartitionSessionRequest
	(*StreamReadMessage_StopPartitionSessionResponse)(nil),        // 77: Ydb.Topic.StreamReadMessage.StopPartitionSessionResponse
	(*StreamReadMessage_UpdatePartitionSession)(nil),              // 78: Ydb.Topic.StreamReadMessage.UpdatePartitionSession
	(*StreamReadMessage_DirectReadAck)(nil),                       // 79: Ydb.Topic.StreamReadMessage.DirectReadAck
	(*StreamReadMessage_EndPartitionSession)(nil),                 // 80: Ydb.Topic.StreamReadMessage.EndPartitionSession
	(*StreamReadMessage_InitRequest_TopicReadSettings)(nil),       // 81: Ydb.Topic.StreamReadMessage.InitRequest.TopicReadSettings
	(*StreamReadMessage_ReadResponse_MessageData)(nil),            // 82: Ydb.Topic.StreamReadMessage.ReadResponse.MessageData
	(*StreamReadMessage_ReadResponse_Batch)(nil),                  // 83: Ydb.Topic.StreamReadMessage.ReadResponse.Batch
	(*StreamReadMessage_ReadResponse_PartitionData)(nil),          // 84: Ydb.Topic.StreamReadMessage.ReadResponse.PartitionData
	nil, // 85: Ydb.Topic.StreamReadMessage.ReadResponse.Batch.WriteSessionMetaEntry
	(*StreamReadMessage_CommitOffsetRequest_PartitionCommitOffset)(nil),     // 86: Ydb.Topic.StreamReadMessage.CommitOffsetRequest.PartitionCommitOffset
	(*StreamReadMessage_CommitOffsetResponse_PartitionCommittedOffset)(nil), // 87: Ydb.Topic.StreamReadMessage.CommitOffsetResponse.PartitionCommittedOffset
	(*StreamDirectReadMessage_FromClient)(nil),                              // 88: Ydb.Topic.StreamDirectReadMessage.FromClient
	(*StreamDirectReadMessage_FromServer)(nil),                              // 89: Ydb.Topic.StreamDirectReadMessage.FromServer
	(*StreamDirectReadMessage_InitRequest)(nil),                             // 90: Ydb.Topic.StreamDirectReadMessage.InitRequest
	(*StreamDirectReadMessage_InitResponse)(nil),                            // 91: Ydb.Topic.StreamDirectReadMessage.InitResponse
	(*StreamDirectReadMessage_StartDirectReadPartitionSessionRequest)(nil),  // 92: Ydb.Topic.StreamDirectReadMessage.StartDirectReadPartitionSessionRequest
	(*StreamDirectReadMessage_StartDirectReadPartitionSessionResponse)(nil), // 93: Ydb.Topic.StreamDirectReadMessage.StartDirectReadPartitionSessionResponse
	(*StreamDirectReadMessage_StopDirectReadPartitionSession)(nil),          // 94: Ydb.Topic.StreamDirectReadMessage.StopDirectReadPartitionSession
	(*StreamDirectReadMessage_DirectReadResponse)(nil),                      // 95: Ydb.Topic.StreamDirectReadMessage.DirectReadResponse
	(*StreamDirectReadMessage_InitRequest_TopicReadSettings)(nil),           // 96: Ydb.Topic.StreamDirectReadMessage.InitRequest.TopicReadSettings
	(*UpdateOffsetsInTransactionRequest_TopicOffsets)(nil),                  // 97: Ydb.Topic.UpdateOffsetsInTransactionRequest.TopicOffsets
	(*UpdateOffsetsInTransactionRequest_TopicOffsets_PartitionOffsets)(nil), // 98: Ydb.Topic.UpdateOffsetsInTransactionRequest.TopicOffsets.PartitionOffsets
	nil,                            // 99: Ydb.Topic.Consumer.AttributesEntry
	(*Consumer_ConsumerStats)(nil), // 100: Ydb.Topic.Consumer.ConsumerStats
	nil,                            // 101: Ydb.Topic.AlterConsumer.AlterAttributesEntry
	nil,                            // 102: Ydb.Topic.CreateTopicRequest.AttributesEntry
	nil,                            // 103: Ydb.Topic.DescribeTopicResult.AttributesEntry
	(*DescribeTopicResult_PartitionInfo)(nil),             // 104: Ydb.Topic.DescribeTopicResult.PartitionInfo
	(*DescribeTopicResult_TopicStats)(nil),                // 105: Ydb.Topic.DescribeTopicResult.TopicStats
	(*DescribeConsumerResult_PartitionInfo)(nil),          // 106: Ydb.Topic.DescribeConsumerResult.PartitionInfo
	(*DescribeConsumerResult_PartitionConsumerStats)(nil), // 107: Ydb.Topic.DescribeConsumerResult.PartitionConsumerStats
	nil,                                    // 108: Ydb.Topic.AlterTopicRequest.AlterAttributesEntry
	(*Ydb_Operations.OperationParams)(nil), // 109: Ydb.Operations.OperationParams
	(*Ydb_Operations.Operation)(nil),       // 110: Ydb.Operations.Operation
	(*timestamppb.Timestamp)(nil),          // 111: google.protobuf.Timestamp
	(*durationpb.Duration)(nil),            // 112: google.protobuf.Duration
	(*Ydb_Scheme.Entry)(nil),               // 113: Ydb.Scheme.Entry
	(Ydb.StatusIds_StatusCode)(0),          // 114: Ydb.StatusIds.StatusCode
	(*Ydb_Issue.IssueMessage)(nil),         // 115: Ydb.Issue.IssueMessage
}
var file_protos_ydb_topic_proto_depIdxs = []int32{
	109, // 0: Ydb.Topic.UpdateOffsetsInTransactionRequest.operation_params:type_name -> Ydb.Operations.OperationParams
	13,  // 1: Ydb.Topic.UpdateOffsetsInTransactionRequest.tx:type_name -> Ydb.Topic.TransactionIdentity
	97,  // 2: Ydb.Topic.UpdateOffsetsInTransactionRequest.topics:type_name -> Ydb.Topic.UpdateOffsetsInTransactionRequest.TopicOffsets
	110, // 3: Ydb.Topic.UpdateOffsetsInTransactionResponse.operation:type_name -> Ydb.Operations.Operation
	109, // 4: Ydb.Topic.CommitOffsetRequest.operation_params:type_name -> Ydb.Operations.OperationParams
	110, // 5: Ydb.Topic.CommitOffsetResponse.operation:type_name -> Ydb.Operations.Operation
	111, // 6: Ydb.Topic.Consumer.read_from:type_name -> google.protobuf.Timestamp
	4,   // 7: Ydb.Topic.Consumer.supported_codecs:type_name -> Ydb.Topic.SupportedCodecs
	99,  // 8: Ydb.Topic.Consumer.attributes:type_name -> Ydb.Topic.Consumer.AttributesEntry
	100, // 9: Ydb.Topic.Consumer.consumer_stats:type_name -> Ydb.Topic.Consumer.ConsumerStats
	111, // 10: Ydb.Topic.AlterConsumer.set_read_from:type_name -> google.protobuf.Timestamp
	4,   // 11: Ydb.Topic.AlterConsumer.set_supported_codecs:type_name -> Ydb.Topic.SupportedCodecs
	101, // 12: Ydb.Topic.AlterConsumer.alter_attributes:type_name -> Ydb.Topic.AlterConsumer.AlterAttributesEntry
	24,  // 13: Ydb.Topic.PartitioningSettings.auto_partitioning_settings:type_name -> Ydb.Topic.AutoPartitioningSettings
	1,   // 14: Ydb.Topic.AutoPartitioningSettings.strategy:type_name -> Ydb.Topic.AutoPartitioningStrategy
	25,  // 15: Ydb.Topic.AutoPartitioningSettings.partition_write_speed:type_name -> Ydb.Topic.AutoPartitioningWriteSpeedStrategy
	112, // 16: Ydb.Topic.AutoPartitioningWriteSpeedStrategy.stabilization_window:type_name -> google.protobuf.Duration
	27,  // 17: Ydb.Topic.AlterPartitioningSettings.alter_auto_partitioning_settings:type_name -> Ydb.Topic.AlterAutoPartitioningSettings
	1,   // 18: Ydb.Topic.AlterAutoPartitioningSettings.set_strategy:type_name -> Ydb.Topic.AutoPartitioningStrategy
	28,  // 19: Ydb.Topic.AlterAutoPartitioningSettings.set_partition_write_speed:type_name -> Ydb.Topic.AlterAutoPartitioningWriteSpeedStrategy
	112, // 20: Ydb.Topic.AlterAutoPartitioningWriteSpeedStrategy.set_stabilization_window:type_name -> google.protobuf.Duration
	109, // 21: Ydb.Topic.CreateTopicRequest.operation_params:type_name -> Ydb.Operations.OperationParams
	23,  // 22: Ydb.Topic.CreateTopicRequest.partitioning_settings:type_name -> Ydb.Topic.PartitioningSettings
	112, // 23: Ydb.Topic.CreateTopicRequest.retention_period:type_name -> google.protobuf.Duration
	4,   // 24: Ydb.Topic.CreateTopicRequest.supported_codecs:type_name -> Ydb.Topic.SupportedCodecs
	102, // 25: Ydb.Topic.CreateTopicRequest.attributes:type_name -> Ydb.Topic.CreateTopicRequest.AttributesEntry
	21,  // 26: Ydb.Topic.CreateTopicRequest.consumers:type_name -> Ydb.Topic.Consumer
	2,   // 27: Ydb.Topic.CreateTopicRequest.metering_mode:type_name -> Ydb.Topic.MeteringMode
	110, // 28: Ydb.Topic.CreateTopicResponse.operation:type_name -> Ydb.Operations.Operation
	109, // 29: Ydb.Topic.DescribeTopicRequest.operation_params:type_name -> Ydb.Operations.OperationParams
	110, // 30: Ydb.Topic.DescribeTopicResponse.operation:type_name -> Ydb.Operations.Operation
	113, // 31: Ydb.Topic.DescribeTopicResult.self:type_name -> Ydb.Scheme.Entry
	23,  // 32: Ydb.Topic.DescribeTopicResult.partitioning_settings:type_name -> Ydb.Topic.PartitioningSettings
	104, // 33: Ydb.Topic.DescribeTopicResult.partitions:type_name -> Ydb.Topic.DescribeTopicResult.PartitionInfo
	112, // 34: Ydb.Topic.DescribeTopicResult.retention_period:type_name -> google.protobuf.Duration
	4,   // 35: Ydb.Topic.DescribeTopicResult.supported_codecs:type_name -> Ydb.Topic.SupportedCodecs
	103, // 36: Ydb.Topic.DescribeTopicResult.attributes:type_name -> Ydb.Topic.DescribeTopicResult.AttributesEntry
	21,  // 37: Ydb.Topic.DescribeTopicResult.consumers:type_name -> Ydb.Topic.Consumer
	2,   // 38: Ydb.Topic.DescribeTopicResult.metering_mode:type_name -> Ydb.Topic.MeteringMode
	105, // 39: Ydb.Topic.DescribeTopicResult.topic_stats:type_name -> Ydb.Topic.DescribeTopicResult.TopicStats
	109, // 40: Ydb.Topic.DescribePartitionRequest.operation_params:type_name -> Ydb.Operations.OperationParams
	110, // 41: Ydb.Topic.DescribePartitionResponse.operation:type_name -> Ydb.Operations.Operation
	104, // 42: Ydb.Topic.DescribePartitionResult.partition:type_name -> Ydb.Topic.DescribeTopicResult.PartitionInfo
	109, // 43: Ydb.Topic.DescribeConsumerRequest.operation_params:type_name -> Ydb.Operations.OperationParams
	110, // 44: Ydb.Topic.DescribeConsumerResponse.operation:type_name -> Ydb.Operations.Operation
	113, // 45: Ydb.Topic.DescribeConsumerResult.self:type_name -> Ydb.Scheme.Entry
	21,  // 46: Ydb.Topic.DescribeConsumerResult.consumer:type_name -> Ydb.Topic.Consumer
	106, // 47: Ydb.Topic.DescribeConsumerResult.partitions:type_name -> Ydb.Topic.DescribeConsumerResult.PartitionInfo
	5,   // 48: Ydb.Topic.PartitionStats.partition_offsets:type_name -> Ydb.Topic.OffsetsRange
	111, // 49: Ydb.Topic.PartitionStats.last_write_time:type_name -> google.protobuf.Timestamp
	112, // 50: Ydb.Topic.PartitionStats.max_write_time_lag:type_name -> google.protobuf.Duration
	20,  // 51: Ydb.Topic.PartitionStats.bytes_written:type_name -> Ydb.Topic.MultipleWindowsStat
	109, // 52: Ydb.Topic.AlterTopicRequest.operation_params:type_name -> Ydb.Operations.OperationParams
	26,  // 53: Ydb.Topic.AlterTopicRequest.alter_partitioning_settings:type_name -> Ydb.Topic.AlterPartitioningSettings
	112, // 54: Ydb.Topic.AlterTopicRequest.set_retention_period:type_name -> google.protobuf.Duration
	4,   // 55: Ydb.Topic.AlterTopicRequest.set_supported_codecs:type_name -> Ydb.Topic.SupportedCodecs
	108, // 56: Ydb.Topic.AlterTopicRequest.alter_attributes:type_name -> Ydb.Topic.AlterTopicRequest.AlterAttributesEntry
	21,  // 57: Ydb.Topic.AlterTopicRequest.add_consumers:type_name -> Ydb.Topic.Consumer
	22,  // 58: Ydb.Topic.AlterTopicRequest.alter_consumers:type_name -> Ydb.Topic.AlterConsumer
	2,   // 59: Ydb.Topic.AlterTopicRequest.set_metering_mode:type_name -> Ydb.Topic.MeteringMode
	110, // 60: Ydb.Topic.AlterTopicResponse.operation:type_name -> Ydb.Operations.Operation
	109, // 61: Ydb.Topic.DropTopicRequest.operation_params:type_name -> Ydb.Operations.OperationParams
	110, // 62: Ydb.Topic.DropTopicResponse.operation:type_name -> Ydb.Operations.Operation
	52,  // 63: Ydb.Topic.StreamWriteMessage.FromClient.init_request:type_name -> Ydb.Topic.StreamWriteMessage.InitRequest
	54,  // 64: Ydb.Topic.StreamWriteMessage.FromClient.write_request:type_name -> Ydb.Topic.StreamWriteMessage.WriteRequest
	6,   // 65: Ydb.Topic.StreamWriteMessage.FromClient.update_token_request:type_name -> Ydb.Topic.UpdateTokenRequest
	114, // 66: Ydb.Topic.StreamWriteMessage.FromServer.status:type_name -> Ydb.StatusIds.StatusCode
	115, // 67: Ydb.Topic.StreamWriteMessage.FromServer.issues:type_name -> Ydb.Issue.IssueMessage
	53,  // 68: Ydb.Topic.StreamWriteMessage.FromServer.init_response:type_name -> Ydb.Topic.StreamWriteMessage.InitResponse
	55,  // 69: Ydb.Topic.StreamWriteMessage.FromServer.write_response:type_name -> Ydb.Topic.StreamWriteMessage.WriteResponse
	7,   // 70: Ydb.Topic.StreamWriteMessage.FromServer.update_token_response:type_name -> Ydb.Topic.UpdateTokenResponse
	56,  // 71: Ydb.Topic.StreamWriteMessage.InitRequest.write_session_meta:type_name -> Ydb.Topic.StreamWriteMessage.InitRequest.WriteSessionMetaEntry
	8,   // 72: Ydb.Topic.StreamWriteMessage.InitRequest.partition_with_generation:type_name -> Ydb.Topic.PartitionWithGeneration
	4,   // 73: Ydb.Topic.StreamWriteMessage.InitResponse.supported_codecs:type_name -> Ydb.Topic.SupportedCodecs
	57,  // 74: Ydb.Topic.StreamWriteMessage.WriteRequest.messages:type_name -> Ydb.Topic.StreamWriteMessage.WriteRequest.MessageData
	13,  // 75: Ydb.Topic.StreamWriteMessage.WriteRequest.tx:type_name -> Ydb.Topic.TransactionIdentity
	58,  // 76: Ydb.Topic.StreamWriteMessage.WriteResponse.acks:type_name -> Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck
	59,  // 77: Ydb.Topic.StreamWriteMessage.WriteResponse.write_statistics:type_name -> Ydb.Topic.StreamWriteMessage.WriteResponse.WriteStatistics
	111, // 78: Ydb.Topic.StreamWriteMessage.WriteRequest.MessageData.created_at:type_name -> google.protobuf.Timestamp
	8,   // 79: Ydb.Topic.StreamWriteMessage.WriteRequest.MessageData.partition_with_generation:type_name -> Ydb.Topic.PartitionWithGeneration
	9,   // 80: Ydb.Topic.StreamWriteMessage.WriteRequest.MessageData.metadata_items:type_name -> Ydb.Topic.MetadataItem
	60,  // 81: Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.written:type_name -> Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.Written
	61,  // 82: Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.skipped:type_name -> Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.Skipped
	62,  // 83: Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.written_in_tx:type_name -> Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.WrittenInTx
	112, // 84: Ydb.Topic.StreamWriteMessage.WriteResponse.WriteStatistics.persisting_time:type_name -> google.protobuf.Duration
	112, // 85: Ydb.Topic.StreamWriteMessage.WriteResponse.WriteStatistics.min_queue_wait_time:type_name -> google.protobuf.Duration
	112, // 86: Ydb.Topic.StreamWriteMessage.WriteResponse.WriteStatistics.max_queue_wait_time:type_name -> google.protobuf.Duration
	112, // 87: Ydb.Topic.StreamWriteMessage.WriteResponse.WriteStatistics.partition_quota_wait_time:type_name -> google.protobuf.Duration
	112, // 88: Ydb.Topic.StreamWriteMessage.WriteResponse.WriteStatistics.topic_quota_wait_time:type_name -> google.protobuf.Duration
	3,   // 89: Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.Skipped.reason:type_name -> Ydb.Topic.StreamWriteMessage.WriteResponse.WriteAck.Skipped.Reason
	66,  // 90: Ydb.Topic.StreamReadMessage.FromClient.init_request:type_name -> Ydb.Topic.StreamReadMessage.InitRequest
	68,  // 91: Ydb.Topic.StreamReadMessage.FromClient.read_request:type_name -> Ydb.Topic.StreamReadMessage.ReadRequest
	70,  // 92: Ydb.Topic.StreamReadMessage.FromClient.commit_offset_request:type_name -> Ydb.Topic.StreamReadMessage.CommitOffsetRequest
	72,  // 93: Ydb.Topic.StreamReadMessage.FromClient.partition_session_status_request:type_name -> Ydb.Topic.StreamReadMessage.PartitionSessionStatusRequest
	6,   // 94: Ydb.Topic.StreamReadMessage.FromClient.update_token_request:type_name -> Ydb.Topic.UpdateTokenRequest
	79,  // 95: Ydb.Topic.StreamReadMessage.FromClient.direct_read_ack:type_name -> Ydb.Topic.StreamReadMessage.DirectReadAck
	75,  // 96: Ydb.Topic.StreamReadMessage.FromClient.start_partition_session_response:type_name -> Ydb.Topic.StreamReadMessage.StartPartitionSessionResponse
	77,  // 97: Ydb.Topic.StreamReadMessage.FromClient.stop_partition_session_response:type_name -> Ydb.Topic.StreamReadMessage.StopPartitionSessionResponse
	114, // 98: Ydb.Topic.StreamReadMessage.FromServer.status:type_name -> Ydb.StatusIds.StatusCode
	115, // 99: Ydb.Topic.StreamReadMessage.FromServer.issues:type_name -> Ydb.Issue.IssueMessage
	67,  // 100: Ydb.Topic.StreamReadMessage.FromServer.init_response:type_name -> Ydb.Topic.StreamReadMessage.InitResponse
	69,  // 101: Ydb.Topic.StreamReadMessage.FromServer.read_response:type_name -> Ydb.Topic.StreamReadMessage.ReadResponse
	71,  // 102: Ydb.Topic.StreamReadMessage.FromServer.commit_offset_response:type_name -> Ydb.Topic.StreamReadMessage.CommitOffsetResponse
	73,  // 103: Ydb.Topic.StreamReadMessage.FromServer.partition_session_status_response:type_name -> Ydb.Topic.StreamReadMessage.PartitionSessionStatusResponse
	7,   // 104: Ydb.Topic.StreamReadMessage.FromServer.update_token_response:type_name -> Ydb.Topic.UpdateTokenResponse
	74,  // 105: Ydb.Topic.StreamReadMessage.FromServer.start_partition_session_request:type_name -> Ydb.Topic.StreamReadMessage.StartPartitionSessionRequest
	76,  // 106: Ydb.Topic.StreamReadMessage.FromServer.stop_partition_session_request:type_name -> Ydb.Topic.StreamReadMessage.StopPartitionSessionRequest
	78,  // 107: Ydb.Topic.StreamReadMessage.FromServer.update_partition_session:type_name -> Ydb.Topic.StreamReadMessage.UpdatePartitionSession
	80,  // 108: Ydb.Topic.StreamReadMessage.FromServer.end_partition_session:type_name -> Ydb.Topic.StreamReadMessage.EndPartitionSession
	81,  // 109: Ydb.Topic.StreamReadMessage.InitRequest.topics_read_settings:type_name -> Ydb.Topic.StreamReadMessage.InitRequest.TopicReadSettings
	84,  // 110: Ydb.Topic.StreamReadMessage.ReadResponse.partition_data:type_name -> Ydb.Topic.StreamReadMessage.ReadResponse.PartitionData
	86,  // 111: Ydb.Topic.StreamReadMessage.CommitOffsetRequest.commit_offsets:type_name -> Ydb.Topic.StreamReadMessage.CommitOffsetRequest.PartitionCommitOffset
	87,  // 112: Ydb.Topic.StreamReadMessage.CommitOffsetResponse.partitions_committed_offsets:type_name -> Ydb.Topic.StreamReadMessage.CommitOffsetResponse.PartitionCommittedOffset
	5,   // 113: Ydb.Topic.StreamReadMessage.PartitionSessionStatusResponse.partition_offsets:type_name -> Ydb.Topic.OffsetsRange
	111, // 114: Ydb.Topic.StreamReadMessage.PartitionSessionStatusResponse.write_time_high_watermark:type_name -> google.protobuf.Timestamp
	63,  // 115: Ydb.Topic.StreamReadMessage.StartPartitionSessionRequest.partition_session:type_name -> Ydb.Topic.StreamReadMessage.PartitionSession
	5,   // 116: Ydb.Topic.StreamReadMessage.StartPartitionSessionRequest.partition_offsets:type_name -> Ydb.Topic.OffsetsRange
	32,  // 117: Ydb.Topic.StreamReadMessage.StartPartitionSessionRequest.partition_location:type_name -> Ydb.Topic.PartitionLocation
	32,  // 118: Ydb.Topic.StreamReadMessage.UpdatePartitionSession.partition_location:type_name -> Ydb.Topic.PartitionLocation
	112, // 119: Ydb.Topic.StreamReadMessage.InitRequest.TopicReadSettings.max_lag:type_name -> google.protobuf.Duration
	111, // 120: Ydb.Topic.StreamReadMessage.InitRequest.TopicReadSettings.read_from:type_name -> google.protobuf.Timestamp
	111, // 121: Ydb.Topic.StreamReadMessage.ReadResponse.MessageData.created_at:type_name -> google.protobuf.Timestamp
	9,   // 122: Ydb.Topic.StreamReadMessage.ReadResponse.MessageData.metadata_items:type_name -> Ydb.Topic.MetadataItem
	82,  // 123: Ydb.Topic.StreamReadMessage.ReadResponse.Batch.message_data:type_name -> Ydb.Topic.StreamReadMessage.ReadResponse.MessageData
	85,  // 124: Ydb.Topic.StreamReadMessage.ReadResponse.Batch.write_session_meta:type_name -> Ydb.Topic.StreamReadMessage.ReadResponse.Batch.WriteSessionMetaEntry
	111, // 125: Ydb.Topic.StreamReadMessage.ReadResponse.Batch.written_at:type_name -> google.protobuf.Timestamp
	83,  // 126: Ydb.Topic.StreamReadMessage.ReadResponse.PartitionData.batches:type_name -> Ydb.Topic.StreamReadMessage.ReadResponse.Batch
	5,   // 127: Ydb.Topic.StreamReadMessage.CommitOffsetRequest.PartitionCommitOffset.offsets:type_name -> Ydb.Topic.OffsetsRange
	90,  // 128: Ydb.Topic.StreamDirectReadMessage.FromClient.init_request:type_name -> Ydb.Topic.StreamDirectReadMessage.InitRequest
	92,  // 129: Ydb.Topic.StreamDirectReadMessage.FromClient.start_direct_read_partition_session_request:type_name -> Ydb.Topic.StreamDirectReadMessage.StartDirectReadPartitionSessionRequest
	6,   // 130: Ydb.Topic.StreamDirectReadMessage.FromClient.update_token_request:type_name -> Ydb.Topic.UpdateTokenRequest
	114, // 131: Ydb.Topic.StreamDirectReadMessage.FromServer.status:type_name -> Ydb.StatusIds.StatusCode
	115, // 132: Ydb.Topic.StreamDirectReadMessage.FromServer.issues:type_name -> Ydb.Issue.IssueMessage
	91,  // 133: Ydb.Topic.StreamDirectReadMessage.FromServer.init_response:type_name -> Ydb.Topic.StreamDirectReadMessage.InitResponse
	93,  // 134: Ydb.Topic.StreamDirectReadMessage.FromServer.start_direct_read_partition_session_response:type_name -> Ydb.Topic.StreamDirectReadMessage.StartDirectReadPartitionSessionResponse
	94,  // 135: Ydb.Topic.StreamDirectReadMessage.FromServer.stop_direct_read_partition_session:type_name -> Ydb.Topic.StreamDirectReadMessage.StopDirectReadPartitionSession
	95,  // 136: Ydb.Topic.StreamDirectReadMessage.FromServer.direct_read_response:type_name -> Ydb.Topic.StreamDirectReadMessage.DirectReadResponse
	7,   // 137: Ydb.Topic.StreamDirectReadMessage.FromServer.update_token_response:type_name -> Ydb.Topic.UpdateTokenResponse
	96,  // 138: Ydb.Topic.StreamDirectReadMessage.InitRequest.topics_read_settings:type_name -> Ydb.Topic.StreamDirectReadMessage.InitRequest.TopicReadSettings
	114, // 139: Ydb.Topic.StreamDirectReadMessage.StopDirectReadPartitionSession.status:type_name -> Ydb.StatusIds.StatusCode
	115, // 140: Ydb.Topic.StreamDirectReadMessage.StopDirectReadPartitionSession.issues:type_name -> Ydb.Issue.IssueMessage
	84,  // 141: Ydb.Topic.StreamDirectReadMessage.DirectReadResponse.partition_data:type_name -> Ydb.Topic.StreamReadMessage.ReadResponse.PartitionData
	98,  // 142: Ydb.Topic.UpdateOffsetsInTransactionRequest.TopicOffsets.partitions:type_name -> Ydb.Topic.UpdateOffsetsInTransactionRequest.TopicOffsets.PartitionOffsets
	5,   // 143: Ydb.Topic.UpdateOffsetsInTransactionRequest.TopicOffsets.PartitionOffsets.partition_offsets:type_name -> Ydb.Topic.OffsetsRange
	111, // 144: Ydb.Topic.Consumer.ConsumerStats.min_partitions_last_read_time:type_name -> google.protobuf.Timestamp
	112, // 145: Ydb.Topic.Consumer.ConsumerStats.max_read_time_lag:type_name -> google.protobuf.Duration
	112, // 146: Ydb.Topic.Consumer.ConsumerStats.max_write_time_lag:type_name -> google.protobuf.Duration
	20,  // 147: Ydb.Topic.Consumer.ConsumerStats.bytes_read:type_name -> Ydb.Topic.MultipleWindowsStat
	43,  // 148: Ydb.Topic.DescribeTopicResult.PartitionInfo.partition_stats:type_name -> Ydb.Topic.PartitionStats
	32,  // 149: Ydb.Topic.DescribeTopicResult.PartitionInfo.partition_location:type_name -> Ydb.Topic.PartitionLocation
	35,  // 150: Ydb.Topic.DescribeTopicResult.PartitionInfo.key_range:type_name -> Ydb.Topic.PartitionKeyRange
	111, // 151: Ydb.Topic.DescribeTopicResult.TopicStats.min_last_write_time:type_name -> google.protobuf.Timestamp
	112, // 152: Ydb.Topic.DescribeTopicResult.TopicStats.max_write_time_lag:type_name -> google.protobuf.Duration
	20,  // 153: Ydb.Topic.DescribeTopicResult.TopicStats.bytes_written:type_name -> Ydb.Topic.MultipleWindowsStat
	43,  // 154: Ydb.Topic.DescribeConsumerResult.PartitionInfo.partition_stats:type_name -> Ydb.Topic.PartitionStats
	107, // 155: Ydb.Topic.DescribeConsumerResult.PartitionInfo.partition_consumer_stats:type_name -> Ydb.Topic.DescribeConsumerResult.PartitionConsumerStats
	32,  // 156: Ydb.Topic.DescribeConsumerResult.PartitionInfo.partition_location:type_name -> Ydb.Topic.PartitionLocation
	111, // 157: Ydb.Topic.DescribeConsumerResult.PartitionConsumerStats.partition_read_session_create_time:type_name -> google.protobuf.Timestamp
	111, // 158: Ydb.Topic.DescribeConsumerResult.PartitionConsumerStats.last_read_time:type_name -> google.protobuf.Timestamp
	112, // 159: Ydb.Topic.DescribeConsumerResult.PartitionConsumerStats.max_read_time_lag:type_name -> google.protobuf.Duration
	112, // 160: Ydb.Topic.DescribeConsumerResult.PartitionConsumerStats.max_write_time_lag:type_name -> google.protobuf.Duration
	20,  // 161: Ydb.Topic.DescribeConsumerResult.PartitionConsumerStats.bytes_read:type_name -> Ydb.Topic.MultipleWindowsStat
	162, // [162:162] is the sub-list for method output_type
	162, // [162:162] is the sub-list for method input_type
	162, // [162:162] is the sub-list for extension type_name
	162, // [162:162] is the sub-list for extension extendee
	0,   // [0:162] is the sub-list for field type_name
}

func init() { file_protos_ydb_topic_proto_init() }
func file_protos_ydb_topic_proto_init() {
	if File_protos_ydb_topic_proto != nil {
		return
	}
	file_protos_ydb_topic_proto_msgTypes[18].OneofWrappers = []any{}
	file_protos_ydb_topic_proto_msgTypes[22].OneofWrappers = []any{}
	file_protos_ydb_topic_proto_msgTypes[23].OneofWrappers = []any{}
	file_protos_ydb_topic_proto_msgTypes[24].OneofWrappers = []any{}
	file_protos_ydb_topic_proto_msgTypes[31].OneofWrappers = []any{}
	file_protos_ydb_topic_proto_msgTypes[40].OneofWrappers = []any{}
	file_protos_ydb_topic_proto_msgTypes[46].OneofWrappers = []any{
		(*StreamWriteMessage_FromClient_InitRequest)(nil),
		(*StreamWriteMessage_FromClient_WriteRequest)(nil),
		(*StreamWriteMessage_FromClient_UpdateTokenRequest)(nil),
	}
	file_protos_ydb_topic_proto_msgTypes[47].OneofWrappers = []any{
		(*StreamWriteMessage_FromServer_InitResponse)(nil),
		(*StreamWriteMessage_FromServer_WriteResponse)(nil),
		(*StreamWriteMessage_FromServer_UpdateTokenResponse)(nil),
	}
	file_protos_ydb_topic_proto_msgTypes[48].OneofWrappers = []any{
		(*StreamWriteMessage_InitRequest_MessageGroupId)(nil),
		(*StreamWriteMessage_InitRequest_PartitionId)(nil),
		(*StreamWriteMessage_InitRequest_PartitionWithGeneration)(nil),
	}
	file_protos_ydb_topic_proto_msgTypes[50].OneofWrappers = []any{}
	file_protos_ydb_topic_proto_msgTypes[53].OneofWrappers = []any{
		(*StreamWriteMessage_WriteRequest_MessageData_MessageGroupId)(nil),
		(*StreamWriteMessage_WriteRequest_MessageData_PartitionId)(nil),
		(*StreamWriteMessage_WriteRequest_MessageData_PartitionWithGeneration)(nil),
	}
	file_protos_ydb_topic_proto_msgTypes[54].OneofWrappers = []any{
		(*StreamWriteMessage_WriteResponse_WriteAck_Written_)(nil),
		(*StreamWriteMessage_WriteResponse_WriteAck_Skipped_)(nil),
		(*StreamWriteMessage_WriteResponse_WriteAck_WrittenInTx_)(nil),
	}
	file_protos_ydb_topic_proto_msgTypes[60].OneofWrappers = []any{
		(*StreamReadMessage_FromClient_InitRequest)(nil),
		(*StreamReadMessage_FromClient_ReadRequest)(nil),
		(*StreamReadMessage_FromClient_CommitOffsetRequest)(nil),
		(*StreamReadMessage_FromClient_PartitionSessionStatusRequest)(nil),
		(*StreamReadMessage_FromClient_UpdateTokenRequest)(nil),
		(*StreamReadMessage_FromClient_DirectReadAck)(nil),
		(*StreamReadMessage_FromClient_StartPartitionSessionResponse)(nil),
		(*StreamReadMessage_FromClient_StopPartitionSessionResponse)(nil),
	}
	file_protos_ydb_topic_proto_msgTypes[61].OneofWrappers = []any{
		(*StreamReadMessage_FromServer_InitResponse)(nil),
		(*StreamReadMessage_FromServer_ReadResponse)(nil),
		(*StreamReadMessage_FromServer_CommitOffsetResponse)(nil),
		(*StreamReadMessage_FromServer_PartitionSessionStatusResponse)(nil),
		(*StreamReadMessage_FromServer_UpdateTokenResponse)(nil),
		(*StreamReadMessage_FromServer_StartPartitionSessionRequest)(nil),
		(*StreamReadMessage_FromServer_StopPartitionSessionRequest)(nil),
		(*StreamReadMessage_FromServer_UpdatePartitionSession)(nil),
		(*StreamReadMessage_FromServer_EndPartitionSession)(nil),
	}
	file_protos_ydb_topic_proto_msgTypes[71].OneofWrappers = []any{}
	file_protos_ydb_topic_proto_msgTypes[84].OneofWrappers = []any{
		(*StreamDirectReadMessage_FromClient_InitRequest)(nil),
		(*StreamDirectReadMessage_FromClient_StartDirectReadPartitionSessionRequest)(nil),
		(*StreamDirectReadMessage_FromClient_UpdateTokenRequest)(nil),
	}
	file_protos_ydb_topic_proto_msgTypes[85].OneofWrappers = []any{
		(*StreamDirectReadMessage_FromServer_InitResponse)(nil),
		(*StreamDirectReadMessage_FromServer_StartDirectReadPartitionSessionResponse)(nil),
		(*StreamDirectReadMessage_FromServer_StopDirectReadPartitionSession)(nil),
		(*StreamDirectReadMessage_FromServer_DirectReadResponse)(nil),
		(*StreamDirectReadMessage_FromServer_UpdateTokenResponse)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_protos_ydb_topic_proto_rawDesc), len(file_protos_ydb_topic_proto_rawDesc)),
			NumEnums:      4,
			NumMessages:   105,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_protos_ydb_topic_proto_goTypes,
		DependencyIndexes: file_protos_ydb_topic_proto_depIdxs,
		EnumInfos:         file_protos_ydb_topic_proto_enumTypes,
		MessageInfos:      file_protos_ydb_topic_proto_msgTypes,
	}.Build()
	File_protos_ydb_topic_proto = out.File
	file_protos_ydb_topic_proto_goTypes = nil
	file_protos_ydb_topic_proto_depIdxs = nil
}
